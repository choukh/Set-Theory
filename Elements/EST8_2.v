(** Adapted from "Elements of Set Theory" Chapter 8 **)
(** Coq coding by choukh, Feb 2021 **)

Require Import ZFC.Lib.Class.
Require Import ZFC.Lib.FuncFacts.
Require Export ZFC.Elements.EST8_1.
Import OrdinalClass.

(*** EST第八章2：序数运算的性质，Veblen不动点定理 ***)

(* ex8_3_a 单调运算保序 *)
Fact monotone_operation_preserve_order :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → monotone F →
  ∀ α β ⋵ 𝐎𝐍, α ∈ β ↔ F α ∈ F β.
Proof with auto.
  intros F HF Hmono α Hoα β Hoβ. split. apply Hmono...
  intros Hlt. destruct (classic (α = β)) as [|Hnq]. {
    exfalso. subst. apply (ord_irrefl (F β))...
  }
  apply ord_connected in Hnq as []...
  exfalso. apply Hmono in H...
  apply (ord_not_lt_gt (F α) (HF α Hoα) (F β))...
Qed.

(* ex8_4 规范运算在极限处的值是极限 *)
Fact normal_operation_limit_is_limit :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  ∀𝜆 ⋵ 𝐎𝐍ˡⁱᵐ, 𝜆 ≠ ∅ → F 𝜆 ⋵ 𝐎𝐍ˡⁱᵐ.
Proof with auto.
  intros F HF [Hmono Hcon] 𝜆 Hlim Hne.
  rewrite Hcon... split. {
    apply union_of_ords_is_ord. intros x Hx.
    apply ReplAx in Hx as [α [Hα HFα]]. subst x.
    apply HF. apply (ord_is_ords 𝜆)...
  }
  ext Hx.
  - apply FUnionE in Hx as [α [Hα HFα]].
    apply UnionAx. exists (F α). split...
    eapply FUnionI... apply sucord_in_limord...
    apply Hα. apply Hmono... apply ord_suc_is_ord.
    apply (ord_is_ords 𝜆)...
  - apply UnionAx in Hx as [α [Hα Hx]].
    apply FUnionE in Hα as [β [Hβ HFβ]].
    eapply FUnionI... apply Hβ. eapply ord_trans; eauto.
    apply HF. apply (ord_is_ords 𝜆)...
Qed.

(* 规范运算的定义域有最大元 *)
Theorem normal_operation_domain_has_maximum :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → ∀β ⋵ 𝐎𝐍, F 0 ∈ β →
  ∃γ ⋵ 𝐎𝐍, ε_maximum γ (Domain F (RangeAmong F β⁺)).
Proof with eauto.
  intros F HF [Hmono Hcon] β Hoβ Hlt.
  set (λ y, ∃α ⋵ 𝐎𝐍, F α = y) as C.
  assert (Hsur: F :ᶜ 𝐎𝐍 ⟹ C). {
    split. intros ξ Hoξ. exists ξ. split... intros ξ H...
  }
  assert (Hsub: C ⫃ 𝐎𝐍). {
    intros ξ [α [Hoα Heq]]. subst ξ. apply HF...
  }
  assert (Hinj: class_injective F 𝐎𝐍). {
    eapply monotone_operation_injective...
  }
  assert (Hran: ∀x ∈ RangeAmong F β⁺, x ⋵ C). {
    intros ξ Hξ. apply SepE2 in Hξ...
  }
  set (Domain F (RangeAmong F β⁺)) as γ.
  assert (Hoγ: γ ⋵ 𝐎𝐍). {
    apply transitive_set_well_ordered_by_epsilon_is_ord.
    - intros x y Hxy Hy.
      eapply domain_spec in Hy as [Hoy HFy]...
      assert (Hox: x ⋵ 𝐎𝐍). eapply ord_is_ords...
      eapply domain_spec... split...
      apply SepI; [apply SepE1 in HFy|exists x; split]...
      eapply ord_trans; revgoals...
    - apply ords_woset. intros x Hx. eapply domain_spec...
  }
  ord_destruct γ.
  - exfalso. eapply EmptyNI... exists 0.
    eapply domain_spec... split... apply SepI.
    apply BUnionI1... exists 0. split...
  - destruct Hsuc as [μ [Hoμ Heq]]. rewrite Heq.
    exists μ. split... split... intros x Hx.
    apply ord_le_iff_lt_suc... eapply ord_is_ords; revgoals...
  - exfalso. apply (ord_irrefl γ)...
    eapply domain_spec... split...
    apply SepI; [|exists γ; split]...
    apply ord_le_iff_lt_suc...
    rewrite Hcon... apply ord_sup_correct.
    + intros x Hx. apply ReplAx in Hx as [α [Hα Heq]].
      subst x. apply HF. eapply ord_is_ords...
    + split... intros x Hx.
      apply ReplAx in Hx as [α [Hα Heq]]. subst x.
      eapply domain_spec in Hα as [Hα HFα]...
      apply SepE1 in HFα. apply ord_le_iff_lt_suc...
Qed.

(* 序数集上界的规范运算等于序数集规范运算的上界 *)
Theorem operation_of_sup_eq_sup_of_operation :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → ∀ S, S ⪽ 𝐎𝐍 → S ≠ ∅ →
  F (sup S) = sup (Range F S).
Proof with eauto; try congruence.
  intros F HF [Hmono Hcon] S Hos Hne.
  assert (HoS: sup S ⋵ 𝐎𝐍). apply union_of_ords_is_ord...
  assert (HoF: F (sup S) ⋵ 𝐎𝐍). apply HF...
  assert (HosR: Range F S ⪽ 𝐎𝐍). {
    intros x Hx. apply ReplAx in Hx as [α [Hoα Heq]].
    subst x. apply HF. apply Hos...
  }
  assert (HoR: sup (Range F S) ⋵ 𝐎𝐍). {
    apply union_of_ords_is_ord...
  }
  ord_ext; revgoals...
  - apply ord_sup_correct... split...
    intros ξ Hξ. apply ReplAx in Hξ as [α [Hoα Heq]].
    subst ξ. apply ord_sup_is_ub in Hos as [Ho Hle].
    apply Hle in Hoα as []; [left|right]...
  - ord_destruct (sup S).
    + rewrite H0. apply union_eq_empty in H0 as []...
      apply ord_sup_is_ub... rewrite H.
      eapply ReplI. apply SingI.
    + apply ord_sup_correct... eapply ReplI.
      apply sup_ords_is_sucord_impl_in...
    + rewrite Hcon... apply ord_sup_correct.
      * intros x Hx. apply ReplAx in Hx as [α [Hα Heq]].
        subst x. apply HF. apply (ord_is_ords (sup S))...
      * split... intros ξ Hξ. left.
        apply ReplAx in Hξ as [α [Hα Heq]]. subst ξ.
        apply UnionAx in Hα as [γ [Hγ Hα]].
        apply UnionAx. exists (F γ). split.
        eapply ReplI... apply Hmono...
Qed.

(* ex8_5 单调运算的值不小于原值 *)
Lemma monotone_operation_le :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → monotone F → ∀α ⋵ 𝐎𝐍, α ⋸ F α.
Proof with auto.
  intros F HF Hmono.
  ord_induction. intros α Hoα IH.
  apply ord_le_iff_not_gt...
  intros HFα. apply Hmono in HFα as HFFα...
  apply IH in HFα as [].
  eapply ord_not_lt_gt; revgoals; eauto; try repeat apply HF...
  eapply ord_not_lt_self; revgoals; eauto; try repeat apply HF...
Qed.

Module VeblenFixedPoint.
Import 𝐎𝐍Operation.

(* 序数运算的不动点 *)
Definition fixed_point := λ F α, α ⋵ 𝐎𝐍 ∧ F α = α.

(* Veblen不动点定理：规范运算存在任意大的不动点 *)
Theorem Veblen_fixed_point : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  ∀β ⋵ 𝐎𝐍, ∃ γ, fixed_point F γ ∧ β ⋸ γ.
Proof with neauto; try congruence.
  intros F HF [Hmono Hcon] β Hoβ.
  apply (monotone_operation_le F) in Hoβ as H...
  destruct H as [Heq|Hlt]; revgoals. exists β. repeat split...
  set (Operation β F) as f.
  set {f n | n ∊ ω} as S.
  assert (Hne: S ≠ ∅). {
    apply EmptyNI. exists (f 0). eapply ReplI...
  }
  assert (Hos: S ⪽ 𝐎𝐍). {
    intros x Hx. apply ReplAx in Hx as [n [Hn Hfn]]. subst x.
    apply operation_operative...
  }
  exists (sup S). repeat split.
  - apply union_of_ords_is_ord...
  - rewrite operation_of_sup_eq_sup_of_operation; revgoals... split...
    ext Hx.
    + apply FUnionE in Hx as [α [Hα Hx]].
      apply ReplAx in Hα as [n [Hn Hfn]]. subst α.
      apply UnionAx. exists (f n⁺). split.
      eapply ReplI... apply ω_inductive...
      unfold f. rewrite operation_suc...
    + apply UnionAx in Hx as [y [Hy Hx]].
      apply ReplAx in Hy as [n [Hn Hfn]]. subst y.
      apply (FUnionI _ _ (f n)). eapply ReplI...
      assert (Hof: f n ⋵ 𝐎𝐍). {
        apply operation_operative...
      }
      apply (monotone_operation_le F) in Hof as H...
      destruct H... eapply ord_trans...
  - apply ord_sup_is_ub...
    apply ReplAx. exists 0. split...
    unfold f. rewrite operation_0...
Qed.

(* ex8_7 规范运算存在比指定序数大的最小不动点 *)
Corollary ex_least_fixed_point :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  ∀β ⋵ 𝐎𝐍, ∃ γ, fixed_point F γ ∧ β ⋸ γ ∧
    ∀ ξ, fixed_point F ξ → β ⋸ ξ → γ ⋸ ξ.
Proof with eauto.
  intros F HF Hnml β Hoβ.
  apply (Veblen_fixed_point F) in Hoβ as [γ [[Hoγ HFγ] Hβγ]]...
  set {ξ ∊ γ⁺ | F ξ = ξ ∧ β ⋸ ξ} as Ω.
  pose proof (ords_woset Ω) as [_ Hmin]. {
    intros ξ Hξ. apply SepE1 in Hξ.
    apply (ord_is_ords γ⁺)...
  }
  pose proof (Hmin Ω) as [μ [Hμ Hmμ]]... {
    exists γ. apply SepI...
  }
  apply SepE in Hμ as [Hμ [HFμ Hβμ]].
  exists μ. repeat split... apply (ord_is_ords γ⁺)...
  intros ξ [Hoξ HFξ] Hβξ.
  destruct (classic (ξ = γ⁺)) as [|Hnq]. left. congruence.
  apply ord_connected in Hnq as [Hlt|Hne]...
  - assert (Hξ: ξ ∈ Ω). apply SepI...
    apply Hmμ in Hξ as []... apply binRelE3 in H...
  - left. eapply ord_trans...
Qed.

(* 不动点类无界 *)
Corollary fixed_point_class_unbounded :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → unbounded (fixed_point F).
Proof with eauto.
  intros F HF Hnml α Hoα.
  assert (Hoα': α⁺ ⋵ 𝐎𝐍)...
  apply (ex_least_fixed_point F) in Hoα' as [β [[Hoβ HFβ] [Hle _]]]...
  exists β. repeat split... destruct Hle.
  eapply ord_trans... rewrite <- H... 
Qed.
Local Hint Resolve fixed_point_class_unbounded : core.

(* 不动点类是序数类的子类 *)
Lemma fixed_point_class_sub_on :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → fixed_point F ⫃ 𝐎𝐍.
Proof.
  intros F HF α [Hoα HFα]. rewrite <- HFα.
  apply HF. apply Hoα.
Qed.
Local Hint Resolve fixed_point_class_sub_on : core.

Import 𝐎𝐍Separation.

(* 不动点的枚举运算 *)
Definition FixedPoint := λ F, Enumerate (fixed_point F).

(* 不动点的枚举运算是单调的 *)
Lemma fixedPoint_monotone :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → monotone (FixedPoint F).
Proof with auto.
  intros F HF Hnml. apply enum_monotone...
  apply fixed_point_class_sub_on...
Qed.

(* 不动点的枚举运算是连续的 *)
Lemma fixedPoint_continuous :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → continuous (FixedPoint F).
Proof with eauto; try congruence.
  intros F HF Hnml.
  apply (monotone_operation_continuous_if_range_closed _ (fixed_point F))...
  apply enum_onto_class... apply fixedPoint_monotone...
  intros A Hne HA. split.
  - apply union_of_ords_is_ord.
    intros x Hx. apply HA...
  - assert (Hos: A ⪽ 𝐎𝐍). intros x Hx. apply HA...
    assert (Hou: sup A ⋵ 𝐎𝐍). apply union_of_ords_is_ord...
    ext Hx.
    + ord_destruct (sup A).
      * apply union_eq_empty in H0 as [|HeqA]...
        rewrite HeqA in HA, Hx.
        unfold sup in Hx. rewrite union_one in Hx.
        assert (∅ ⋵ fixed_point F). apply HA. apply SingI.
        destruct H as [_ HF0]. rewrite HF0 in Hx. exfalso0.
      * apply sup_ords_is_sucord_impl_in in Hsuc...
        apply HA in Hsuc as [_ HFu]...
      * destruct Hnml as [Hmono Hcon].
        rewrite Hcon in Hx...
        apply FUnionE in Hx as [α [Hα Hx]].
        apply UnionAx in Hα as [β [Hβ Hα]].
        apply UnionAx. exists β. split...
        apply HA in Hβ as [Hoβ HFβ].
        apply Hmono in Hα... rewrite <- HFβ.
        eapply ord_trans...
    + apply UnionAx in Hx as [α [Hα Hx]].
      assert (α ⋸ sup A). apply ord_sup_is_ub...
      apply HA in Hα as [Hoα HFα]. rewrite <- HFα in Hx.
      destruct H... eapply ord_trans... apply Hnml...
Qed.

(* ex8_8 不动点的枚举运算是规范的 *)
Theorem fixedPoint_normal :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → normal (FixedPoint F).
Proof with auto.
  intros F HF Hnml. split.
  apply fixedPoint_monotone...
  apply fixedPoint_continuous...
Qed.

(* 存在不动点的不动点 *)
Corollary ex_fixed_point_of_fixed_point :
  ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  ∀β ⋵ 𝐎𝐍, ∃ γ, fixed_point (FixedPoint F) γ ∧ β ⋸ γ.
Proof with auto.
  intros F HF Hnml β Hoβ. apply Veblen_fixed_point...
  apply enum_operative... apply fixed_point_class_sub_on...
  apply fixedPoint_normal...
Qed.

(* 不动点的枚举运算的值满足不动点性质 *)
Lemma fixedPoint : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  ∀α ⋵ 𝐎𝐍, F (FixedPoint F α) = FixedPoint F α.
Proof.
  intros F HF Hnml α Hα.
  pose proof (enum_into_class (fixed_point F)) as [_ Heq]; eauto.
Qed.

(* 不动点是极限序数 *)
Theorem fixed_point_is_limord : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F →
  (∀α ⋵ 𝐎𝐍, FixedPoint F α⁺ ≠ (FixedPoint F α)⁺) →
  FixedPoint F :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍ˡⁱᵐ.
Proof with eauto.
  intros F HF Hnml Hnq α Hα.
  assert (Ho: FixedPoint F α ⋵ 𝐎𝐍). {
    apply enum_operative...
  }
  assert (Hso: sup (FixedPoint F α) ⋵ 𝐎𝐍). {
    apply union_of_ords_is_ord. apply ord_is_ords...
  }
  split... apply sub_antisym; revgoals. {
    intros x Hx. apply UnionAx in Hx as [y [Hy Hx]]. eapply ord_trans...
  }
  apply ord_le_iff_sub...
  destruct (classic (FixedPoint F α = ∅)) as [|Hne]. {
    rewrite H. right. symmetry. apply union_empty.
  }
  apply enum_spec...
  - split... rewrite operation_of_sup_eq_sup_of_operation...
    2: apply ord_is_ords... ext.
    + apply FUnionE in H as [y [Hy Hx]].
      apply UnionAx. exists (F y). split...
      rewrite <- fixedPoint... apply Hnml...
    + apply UnionAx in H as [y [Hy Hx]].
      assert (Hoy: y ⋵ 𝐎𝐍). eapply ord_is_ords; revgoals...
      assert (Hox: x ⋵ 𝐎𝐍). eapply ord_is_ords; revgoals...
      eapply FUnionI... contra. apply ord_le_iff_not_gt in H...
      assert (F y ∈ y). eapply ord_trans_le_lt...
      apply ord_le_iff_not_gt in H0...
      apply monotone_operation_weakly_increasing... apply Hnml.
  - fold (FixedPoint F). intros H.
    apply ReplAx in H as [β [Hβ Heq]].
    assert (Hoβ: β ⋵ 𝐎𝐍). apply (ord_is_ords α)...
    assert ((FixedPoint F β)⁺ = FixedPoint F α). {
      pose proof (sucord_or_limord (FixedPoint F α)) as []...
      + destruct H as [γ [Hγ H]].
        rewrite Heq, H, sup_of_sucord...
      + apply limord_iff_not_contains_sup in H...
        exfalso. apply H. rewrite <- Heq.
        apply fixedPoint_normal...
    }
    apply (Hnq β)... cut (α = β⁺). congruence. contra.
    apply ord_connected in H0 as []... eapply ord_not_dense...
    eapply fixedPoint_monotone in H0...
    rewrite <- H in H0. apply ord_le_iff_lt_suc in H0.
    apply ord_le_iff_not_gt in H0.
    apply H0. apply fixedPoint_monotone...
    1-4: apply enum_operative...
Qed.

End VeblenFixedPoint.
