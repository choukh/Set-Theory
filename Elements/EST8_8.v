(** Adapted from "Elements of Set Theory" Chapter 8 **)
(** Coq coding by choukh, Aug 2021 **)

Require Export ZFC.Elements.EST8_7.
Import OrdinalClass ğğOperation.

Local Hint Resolve
  add_ran mul_ran exp_ran
  ordAdd_ran ordMul_ran preOrdExp_ran ordExp_ran : core.

(*** ESTç¬¬å…«ç« 8ï¼šè¿­ä»£å¹‚æ¬¡ï¼ŒÎµæ•° ***)

(** Îµæ•° **)
(* please see LargeOrdinal/EpsilonNumbers.v *)

(** è¿­ä»£å¹‚æ¬¡ **)
(* see also LargeOrdinals/NormalTetration.v *)
Definition OrdTetL := Î» Î±, Operation Î± (OrdExp Î±).
Notation "Î± ^^á´¸ Î²" := (OrdTetL Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTetL_0 : âˆ€Î± â‹µ ğğ, Î± ^^á´¸ 0 = Î±.
Proof. intros Î± H. apply operation_0; auto. Qed.

Theorem ordTetL_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î²âº = Î± ^ (Î± ^^á´¸ Î²).
Proof. intros Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTetL_limit : âˆ€Î± â‹µ ğğ, continuous (OrdTetL Î±).
Proof. intros Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTetL_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² â‹µ ğğ.
Proof. intros Î± HÎ± Î² HÎ². apply operation_operative; auto. Qed.
Local Hint Resolve ordTetL_ran : core.

Theorem ordTetL_1_r : âˆ€Î± â‹µ ğğ, Î± ^^á´¸ 1 = Î± ^ Î±.
Proof.
  intros Î± H. rewrite pred, ordTetL_suc, ordTetL_0; auto.
Qed.

Theorem ordTetL_1_l : âˆ€Î± â‹µ ğğ, 1 ^^á´¸ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordTetL_suc, ordExp_1_l...
  - rewrite ordTetL_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + rewrite one in H. apply SingE in H. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordTetL_0, pred...
Qed.

Lemma ordTetL_eq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² = 0 â†’ Î± = 0.
Proof with eauto.
  intros Î± HÎ± Î² HÎ². generalize dependent Î².
  ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTetL_0 in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTetL_suc in H...
    apply ordExp_eq_0 in H...
  - rewrite ordTetL_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [Î³ HÎ³].
      assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in HÎ³...
      eapply repl_eq_1 in HÎ³ as H0...
Qed.

Lemma ordAdd_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± + Î² = 1 â†’
  Î± = 0 âˆ§ Î² = 1 âˆ¨ Î± = 1 âˆ§ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H.
  ord_destruct Î±; subst.
  - rewrite ordAdd_0_l in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    ord_destruct Î².
    + subst. rewrite ordAdd_0_r in H...
    + exfalso. destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
      rewrite <- (ordAdd_1_r Î´), <- ordAdd_assoc in H...
      rewrite (ordAdd_1_r), pred in H...
      apply ord_suc_injective in H...
      apply ordAdd_eq_0 in H as []... eapply suc_neq_0...
    + exfalso. apply limord_ge_Ï‰ in Hlim...
      apply (ord_irrefl 1)... rewrite <- H at 2.
      eapply ord_trans_lt_le. auto. apply embed_ran.
      eapply ord_trans_le... apply ordAdd_enlarge_l...
  - exfalso.
    destruct (classic (Î² = 0)). {
      subst. rewrite ordAdd_0_r in H...
      apply (limord_iff_not_sucord Î±)... exists 0...
    }
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans. auto. apply embed_ran.
    eapply ord_trans_le_lt... apply ordAdd_enlarge_r...
Qed.

Lemma ordMul_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± â‹… Î² = 1 â†’ Î± = 1 âˆ§ Î² = 1.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î².
  - subst. rewrite ordMul_0_r in H... exfalso...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordMul_suc in H...
    apply ordAdd_eq_1 in H as [[H0 H1]|[H1 H0]]...
    + apply ordMul_eq_0 in H0 as []...
      * exfalso. subst...
      * split... subst...
    + rewrite H0 in H1. rewrite ordMul_0_l in H1... exfalso...
  - exfalso.
    destruct (classic (Î± = 0)). subst. rewrite ordMul_0_l in H...
    destruct (classic (Î± = 1)). {
      subst. rewrite ordMul_1_l in H...
      apply (limord_iff_not_sucord Î²)... exists 0...
    }
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply ordMul_enlarge_l...
Qed.

Lemma preOrdExp_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^áµ– Î² = 1 â†’
  Î± = 1 âˆ¨ Î² = 0 âˆ¨ Î² â‰  0 âˆ§ Î² â‹µ ğğË¡â±áµ âˆ§ Î± = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î²...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite preOrdExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (Î± = 0))...
    destruct (classic (Î± = 1))...
    exfalso. apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply preOrdExp_enlarge_l...
Qed.

Lemma ordExp_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^ Î² = 1 â†’ Î± = 1 âˆ¨ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î².
  - subst. rewrite ordExp_0_r in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (Î± = 1))...
    exfalso. unfold OrdExp in H.
    destruct (ixm (Î± = 0)); destruct (ixm (Î² = 0))...
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto.
    apply embed_ran. eapply ord_trans_le...
    apply preOrdExp_enlarge_l...
Qed.

Lemma ordTetL_gt_1 : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ 1 âˆˆ Î± ^^á´¸ Î².
Proof with neauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTetL_suc... eapply ord_trans...
    apply ordExp_enlarge_r...
  - rewrite ordTetL_limit...
    apply EmptyNE in H0 as [Î³ HÎ³].
    assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTetL_suc... apply ordExp_enlarge_l...
Qed.

Theorem ordTetL_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² = 1 â†’ Î± = 0 âˆ¨ Î± = 1.
Proof with neauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTetL_0 in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTetL_suc in H...
    apply ordExp_eq_1 in H as []...
    apply ordTetL_eq_0 in H...
  - destruct (classic (Î± = 0))...
    destruct (classic (Î± = 1))... exfalso.
    apply (ord_irrefl 1)... rewrite <- H at 2.
    apply ordTetL_gt_1...
Qed.

Fact ordTetL_is_limord_l : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  0 â†’ ğœ† ^^á´¸ Î± â‹µ ğğË¡â±áµ.
Proof with nauto.
  ord_induction. intros Î± HÎ± IH ğœ† Hğœ† H0.
  ord_destruct Î±.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordTetL_suc... apply ordExp_is_limord_l...
    apply ordTetL_gt_1... eapply ord_trans_lt_le. auto.
    apply embed_ran. apply limord_ge_Ï‰...
  - rewrite ordTetL_limit...
    apply union_of_limords_is_limord. intros x Hx.
    apply ReplAx in Hx as [Î² [HÎ² Hx]]. subst x. apply IH...
Qed.

Lemma tetL_ran : âˆ€ m n âˆˆ Ï‰, m ^^á´¸ n âˆˆ Ï‰.
Proof with auto.
  intros k Hk n Hn. Ï‰_induction n.
  - rewrite ordTetL_0...
  - rewrite ordTetL_suc, fin_ordExp_eq_exp...
Qed.
Local Hint Resolve tetL_ran : core.

Lemma tetL_preserve_base_lt : âˆ€ m n p âˆˆ Ï‰, m â‰  0 â†’ n â‰  0 â†’
  m âˆˆ n â†” m ^^á´¸ p âˆˆ n ^^á´¸ p.
Proof with eauto.
  assert (Hright: âˆ€ m n p âˆˆ Ï‰, m â‰  0 â†’ n â‰  0 â†’ m âˆˆ n â†’ m ^^á´¸ p âˆˆ n ^^á´¸ p). {
    intros m Hm n Hn p Hp Hm0 Hn0 H.
    generalize dependent n. generalize dependent m.
    Ï‰_induction p; intros k Hk Hk0 n Hn Hn0 H.
    - rewrite ordTetL_0, ordTetL_0...
    - assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
      assert (H0: k ^^á´¸ m â‰  0). intros H0. apply ordTetL_eq_0 in H0...
      rewrite ordTetL_suc, ordTetL_suc...
      repeat rewrite fin_ordExp_eq_exp...
      eapply lt_le_trans. auto.
      apply exp_preserve_base_lt; revgoals...
      apply exp_preserve_exponent_le...
  }
  intros m Hm n Hn p Hp Hm0 Hn0. split. apply Hright...
  intros H. destruct (classic (m = n)).
  - subst. exfalso. eapply nat_irrefl; revgoals...
  - apply nat_connected in H0 as []...
    pose proof (Hright n Hn m Hm p Hp Hn0 Hm0 H0).
    exfalso. eapply nat_not_lt_gt; revgoals...
Qed.

Lemma tetL_enlarge_l : âˆ€ m n âˆˆ Ï‰, 1 âˆˆ n â†’ m âˆˆ n ^^á´¸ m.
Proof with neauto.
  intros k Hk. Ï‰_induction k; intros n Hn Hn0.
  - rewrite ordTetL_0... apply ord_neq_0_gt_0...
    apply ord_gt_1_neq_0_1...
  - rewrite ordTetL_suc... pose proof (IH n Hn Hn0).
    apply lt_iff_suc_le in H...
    eapply ord_trans_le_lt. auto. apply H.
    rewrite fin_ordExp_eq_exp... apply exp_enlarge_l...
Qed.

Lemma ordTetL_2_Ï‰ : 2 ^^á´¸ Ï‰ = Ï‰.
Proof with neauto.
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply Ï‰_trans...
  - rewrite ordTetL_limit... eapply FUnionI...
    apply tetL_enlarge_l... rewrite (pred 2)...
Qed.

(** æ— é™ç»“åˆå¾‹ï¼Œå·¦ä¾§ä¸¥æ ¼æ”¾å¤§ **)

Lemma ordAdd_arbitrary_assoc : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Î± + Î± â‹… n = Î± â‹… n + Î±.
Proof with auto.
  intros Î± HÎ± n Hn. Ï‰_induction n.
  - rewrite ordMul_0_r, ordAdd_0_r, ordAdd_0_l...
  - rewrite ordMul_suc... rewrite <- IH at 2... rewrite ordAdd_assoc...
Qed.

Lemma ordAdd_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± â‹… n, Î² âˆˆ Î± + Î².
Proof with neauto; try congruence.
  intros Î± HÎ± n Hn. Ï‰_induction n; intros Î² HÎ².
  - rewrite <- zero, ordMul_0_r in HÎ²... exfalso0.
  - destruct (classic (Î² âˆˆ Î± â‹… m)). apply IH...
    assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords (Î± â‹… mâº))...
    rewrite ordMul_suc, <- ordAdd_arbitrary_assoc in HÎ²...
    apply ord_le_iff_not_gt in H as []...
    apply (ordAdd_preserve_lt Î±) in H... eapply ord_trans...
Qed.

Lemma ordMul_arbitrary_assoc : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Î± â‹… Î± ^ n = Î± ^ n â‹… Î±.
Proof with auto.
  intros Î± HÎ± n Hn. Ï‰_induction n.
  - rewrite ordExp_0_r, ordMul_1_r, ordMul_1_l...
  - rewrite ordExp_suc... rewrite <- IH at 2... rewrite ordMul_assoc...
Qed.

Lemma ordMul_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± ^ n, Î² â‰  0 â†’ Î² âˆˆ Î± â‹… Î².
Proof with neauto; try congruence.
  intros Î± HÎ± n Hn Î² HÎ² HÎ²0.
  destruct (classic (Î± = 0)) as [|HÎ±0]. {
    subst. destruct (classic (n = 0)). {
      subst. rewrite ordExp_0_r in HÎ²...
      rewrite one in HÎ². apply SingE in HÎ². exfalso...
    }
    rewrite ordExp_0_l in HÎ²... exfalso0.
  }
  generalize dependent Î².
  Ï‰_induction n; intros Î² HÎ² HÎ²0.
  - rewrite <- zero, ordExp_0_r in HÎ²...
    rewrite one in HÎ². apply SingE in HÎ². exfalso...
  - destruct (classic (Î² âˆˆ Î± ^ m)). apply IH...
    assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords (Î± ^ mâº))...
    rewrite ordExp_suc, <- ordMul_arbitrary_assoc in HÎ²...
    apply ord_le_iff_not_gt in H as []...
    apply (ordMul_preserve_lt Î±) in H... eapply ord_trans...
Qed.

Lemma ordExp_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± ^^á´¸ n, Î² âˆˆ Î± ^ Î².
Proof with neauto; try congruence.
  intros Î± HÎ± HÎ±1 n Hn. Ï‰_induction n; intros x Hx.
  - destruct (classic (x = 0)). {
      subst. rewrite ordExp_0_r, pred, pred...
    }
    rewrite <- zero, ordTetL_0 in Hx...
    apply ordExp_enlarge_lt... 1-2: eapply ord_is_ords...
  - destruct (classic (x âˆˆ Î± ^^á´¸ m)). apply IH...
    assert (Hox: x â‹µ ğğ). apply (ord_is_ords (Î± ^^á´¸ mâº))...
    rewrite ordTetL_suc in Hx...
    apply ord_le_iff_not_gt in H as []...
    apply (ordExp_preserve_lt Î±) in H... eapply ord_trans...
Qed.

(** å¸æ”¶å¾‹ **)

(* Those Î± that Ï‰ â‹¸ Î± are all fixed points for n_addition.
  Please see also LargeOrdinal/LowerFixedPoint.v *)
Theorem ordAdd_1_absorption : âˆ€Î± â‹µ ğğ, Ï‰ â‹¸ Î± â†’ 1 + Î± = Î±.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH Hle.
  destruct Hle; revgoals. {
    subst. apply ordAdd_1_Ï‰.
  }
  ord_destruct Î±.
  - subst. exfalso0.
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordAdd_suc, IH... apply ord_le_iff_lt_suc...
  - rewrite ordAdd_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      destruct (classic (Î² âˆˆ Ï‰)).
      * eapply ord_trans... rewrite ordAdd_1_l...
        apply sucord_in_limord...
      * rewrite IH in HÎ¾... eapply ord_trans...
        apply ord_le_iff_not_gt... eapply ord_is_ords...
    + assert (HÎ¾o: Î¾ â‹µ ğğ). eapply ord_is_ords...
      destruct (classic (Î¾ âˆˆ Ï‰)) as [|Hle].
      * eapply FUnionI... rewrite ordAdd_1_l...
      * apply ord_le_iff_not_gt in Hle...
        eapply FUnionI. apply sucord_in_limord...
        rewrite ordAdd_suc, IH...
Qed.

Corollary ordAdd_n_absorption : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Ï‰ â‹¸ Î± â†’ n + Î± = Î±.
Proof with neauto.
  intros Î± HÎ± n Hn Hle.
  Ï‰_induction n. rewrite ordAdd_0_l...
  rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_absorption...
Qed.

(* Ï‰å¹‚å¯¹åŠ æ³•çš„å¸æ”¶å¾‹ *)
Corollary ordAdd_Ï‰_pow_absorption : âˆ€Î² â‹µ ğğ, âˆ€Î± âˆˆ Î², Ï‰ ^ Î± + Ï‰ ^ Î² = Ï‰ ^ Î².
Proof with neauto.
  intros Î² HÎ² Î± Hlt. assert (Î± â‹¸ Î²)...
  assert (HÎ±: Î± â‹µ ğğ). eapply ord_is_ords...
  apply ord_subtraction in H as [Î´ [[HÎ´ Hsum] _]]... subst.
  rewrite <- ordExp_add... rewrite <- (ordMul_1_r (Ï‰ ^ Î±)) at 1...
  rewrite <- ordMul_distr... f_equal. apply ordAdd_1_absorption...
  rewrite <- ordExp_1_r at 1 3... apply ordExp_preserve_le_r...
  apply ord_le_iff_not_gt... intros H.
  rewrite one in H. apply SingE in H. subst.
  rewrite ordAdd_0_r in Hlt... eapply ord_irrefl...
Qed.

Theorem ordMul_n_Ï‰ : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ n â‹… Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H0. exfalso...
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordMul_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply Ï‰_trans... rewrite fin_ordMul_eq_mul...
  - destruct (classic (m = 0)).
    + subst. rewrite ordMul_1_l...
    + rewrite <- IH, ordMul_limit in H... rewrite ordMul_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      rewrite fin_ordMul_eq_mul, fin_ordMul_eq_mul...
      apply mul_preserve_lt... intros H. subst.
      rewrite ordMul_0_r in Hx... exfalso0.
Qed.

Theorem ordExp_n_Ï‰ : âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ n ^ Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H1. exfalso0.
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordExp_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply Ï‰_trans... rewrite fin_ordExp_eq_exp...
  - destruct (classic (x = 0)) as [|Hx0]. {
      subst. apply ord_neq_0_gt_0... intros H0.
      apply ordExp_eq_0 in H0... eapply suc_neq_0...
    }
    destruct (classic (m = 0)) as [|Hm0]. {
      rewrite H0 in H1. exfalso. apply (nat_irrefl 1)...
    }
    destruct (classic (m = 1)) as [|Hm1]. {
      rewrite H0. rewrite <- ordExp_2_Ï‰ in H...
    }
    rewrite <- IH, ordExp_limit in H... rewrite ordExp_limit...
    apply FUnionE in H as [k [Hk Hx]].
    eapply FUnionI... eapply ord_trans...
    rewrite fin_ordExp_eq_exp, fin_ordExp_eq_exp...
    apply exp_preserve_base_lt... intros H. subst.
    rewrite ordExp_0_r in Hx...
    rewrite one in Hx. apply SingE in Hx...
Qed.

Theorem ordTetL_n_Ï‰ : âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ n ^^á´¸ Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H1. exfalso0.
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply Ï‰_trans...
  - apply le_iff_lt_suc in H1 as []...
    + rewrite <- IH, ordTetL_limit in H...
      rewrite ordTetL_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      apply tetL_preserve_base_lt... apply ord_gt_1_neq_0_1...
    + subst. rewrite <- ordTetL_2_Ï‰ in H...
Qed.
