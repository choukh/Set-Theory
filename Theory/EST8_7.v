(** Adapted from "Elements of Set Theory" Chapter 8 **)
(** Coq coding by choukh, Aug 2021 **)

Require Export ZFC.Theory.EST8_2.
Import ğğOperation.

(*** ESTç¬¬å…«ç« 7ï¼šåºæ•°ç®—æœ¯ï¼ˆé€’å½’å®šä¹‰ï¼‰ ***)

Declare Scope OrdArith_scope.
Delimit Scope OrdArith_scope with oa.
Open Scope OrdArith_scope.

(* åºæ•°åŠ æ³• *)
Definition OrdAdd := Î» Î±, Operation Î± Suc.
Notation "Î± + Î²" := (OrdAdd Î± Î²) : OrdArith_scope.

Theorem ordAdd_0_r : âˆ€Î± â‹µ ğğ, Î± + 0 = Î±.
Proof. intros Î± H. apply operation_0. Qed.

Theorem ordAdd_suc : âˆ€ Î± Î² â‹µ ğğ, Î± + Î²âº = (Î± + Î²)âº.
Proof. intros Î± H. apply operation_suc. Qed.

Theorem ordAdd_limit : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  âˆ… â†’
  Î± + ğœ† = sup {Î± + Î² | Î² âˆŠ ğœ†}.
Proof. intros Î± H ğœ†. apply operation_limit. Qed.

Corollary ordAdd_1_r : âˆ€Î± â‹µ ğğ, Î± + 1 = Î±âº.
Proof.
  intros Î± H.
  rewrite pred, ordAdd_suc, ordAdd_0_r; auto.
Qed.

Theorem ordAdd_ran : âˆ€ Î± Î² â‹µ ğğ, Î± + Î² â‹µ ğğ.
Proof. intros Î± HÎ± Î² HÎ². apply operation_operative; auto. Qed.
Local Hint Resolve ordAdd_ran : core.
Local Hint Resolve add_ran : core.

(* æœ‰é™åºæ•°åŠ æ³•ç­‰æ•ˆäºè‡ªç„¶æ•°åŠ æ³• *)
Theorem fin_ordAdd_eq_add : âˆ€ m n âˆˆ Ï‰, m + n = (m + n)%Ï‰.
Proof with nauto.
  intros m Hm n Hn. generalize dependent m.
  Ï‰_induction n; intros k Hk.
  - rewrite ordAdd_0_r, add_0_r...
    apply (ord_is_ords Ï‰)...
  - rewrite ordAdd_suc, IH, suc, suc, add_assoc...
    apply (ord_is_ords Ï‰)... apply (ord_is_ords Ï‰)...
Qed.

(* æœ‰é™åºæ•°çš„å’Œæ˜¯è‡ªç„¶æ•° *)
Corollary fin_ordAdd_ran : âˆ€ m n âˆˆ Ï‰, m + n âˆˆ Ï‰.
Proof with auto.
  intros m Hm n Hn. rewrite fin_ordAdd_eq_add...
Qed.

Example ordAdd_1_1 : 1 + 1 = 2.
Proof. rewrite pred, ordAdd_suc, ordAdd_0_r; auto. Qed.

Example ordAdd_1_Ï‰ : 1 + Ï‰ = Ï‰.
Proof with neauto.
  rewrite ordAdd_limit... ext Î± HÎ±.
  - apply FUnionE in HÎ± as [Î² [HÎ² HÎ±]].
    eapply Ï‰_trans... apply fin_ordAdd_ran...
  - eapply FUnionI... rewrite fin_ordAdd_eq_add, add_comm, <- suc...
Qed.

Example ordAdd_Ï‰_1 : Ï‰ + 1 = Ï‰âº.
Proof. rewrite pred, ordAdd_suc, ordAdd_0_r; auto. Qed.

(* åºæ•°ä¹˜æ³• *)
Definition OrdMul := Î» Î±, Operation 0 (Î» Î¾, Î¾ + Î±).
Notation "Î± â‹… Î²" := (OrdMul Î± Î²) : OrdArith_scope.

Theorem ordMul_0_r : âˆ€Î± â‹µ ğğ, Î± â‹… 0 = 0.
Proof. intros Î± H. apply operation_0. Qed.

Theorem ordMul_suc : âˆ€ Î± Î² â‹µ ğğ, Î± â‹… Î²âº = (Î± â‹… Î²) + Î±.
Proof. intros Î± H. apply operation_suc. Qed.

Theorem ordMul_limit : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  âˆ… â†’
  Î± â‹… ğœ† = sup {Î± â‹… Î² | Î² âˆŠ ğœ†}.
Proof. intros Î± H ğœ†. apply operation_limit. Qed.

Theorem ordMul_ran : âˆ€ Î± Î² â‹µ ğğ, Î± â‹… Î² â‹µ ğğ.
Proof with auto.
  intros Î± HÎ± Î² HÎ².
  apply operation_operative...
Qed.
Local Hint Resolve ordMul_ran : core.
Local Hint Resolve mul_ran : core.

(* æœ‰é™åºæ•°ä¹˜æ³•ç­‰æ•ˆäºè‡ªç„¶æ•°ä¹˜æ³• *)
Theorem fin_ordMul_eq_mul : âˆ€ m n âˆˆ Ï‰, m â‹… n = (m â‹… n)%Ï‰.
Proof with nauto.
  intros m Hm n Hn. generalize dependent m.
  Ï‰_induction n; intros k Hk.
  - rewrite ordMul_0_r, mul_0_r...
    apply (ord_is_ords Ï‰)...
  - rewrite ordMul_suc, IH, mul_suc, fin_ordAdd_eq_add, add_comm...
    apply (ord_is_ords Ï‰)... apply (ord_is_ords Ï‰)...
Qed.

(* æœ‰é™åºæ•°çš„ç§¯æ˜¯è‡ªç„¶æ•° *)
Corollary fin_ordMul_ran : âˆ€ m n âˆˆ Ï‰, m â‹… n âˆˆ Ï‰.
Proof with auto.
  intros m Hm n Hn. rewrite fin_ordMul_eq_mul...
Qed.

(* åºæ•°ä¹˜æ–¹ *)
Definition OrdExp : set â†’ set â†’ set := Î» Î±,
  match (ixm (Î± = 0)) with
  | inl _ => Î» Î¾, match (ixm (Î¾ = 0)) with
    | inl _ => 1
    | inr _ => 0
    end
  | inr _ => Operation 1 (Î» Î¾, Î¾ â‹… Î±)
  end.
Notation "Î± ^ Î²" := (OrdExp Î± Î²) : OrdArith_scope.

Theorem ordExp_0_r : âˆ€Î± â‹µ ğğ, Î± ^ 0 = 1.
Proof with auto.
  intros Î± H. unfold OrdExp.
  destruct (ixm (Î± = 0)).
  - destruct (ixm (Embed 0 = 0))... exfalso...
  - rewrite operation_0...
Qed.

Theorem ordExp_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^ Î²âº = (Î± ^ Î²) â‹… Î±.
Proof with neauto.
  intros Î± HÎ± Î² HÎ². unfold OrdExp.
  destruct (ixm (Î± = 0)).
  - destruct (ixm (Î²âº = 0)).
    + exfalso. eapply suc_neq_0...
    + destruct (ixm (Î² = 0)); subst; rewrite ordMul_0_r...
  - apply operation_suc...
Qed.

Theorem ordExp_limit : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, Î± â‰  0 â†’ ğœ† â‰  0 â†’
  Î± ^ ğœ† = sup {Î± ^ Î² | Î² âˆŠ ğœ†}.
Proof with nauto.
  intros Î± HÎ± ğœ† Hğœ† HÎ±0 Hğœ†0. unfold OrdExp.
  destruct (ixm (Î± = 0)). exfalso...
  apply operation_limit...
Qed.

Theorem ordExp_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^ Î² â‹µ ğğ.
Proof with nauto.
  intros Î± HÎ± Î² HÎ². unfold OrdExp.
  destruct (ixm (Î± = 0)).
  - destruct (ixm (Î² = 0))...
  - apply operation_operative...
Qed.
Local Hint Resolve ordExp_ran : core.
Local Hint Resolve exp_ran : core.

(* æœ‰é™åºæ•°ä¹˜æ–¹ç­‰æ•ˆäºè‡ªç„¶æ•°ä¹˜æ–¹ *)
Theorem fin_ordExp_eq_exp : âˆ€ m n âˆˆ Ï‰, m ^ n = (m ^ n)%Ï‰.
Proof with nauto.
  intros m Hm n Hn. generalize dependent m.
  Ï‰_induction n; intros k Hk.
  - rewrite ordExp_0_r, exp_0_r...
    apply (ord_is_ords Ï‰)...
  - rewrite ordExp_suc, IH, exp_suc, fin_ordMul_eq_mul, mul_comm...
    apply (ord_is_ords Ï‰)... apply (ord_is_ords Ï‰)...
Qed.

(* æœ‰é™åºæ•°çš„å¹‚æ˜¯è‡ªç„¶æ•° *)
Corollary fin_ordExp_ran : âˆ€ m n âˆˆ Ï‰, m ^ n âˆˆ Ï‰.
Proof with auto.
  intros m Hm n Hn. rewrite fin_ordExp_eq_exp...
Qed.

Example ordExp_2_Ï‰ : 2 ^ Ï‰ = Ï‰.
Proof with neauto.
  rewrite ordExp_limit; nauto; [|apply suc_neq_0].
  ext Î± HÎ±.
  - apply FUnionE in HÎ± as [Î² [HÎ² HÎ±]].
    eapply Ï‰_trans... apply fin_ordExp_ran...
  - eapply FUnionI... rewrite fin_ordExp_eq_exp...
    apply exp_enlarge_lt... apply BUnionI2...
Qed.

(** åºæ•°ç®—æœ¯å®šå¾‹ **)

Theorem ordAdd_0_l : âˆ€Î± â‹µ ğğ, 0 + Î± = Î±.
Proof with eauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordAdd_0_r...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordAdd_suc, IH...
  - rewrite ordAdd_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      rewrite IH in HÎ¾... eapply ord_trans...
    + eapply sucord_in_limord in Hlim...
      eapply FUnionI... rewrite IH...
Qed.

Theorem ordAdd_1_l_lt_Ï‰ : âˆ€Î± âˆˆ Ï‰, 1 + Î± = Î±âº.
Proof.
  intros Î± HÎ±. rewrite fin_ordAdd_eq_add, add_1_l; nauto.
Qed.

Theorem ordAdd_1_l_ge_Ï‰ : âˆ€Î± â‹µ ğğ, Ï‰ â‹¸ Î± â†’ 1 + Î± = Î±.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH Hle.
  destruct Hle; revgoals. {
    subst. apply ordAdd_1_Ï‰.
  }
  ord_destruct Î±.
  - subst. exfalso0.
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordAdd_suc, IH... apply ord_leq_iff_lt_suc...
  - rewrite ordAdd_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      destruct (classic (Î² âˆˆ Ï‰)).
      * eapply ord_trans... rewrite ordAdd_1_l_lt_Ï‰...
        apply sucord_in_limord...
      * rewrite IH in HÎ¾... eapply ord_trans...
        apply ord_leq_iff_not_gt... eapply ord_is_ords...
    + assert (HÎ¾o: Î¾ â‹µ ğğ). eapply ord_is_ords...
      destruct (classic (Î¾ âˆˆ Ï‰)) as [|Hle].
      * eapply FUnionI... rewrite ordAdd_1_l_lt_Ï‰...
      * apply ord_leq_iff_not_gt in Hle...
        eapply FUnionI. apply sucord_in_limord...
        rewrite ordAdd_suc, IH...
Qed.

Theorem ordMul_0_l : âˆ€Î± â‹µ ğğ, 0 â‹… Î± = 0.
Proof with nauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite ordMul_0_r...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordMul_suc, ordAdd_0_r, IH...
  - rewrite ordMul_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      rewrite IH in HÎ¾...
    + exfalso0.
Qed.

Theorem ordMul_1_r : âˆ€Î± â‹µ ğğ, Î± â‹… 1 = Î±.
Proof.
  intros Î± H.
  rewrite pred, ordMul_suc, ordMul_0_r, ordAdd_0_l; auto.
Qed.

Theorem ordMul_1_l : âˆ€Î± â‹µ ğğ, 1 â‹… Î± = Î±.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordMul_0_r...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordMul_suc, IH, ordAdd_1_r...
  - rewrite ordMul_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      rewrite IH in HÎ¾... eapply ord_trans...
    + eapply sucord_in_limord in Hlim...
      eapply FUnionI... rewrite IH...
Qed.

Theorem ordExp_0_l : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ 0 ^ Î± = 0.
Proof with nauto.
  ord_induction. intros Î± HÎ± IH H0.
  ord_destruct Î±.
  - subst. exfalso...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordExp_suc, ordMul_0_r...
  - unfold OrdExp. destruct (ixm (Embed 0 = 0))...
    + destruct (ixm (Î± = 0))... exfalso...
    + exfalso...
Qed.

Theorem ordExp_1_r : âˆ€Î± â‹µ ğğ, Î± ^ 1 = Î±.
Proof.
  intros Î± H.
  rewrite pred, ordExp_suc, ordExp_0_r, ordMul_1_l; auto.
Qed.

Theorem ordExp_1_l : âˆ€Î± â‹µ ğğ, 1 ^ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite ordExp_0_r...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordExp_suc, ordMul_1_r, IH...
  - rewrite ordExp_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      rewrite IH in HÎ¾...
    + rewrite one in HÎ¾. apply SingE in HÎ¾. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordExp_0_r, pred...
Qed.

Lemma ord_sum_eq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± + Î² = 0 â†’ Î± = 0 âˆ§ Î² = 0.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² H0.
  ord_destruct Î±; ord_destruct Î²; subst...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordAdd_suc in H0... exfalso. eapply suc_neq_0...
  - exfalso. rewrite ordAdd_limit in H0...
    apply union_eq_empty in H0 as [].
    + apply repl_eq_empty in H...
    + apply EmptyNE in H2 as [x Hx].
      assert (Hox: x â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in Hx...
      eapply repl_eq_1 in Hx...
      rewrite ordAdd_suc in Hx... eapply suc_neq_0...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordAdd_0_r in H0...
  - destruct Hsuc0 as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordAdd_suc in H0... exfalso. eapply suc_neq_0...
  - exfalso. rewrite ordAdd_limit in H0...
    apply union_eq_empty in H0 as [].
    + apply repl_eq_empty in H...
    + apply EmptyNE in H1 as [x Hx].
      assert (Hox: x â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in Hx...
      eapply repl_eq_1 in Hx...
      rewrite ordAdd_suc in Hx... eapply suc_neq_0...
  - rewrite ordAdd_0_r in H0...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordAdd_suc in H0... exfalso. eapply suc_neq_0...
  - exfalso. rewrite ordAdd_limit in H0...
    apply union_eq_empty in H0 as [].
    + apply repl_eq_empty in H...
    + apply EmptyNE in H2 as [x Hx].
      assert (Hox: x â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in Hx...
      eapply repl_eq_1 in Hx...
      rewrite ordAdd_suc in Hx... eapply suc_neq_0...
Qed.

Lemma ord_prd_eq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± â‹… Î² = 0 â†’ Î± = 0 âˆ¨ Î² = 0.
Proof with eauto.
  intros Î± HÎ± Î² HÎ². generalize dependent Î².
  ord_induction. intros Î² HÎ² IH H0.
  ord_destruct Î². subst...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordMul_suc in H0...
    apply ord_sum_eq_0 in H0 as []...
  - rewrite ordMul_limit in H0...
    apply union_eq_empty in H0 as [].
    + apply repl_eq_empty in H...
    + apply EmptyNE in H1 as [x Hx].
      assert (Hox: x â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in Hx...
      eapply repl_eq_1 in Hx as H0...
      apply IH in H0 as []...
      exfalso. eapply suc_neq_0...
Qed.

Lemma ord_pow_eq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± ^ Î² = 0 â†’ Î± = 0.
Proof with eauto.
  intros Î± HÎ± Î² HÎ². generalize dependent Î².
  ord_induction. intros Î² HÎ² IH H0.
  ord_destruct Î².
  - subst. rewrite ordExp_0_r in H0...
    exfalso. eapply suc_neq_0...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordExp_suc in H0...
    apply ord_prd_eq_0 in H0 as []...
  - unfold OrdExp in H0.
    destruct (ixm (Î± = 0))...
    rewrite operation_limit in H0...
    apply union_eq_empty in H0 as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H1 as [Î³ HÎ³].
      assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in HÎ³...
      eapply repl_eq_1 in HÎ³ as H0...
      rewrite <- H. symmetry. apply repl_ext.
      intros Î´ HÎ´. unfold OrdExp.
      destruct (ixm (Î± = 0))... exfalso...
Qed.

Import OrdinalClass.
Local Hint Resolve operation_operative : core.

Theorem ordAdd_normal : âˆ€Î± â‹µ ğğ, normal (OrdAdd Î±).
Proof with auto.
  intros Î± HÎ±. apply operation_normal...
  intros Î² HÎ². fold (OrdAdd Î± Î²âº). rewrite ordAdd_suc...
Qed.

Theorem ordMul_normal : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ normal (OrdMul Î±).
Proof with auto.
  intros Î± HÎ± Hlt. apply operation_normal...
  intros Î² HÎ². fold (OrdMul Î± Î²). fold (OrdMul Î± Î²âº).
  rewrite ordMul_suc... rewrite <- ordAdd_0_r at 1...
  apply ordAdd_normal... apply ord_neq_0_gt_0...
Qed.

Theorem ordExp_normal : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ normal (OrdExp Î±).
Proof with neauto.
  intros Î± HÎ± Hlt. unfold OrdExp.
  destruct (ixm (Î± = 0)). subst. exfalso0.
  apply operation_normal... intros Î² HÎ².
  rewrite operation_suc... rewrite <- ordMul_1_r at 1...
  apply ordMul_normal... intros H.
  apply n. eapply ord_pow_eq_0... unfold OrdExp.
  destruct (ixm (Î± = 0))... exfalso...
Qed.

Fact ord_sum_limit : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  0 â†’ Î± + ğœ† â‹µ ğğË¡â±áµ.
Proof with auto.
  intros Î± HÎ± ğœ† Hğœ† Hne.
  apply normal_operation_limit_is_limit...
  apply ordAdd_normal...
Qed.

Fact ord_prd_limit_r : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, Î± â‰  0 â†’ ğœ† â‰  0 â†’ Î± â‹… ğœ† â‹µ ğğË¡â±áµ.
Proof with auto.
  intros Î± HÎ± ğœ† Hğœ† H1 H2.
  apply normal_operation_limit_is_limit...
  apply ordMul_normal...
Qed.

Fact ord_prd_limit_l : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, Î± â‰  0 â†’ ğœ† â‰  0 â†’ ğœ† â‹… Î± â‹µ ğğË¡â±áµ.
Proof with auto.
  intros Î± HÎ± ğœ† Hğœ† H1 H2.
  assert (Hoğœ†: ğœ† â‹µ ğğ). apply Hğœ†.
  ord_destruct Î±.
  - subst. exfalso...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordMul_suc... apply ord_sum_limit...
  - apply ord_prd_limit_r...
Qed.

Fact ord_pow_limit_r : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, 1 âˆˆ Î± â†’ ğœ† â‰  0 â†’ Î± ^ ğœ† â‹µ ğğË¡â±áµ.
Proof with auto.
  intros Î± HÎ± ğœ† Hğœ† H1 H2.
  apply normal_operation_limit_is_limit...
  apply ordExp_normal...
Qed.

Fact ord_pow_limit_l : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, 1 âˆˆ Î± â†’ ğœ† â‰  0 â†’ ğœ† ^ Î± â‹µ ğğË¡â±áµ.
Proof with nauto.
  intros Î± HÎ± ğœ† Hğœ† H1 H2.
  assert (Hoğœ†: ğœ† â‹µ ğğ). apply Hğœ†.
  ord_destruct Î±.
  - subst. exfalso0.
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordExp_suc... apply ord_prd_limit_r...
    intros H. apply ord_pow_eq_0 in H...
  - apply ord_pow_limit_r...
    apply gt_1_iff_neq_0_1... split... intros H.
    apply (limord_iff_not_sucord ğœ†)... exists 0...
Qed.

(** Addition, multiplication and exponentiation is
  strictly increasing and continuous in the right argument,
  but the analogous relation does not hold for the left argument. **)

Corollary ordAdd_preserve_lt : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î² âˆˆ Î³ â†” Î± + Î² âˆˆ Î± + Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³. split; intros H.
  apply ordAdd_normal...
  destruct (classic (Î² = Î³)).
  - subst. exfalso. eapply ord_irrefl; revgoals...
  - apply ord_connected in H0 as []...
    apply (proj1 (ordAdd_normal Î± HÎ±)) in H0...
    exfalso. eapply ord_not_lt_gt; revgoals...
Qed.

Corollary ordMul_preserve_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‰  0 â†’
  Î² âˆˆ Î³ â†” Î± â‹… Î² âˆˆ Î± â‹… Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0. split; intros H.
  apply ordMul_normal...
  destruct (classic (Î² = Î³)).
  - subst. exfalso. eapply ord_irrefl; revgoals...
  - apply ord_connected in H1 as []...
    apply (proj1 (ordMul_normal Î± HÎ± H0)) in H1...
    exfalso. eapply ord_not_lt_gt; revgoals...
Qed.

Corollary ordExp_preserve_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î± â†’ 
  Î² âˆˆ Î³ â†” Î± ^ Î² âˆˆ Î± ^ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H1. split; intros H.
  apply ordExp_normal...
  destruct (classic (Î² = Î³)).
  - subst. exfalso. eapply ord_irrefl; revgoals...
  - apply ord_connected in H0 as []...
    apply (proj1 (ordExp_normal Î± HÎ± H1)) in H0...
    exfalso. eapply ord_not_lt_gt; revgoals...
Qed.

Corollary ordAdd_cancel : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± + Î² = Î± + Î³ â†’ Î² = Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Heq.
  contra. apply ord_connected in H as [Hlt|Hlt]...
  - assert (Î± + Î² âˆˆ Î± + Î³). apply ordAdd_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
  - assert (Î± + Î³ âˆˆ Î± + Î²). apply ordAdd_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
Qed.

Corollary ordMul_cancel : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‰  0 â†’ Î± â‹… Î² = Î± â‹… Î³ â†’ Î² = Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Heq.
  contra. apply ord_connected in H as [Hlt|Hlt]...
  - assert (Î± â‹… Î² âˆˆ Î± â‹… Î³). apply ordMul_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
  - assert (Î± â‹… Î³ âˆˆ Î± â‹… Î²). apply ordMul_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
Qed.

Corollary ordExp_cancel : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î± â†’ Î± ^ Î² = Î± ^ Î³ â†’ Î² = Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H1 Heq.
  contra. apply ord_connected in H as [Hlt|Hlt]...
  - assert (Î± ^ Î² âˆˆ Î± ^ Î³). apply ordExp_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
  - assert (Î± ^ Î³ âˆˆ Î± ^ Î²). apply ordExp_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
Qed.

(** Addition, multiplication and exponentiation is
  non-strictly increasing in the both left and right argument. **)

Theorem ordAdd_preserve_leq_l : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î± + Î³ â‹¸ Î² + Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH.
  ord_destruct Î³.
  - subst. rewrite ordAdd_0_r, ordAdd_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    rewrite ordAdd_suc, ordAdd_suc...
    rewrite <- ord_suc_preserve_leq...
  - apply ord_leq_iff_sub...
    rewrite ordAdd_limit, ordAdd_limit...
    intros x Hx. apply FUnionE in Hx as [Î´ [HÎ´ Hx]].
    assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI... apply IH in HÎ´ as []...
    eapply ord_trans... congruence.
Qed.

Fact ordAdd_preserve_leq_r : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î³ + Î± â‹¸ Î³ + Î².
Proof.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ [].
  left. apply ordAdd_preserve_lt; auto.
  right. congruence.
Qed.

Theorem ordMul_preserve_leq_l : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î± â‹… Î³ â‹¸ Î² â‹… Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH.
  ord_destruct Î³.
  - subst. rewrite ordMul_0_r, ordMul_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    rewrite ordMul_suc, ordMul_suc...
    eapply ord_le_tran; revgoals.
    + apply ordAdd_preserve_leq_l; revgoals.
      apply IH... auto. auto. auto.
    + destruct Hle.
      * left. apply ordAdd_normal...
      * right. congruence.
    + auto. + auto. + auto.
  - apply ord_leq_iff_sub...
    rewrite ordMul_limit, ordMul_limit...
    intros x Hx. apply FUnionE in Hx as [Î´ [HÎ´ Hx]].
    assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI... apply IH in HÎ´ as []...
    eapply ord_trans... congruence.
Qed.

Fact ordMul_preserve_leq_r : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î³ â‹… Î± â‹¸ Î³ â‹… Î².
Proof with auto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  destruct (classic (Î³ = 0)). {
    subst. rewrite ordMul_0_l, ordMul_0_l...
  }
  destruct Hle.
  left. apply ordMul_preserve_lt...
  right. congruence.
Qed.

Theorem ordExp_preserve_leq_l : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î± ^ Î³ â‹¸ Î² ^ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH.
  ord_destruct Î³.
  - subst. rewrite ordExp_0_r, ordExp_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    destruct (classic (Î± = 0)). {
      subst. rewrite ordExp_0_l...
      apply ord_leq_iff_not_gt... intros H. exfalso0.
    }
    rewrite ordExp_suc, ordExp_suc...
    eapply ord_le_tran; revgoals.
    + apply ordMul_preserve_leq_l; revgoals.
      apply IH... 1-3: auto.
    + destruct Hle.
      * left. apply ordMul_normal... intros H1.
        apply ord_pow_eq_0 in H1...
      * right. congruence.
    + auto. + auto. + auto.
  - destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. rewrite ordExp_0_l...
      apply ord_leq_iff_not_gt... intros H. exfalso0.
    }
    destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. destruct Hle. exfalso0.
      subst. rewrite ordExp_0_l...
    }
    apply ord_leq_iff_sub...
    rewrite ordExp_limit, ordExp_limit...
    intros x Hx. apply FUnionE in Hx as [Î´ [HÎ´ Hx]].
    assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI... apply IH in HÎ´ as []...
    eapply ord_trans... congruence.
Qed.

Fact ordExp_preserve_leq_r : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î³ â†’
  Î± â‹¸ Î² â†’ Î³ ^ Î± â‹¸ Î³ ^ Î².
Proof.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 [].
  left. apply ordExp_preserve_lt; auto.
  right. congruence.
Qed.

Example Ï‰_lt_Ï‰_exp_Ï‰ : Ï‰ âˆˆ Ï‰ ^ Ï‰.
Proof with nauto.
  eapply (ord_trans _ _ _ (Ï‰ ^ 2)); revgoals.
  apply ordExp_preserve_lt...
  rewrite pred, ordExp_suc, ordExp_1_r...
  eapply (ord_trans _ _ _ (Ï‰ â‹… 2)); revgoals.
  apply ordMul_preserve_lt...
  rewrite pred, ordMul_suc, ordMul_1_r...
  eapply (ord_trans _ _ _ (Ï‰ + 1)); revgoals.
  apply ordAdd_preserve_lt...
  rewrite ordAdd_1_r...
  Unshelve. 1-3: auto.
Qed.

Lemma ordAdd_enlarge_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± âˆˆ Î² â†’ Î± âˆˆ Î² + Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  destruct (classic (Î³ = 0)). subst. rewrite ordAdd_0_r...
  rewrite <- (ordAdd_0_r Î²) in Hle...
  apply (ord_lt_tran Î± HÎ± (Î² + 0))...
  apply ordAdd_preserve_lt... apply ord_neq_0_gt_0...
Qed.

Lemma ordAdd_enlarge_leq : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‹¸ Î² â†’ Î± â‹¸ Î² + Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  rewrite <- (ordAdd_0_r Î²) in Hle...
  apply (ord_le_tran Î± HÎ± (Î² + 0))...
  apply ordAdd_preserve_leq_r...
  apply ord_leq_iff_not_gt... intros H. exfalso0.
Qed.

Lemma ordMul_enlarge_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± âˆˆ Î² â†’ Î± âˆˆ Î² â‹… Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). subst. exfalso0.
  destruct (classic (Î³ = 1)). subst. rewrite ordMul_1_r...
  rewrite <- (ordMul_1_r Î²) in Hle...
  eapply (ord_lt_tran Î± HÎ± (Î² â‹… 1))...
  apply ordMul_preserve_lt...
  apply gt_1_iff_neq_0_1...
Qed.

Lemma ordMul_enlarge_leq : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± â‹¸ Î² â†’ Î± â‹¸ Î² â‹… Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). subst. rewrite ordMul_0_l...
  rewrite <- (ordMul_1_r Î²) in Hle...
  eapply (ord_le_tran Î± HÎ± (Î² â‹… 1))...
  apply ordMul_preserve_leq_r...
  apply ord_leq_iff_not_gt... intros H1.
  rewrite one in H1. apply SingE in H1...
Qed.

Lemma ordExp_enlarge_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± âˆˆ Î² â†’ Î± âˆˆ Î² ^ Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). subst. exfalso0.
  destruct (classic (Î² = 1)). {
    subst. rewrite one in Hle. apply SingE in Hle.
    subst. apply ord_neq_0_gt_0...
    intros Hpow. apply ord_pow_eq_0 in Hpow...
  }
  destruct (classic (Î³ = 1)). subst. rewrite ordExp_1_r...
  rewrite <- (ordExp_1_r Î²) in Hle...
  eapply (ord_lt_tran Î± HÎ± (Î² ^ 1))...
  apply ordExp_preserve_lt...
  1-2: apply gt_1_iff_neq_0_1...
Qed.

Lemma ordExp_enlarge_leq : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± â‹¸ Î² â†’ Î± â‹¸ Î² ^ Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). subst. rewrite ordExp_0_l...
  destruct (classic (Î² = 1)). subst. rewrite ordExp_1_l...
  rewrite <- (ordExp_1_r Î²) in Hle...
  eapply (ord_le_tran Î± HÎ± (Î² ^ 1))...
  apply ordExp_preserve_leq_r...
  apply gt_1_iff_neq_0_1...
  apply ord_leq_iff_not_gt... intros HÎ³1.
  rewrite one in HÎ³1. apply SingE in HÎ³1...
Qed.

Theorem ord_subtraction : âˆ€ Î± Î² â‹µ ğğ, Î± â‹¸ Î² â†’ âˆƒ!Î´ â‹µ ğğ, Î± + Î´ = Î².
Proof with eauto.
  intros Î± HÎ± Î² HÎ² [Hlt|Heq]; revgoals. {
    exists 0. split. rewrite ordAdd_0_r...
    intros x [Hx H]. subst. rewrite <- ordAdd_0_r in H...
    apply ordAdd_cancel in H...
  }
  pose proof (normal_operation_domain_has_maximum (OrdAdd Î±)) as [Î´ [HoÎ´ [HÎ´ Hmax]]]...
  apply ordAdd_normal... rewrite ordAdd_0_r...
  assert (Hrp: âˆ€ x âˆˆ RangeAmong (OrdAdd Î±) Î²âº, âˆƒ!y â‹µ ğğ, Î± + y = x). {
    intros x Hx. apply SepE in Hx as [Hx [y [Hy Heq]]].
    exists y. split... intros y' [Hy' H']. subst.
    apply ordAdd_cancel in H'...
  }
  apply Ï•_ReplAx in HÎ´ as [Ïƒ [HÏƒ [_ Heq]]]...
  subst. apply SepE1 in HÏƒ as Hle.
  apply ord_leq_iff_lt_suc in Hle...
  exists Î´. split.
  - split... destruct Hle... exfalso.
    apply (ord_irrefl Î´âº)... apply ord_leq_iff_lt_suc...
    apply Hmax. apply Ï•_ReplAx... exists (Î± + Î´âº). split...
    apply SepI. rewrite ordAdd_suc...
    rewrite <- ord_suc_preserve_lt... exists Î´âº...
  - intros Î´' [HÎ´' Heq].
    apply sub_antisym; apply ord_leq_iff_sub...
    + apply ord_leq_iff_lt_suc...
      apply (ordAdd_preserve_lt Î±)...
      eapply ord_le_lt_tran; revgoals; swap 1 2.
      apply Hle. 2-4: auto. rewrite <- Heq, ordAdd_suc...
    + apply Hmax. apply Ï•_ReplAx... exists (Î± + Î´'). split...
      apply SepI. apply ord_leq_iff_lt_suc... exists Î´'...
Qed.

Theorem ord_division : âˆ€ Î± Î´ â‹µ ğğ, Î´ â‰  0 â†’
  âˆƒ! Î² Î³ â‹µ ğğ, Î± = Î´ â‹… Î² + Î³ âˆ§ Î³ âˆˆ Î´.
Proof with eauto.
  intros Î± HÎ± Î´ HÎ´ HÎ´0.
  destruct (classic (Î± = 0)) as [|HÎ±0]. {
    subst. exists 0. split.
    - split... exists 0. split.
      + split... rewrite ordMul_0_r, ordAdd_0_r...
        split... apply ord_neq_0_gt_0...
      + intros Î³ [HÎ³ [H _]]. rewrite ordMul_0_r, ordAdd_0_l in H...
    - intros Î² [HÎ² [Î³ [[HÎ³ [Heq _]] _]]]. symmetry in Heq.
      apply ord_sum_eq_0 in Heq as []...
      apply ord_prd_eq_0 in H as []... exfalso...
  }
  pose proof (normal_operation_domain_has_maximum (OrdMul Î´)) as [Î² [HoÎ² [HÎ² Hmax]]].
  auto. apply ordMul_normal... apply HÎ±.
  rewrite ordMul_0_r... apply ord_neq_0_gt_0...
  assert (Hrp: âˆ€x âˆˆ RangeAmong (OrdMul Î´) Î±âº, âˆƒ!y â‹µ ğğ, Î´ â‹… y = x). {
    intros x Hx. apply SepE in Hx as [Hx [y [Hy Heq]]].
    exists y. split... intros y' [Hy' H']. subst.
    apply ordMul_cancel in H'...
  }
  apply Ï•_ReplAx in HÎ² as [Ïƒ [HÏƒ [_ Heq]]]...
  subst. apply SepE1 in HÏƒ as Hle.
  apply ord_leq_iff_lt_suc in Hle...
  exists Î². split.
  - split... apply ord_subtraction in Hle as [Î³ [[HÎ³ Heq] Hu]]...
    exists Î³. repeat split; [..|intros Î³' [HÎ³' [Heq' _]]; apply Hu]...
    contra as C. apply ord_leq_iff_not_gt in C...
    apply (ord_irrefl Î²âº)... apply ord_leq_iff_lt_suc...
    apply Hmax. apply Ï•_ReplAx... exists (Î´ â‹… Î²âº). split...
    apply SepI. apply ord_leq_iff_lt_suc...
    rewrite ordMul_suc... rewrite <- Heq.
    apply ordAdd_preserve_leq_r... exists Î²âº...
  - intros Î²' [HÎ²' [Î³' [[HÎ³' [Heq Hlt]] _]]].
    apply sub_antisym; apply ord_leq_iff_sub...
    + apply ord_leq_iff_lt_suc...
      apply (ordMul_preserve_lt Î´)...
      eapply ord_le_lt_tran; revgoals; swap 1 2.
      apply Hle. 2-4: auto. rewrite Heq, ordMul_suc...
      apply ordAdd_preserve_lt...
    + apply Hmax. apply Ï•_ReplAx... exists (Î´ â‹… Î²'). split...
      apply SepI. apply ord_leq_iff_lt_suc...
      rewrite Heq. apply ordAdd_enlarge_leq... exists Î²'...
Qed.

Theorem ord_logarithm : âˆ€ Î± Î² â‹µ ğğ, Î± â‰  0 â†’ 1 âˆˆ Î² â†’
  âˆƒ! Î³ Î´ Ï â‹µ ğğ, Î± = Î² ^ Î³ â‹… Î´ + Ï âˆ§ Î´ â‰  0 âˆ§ Î´ âˆˆ Î² âˆ§ Ï âˆˆ Î² ^ Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² HÎ±0 HÎ²1.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. exists 0. split.
    - split... exists 1. split.
      + split... exists 0. split.
        * split... rewrite ordExp_0_r, ordMul_1_r, ordAdd_0_r...
          repeat split... apply suc_has_0...
        * intros Ï [HÏ [H _]]. rewrite ordExp_0_r, ordMul_1_r in H...
          rewrite <- (ordAdd_0_r 1) in H at 1...
          apply ordAdd_cancel in H...
      + intros Î´ [HÎ´ [Ï [[HÏ [H [_ [_ Hlt]]]] _]]].
        rewrite ordExp_0_r in H, Hlt...
        rewrite one in Hlt. apply SingE in Hlt. subst.
        rewrite ordMul_1_l, ordAdd_0_r in H...
    - intros Î³ [HÎ³ [Î´ [[HÎ´ [Ï [[HÏ [Heq [HÎ´0 _]]] _]]] _]]].
      symmetry. contra. apply ord_neq_0_gt_0 in H...
      apply (ordExp_preserve_lt Î²) in H...
      rewrite ordExp_0_r, Heq in H...
      eapply (ordMul_enlarge_lt _ _ _ _ Î´) in H...
      eapply (ordAdd_enlarge_lt _ _ _ _ Ï) in H...
      eapply ord_irrefl; revgoals...
  }
  pose proof (normal_operation_domain_has_maximum (OrdExp Î²)) as [Î³ [HoÎ³ [HÎ³ Hmax]]].
  auto. apply ordExp_normal... apply HÎ±.
  rewrite ordExp_0_r... apply gt_1_iff_neq_0_1...
  assert (Hrp: âˆ€x âˆˆ RangeAmong (OrdExp Î²) Î±âº, âˆƒ!y â‹µ ğğ, Î² ^ y = x). {
    intros x Hx. apply SepE in Hx as [Hx [y [Hy Heq]]].
    exists y. split... intros y' [Hy' H']. subst.
    apply ordExp_cancel in H'...
  }
  apply Ï•_ReplAx in HÎ³ as [Ïƒ [HÏƒ [_ Heq]]]...
  subst. apply SepE1 in HÏƒ as Hle.
  apply ord_leq_iff_lt_suc in Hle...
  exists Î³. split.
  - split... pose proof (ord_division Î± HÎ± (Î² ^ Î³)) as [Î´ [[HÎ´ [Ï [[HÏ [H1 H2]] Hu1]]] Hu2]]...
    intros H0. apply ord_pow_eq_0 in H0... subst. exfalso0.
    exists Î´. split.
    + split... exists Ï. split; revgoals. {
        intros Ï' [HÏ' [H1' [_ [_ H2']]]]. apply Hu1...
      }
      repeat split...
      * intros H0. rewrite H0, ordMul_0_r, ordAdd_0_l in H1...
        rewrite <- H1 in H2. apply ord_leq_iff_not_gt in H2...
      * contra as C. apply ord_leq_iff_not_gt in C...
        apply (ord_irrefl Î³âº)... apply ord_leq_iff_lt_suc...
        apply Hmax. apply Ï•_ReplAx... exists (Î² ^ Î³âº). split...
        apply SepI. apply ord_leq_iff_lt_suc...
        rewrite ordExp_suc... rewrite H1.
        eapply (ord_le_tran _ _ (Î² ^ Î³ â‹… Î´))...
        apply ordMul_preserve_leq_r...
        apply ordAdd_enlarge_leq... exists Î³âº...
    + intros Î´' [HÎ´' [Ï' [[HÏ' [H1' [Hlt1 [Hlt2 H2']]]] Hu]]].
      apply Hu2. split... exists Ï'. split...
      intros Ï'' [HÏ'' [H1'' H2'']]. apply Hu...
  - intros Î³' [HÎ³' [Î´' [[HÎ´' [Ï' [[HÏ' [H1 [H2 [H3 H4]]]] _]]] _]]].
    apply sub_antisym; apply ord_leq_iff_sub...
    + apply ord_leq_iff_lt_suc...
      apply (ordExp_preserve_lt Î²)...
      eapply ord_le_lt_tran; revgoals; swap 1 2.
      apply Hle. 2-4: auto. rewrite H1, ordExp_suc...
      eapply ord_lt_le_tran; revgoals; swap 1 2.
      apply ordAdd_preserve_lt; revgoals... 2-4: auto.
      rewrite <- ordMul_suc...
      apply ordMul_preserve_leq_r...
      apply ord_suc_correct...
    + apply Hmax. apply Ï•_ReplAx... exists (Î² ^ Î³'). split...
      apply SepI. apply ord_leq_iff_lt_suc...
      rewrite H1. apply ordAdd_enlarge_leq...
      apply ordMul_enlarge_leq... exists Î³'...
  Unshelve. 1-5: auto.
Qed.

Theorem ordAdd_assoc : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± + Î² + Î³ = Î± + (Î² + Î³).
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³.
  generalize dependent Î².
  generalize dependent Î±.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH Î± HÎ± Î² HÎ².
  ord_destruct Î³.
  - subst. rewrite ordAdd_0_r, ordAdd_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    repeat rewrite ordAdd_suc... rewrite IH...
  - ext Î¾ HÎ¾.
    + rewrite ordAdd_limit in HÎ¾...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite IH in HÎ¾... eapply ord_trans...
      apply ordAdd_normal, ordAdd_normal...
    + rewrite ordAdd_limit in HÎ¾...
      2: apply ord_sum_limit...
      2: intros H; apply ord_sum_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordAdd_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). eapply ord_is_ords; revgoals...
      assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords; revgoals...
      apply (ordAdd_preserve_lt Î±) in HÎ´...
      rewrite <- IH in HÎ´...
      eapply ord_trans, ord_trans...
      apply ordAdd_preserve_lt...
Qed.

Theorem ordMul_distr : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‹… (Î² + Î³) = Î± â‹… Î² + Î± â‹… Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³.
  generalize dependent Î².
  generalize dependent Î±.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH Î± HÎ± Î² HÎ².
  ord_destruct Î³.
  - subst. rewrite ordAdd_0_r, ordMul_0_r, ordAdd_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    rewrite ordMul_suc, ordAdd_suc, ordMul_suc, IH, ordAdd_assoc...
  - destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. repeat rewrite ordMul_0_l... rewrite ordAdd_0_r...
    }
    ext Î¾ HÎ¾.
    + rewrite ordMul_limit in HÎ¾...
      2: apply ord_sum_limit...
      2: intros H; apply ord_sum_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      assert (HoÎ´: Î´ â‹µ ğğ). apply (ord_is_ords (Î² + Î³))...
      rewrite ordAdd_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). apply (ord_is_ords Î³)...
      eapply (ordMul_preserve_lt Î±) in HÎ´...
      rewrite IH in HÎ´... eapply ord_trans, ord_trans...
      apply ordAdd_normal, ordMul_normal...
    + rewrite ordAdd_limit in HÎ¾...
      2: apply ord_prd_limit_r...
      2: intros H; apply ord_prd_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordMul_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). eapply ord_is_ords; revgoals...
      assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords; revgoals...
      apply (ordAdd_preserve_lt (Î± â‹… Î²)) in HÎ´...
      rewrite <- IH in HÎ´...
      eapply ord_trans, ord_trans...
      apply ordMul_preserve_lt, ordAdd_preserve_lt...
Qed.

Theorem ordMul_assoc : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‹… Î² â‹… Î³ = Î± â‹… (Î² â‹… Î³).
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³.
  generalize dependent Î².
  generalize dependent Î±.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH Î± HÎ± Î² HÎ².
  ord_destruct Î³.
  - subst. repeat rewrite ordMul_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    repeat rewrite ordMul_suc... repeat rewrite IH...
    rewrite ordMul_distr...
  - destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. repeat rewrite ordMul_0_l...
    }
    destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. rewrite ordMul_0_l, ordMul_0_r, ordMul_0_l...
    }
    ext Î¾ HÎ¾.
    + rewrite ordMul_limit in HÎ¾...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite IH in HÎ¾... eapply ord_trans...
      apply ordMul_normal, ordMul_normal...
    + rewrite ordMul_limit in HÎ¾...
      2: apply ord_prd_limit_r...
      2: intros H; apply ord_prd_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordMul_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). eapply ord_is_ords; revgoals...
      assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords; revgoals...
      apply (ordMul_preserve_lt Î±) in HÎ´...
      rewrite <- IH in HÎ´...
      eapply ord_trans, ord_trans...
      apply ordMul_preserve_lt...
      intros H. apply ord_prd_eq_0 in H as []...
Qed.

Theorem ordExp_add : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± ^ (Î² + Î³) = Î± ^ Î² â‹… Î± ^ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³.
  generalize dependent Î².
  generalize dependent Î±.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH Î± HÎ± Î² HÎ².
  ord_destruct Î³.
  - subst. rewrite ordAdd_0_r, ordExp_0_r, ordMul_1_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    rewrite ordAdd_suc, ordExp_suc, ordExp_suc, IH, ordMul_assoc...
  - destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. rewrite ordAdd_0_l, ordExp_0_r, ordMul_1_l...
    }
    destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. repeat rewrite ordExp_0_l... rewrite ordMul_0_r...
      intros H. apply ord_sum_eq_0 in H as []...
    }
    destruct (classic (Î± = 1)) as [|HÎ±1]. {
      subst. repeat rewrite ordExp_1_l... rewrite ordMul_1_r...
    }
    assert (H1Î±: 1 âˆˆ Î±). apply gt_1_iff_neq_0_1...
    ext Î¾ HÎ¾.
    + rewrite ordExp_limit in HÎ¾...
      2: apply ord_sum_limit...
      2: intros H; apply ord_sum_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordAdd_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). apply (ord_is_ords Î³)...
      assert (HoÎ´: Î´ â‹µ ğğ). apply (ord_is_ords (Î² + Îµ))...
      eapply (ordExp_preserve_lt Î±) in HÎ´...
      eapply ord_trans, ord_trans... rewrite IH...
      apply ordMul_normal, ordExp_normal...
      intros H. apply ord_pow_eq_0 in H...
    + rewrite ordMul_limit in HÎ¾...
      2: apply ord_pow_limit_r...
      2: intros H; apply ord_pow_eq_0 in H...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordExp_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). eapply ord_is_ords; revgoals...
      assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords; revgoals...
      apply (ordMul_preserve_lt (Î± ^ Î²)) in HÎ´...
      2: intros H'; apply ord_pow_eq_0 in H'...
      eapply ord_trans, ord_trans... rewrite <- IH...
      apply ordExp_normal, ordAdd_normal...
Qed.

Theorem ordExp_exp : âˆ€ Î± Î² Î³ â‹µ ğğ, (Î± ^ Î²) ^ Î³ = Î± ^ (Î² â‹… Î³).
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³.
  generalize dependent Î².
  generalize dependent Î±.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH Î± HÎ± Î² HÎ².
  ord_destruct Î³.
  - subst. rewrite ordExp_0_r, ordMul_0_r, ordExp_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    rewrite ordExp_suc, ordMul_suc, IH, ordExp_add...
  - destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. rewrite ordExp_0_r, ordExp_1_l, ordMul_0_l, ordExp_0_r...
    }
    destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. repeat rewrite ordExp_0_l...
      intros H. apply ord_prd_eq_0 in H as []...
    }
    destruct (classic (Î± = 1)) as [|HÎ±1]. {
      subst. repeat rewrite ordExp_1_l...
    }
    assert (H1Î±: 1 âˆˆ Î±). apply gt_1_iff_neq_0_1...
    ext Î¾ HÎ¾.
    + rewrite ordExp_limit in HÎ¾...
      2: intros H; apply ord_pow_eq_0 in H...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      eapply ord_trans... rewrite IH...
      apply ordExp_normal, ordMul_normal...
    + rewrite ordExp_limit in HÎ¾...
      2: apply ord_prd_limit_r...
      2: intros H; apply ord_prd_eq_0 in H as []...
      apply FUnionE in HÎ¾ as [Î´ [HÎ´ HÎ¾]].
      rewrite ordMul_limit in HÎ´...
      apply FUnionE in HÎ´ as [Îµ [HÎµ HÎ´]].
      assert (HoÎµ: Îµ â‹µ ğğ). eapply ord_is_ords; revgoals...
      assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords; revgoals...
      apply (ordExp_preserve_lt Î±) in HÎ´...
      eapply ord_trans, ord_trans... rewrite <- IH...
      apply ordExp_normal... apply ordExp_enlarge_lt...
Qed.
