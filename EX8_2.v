(** Coq coding by choukh, Mar 2021 **)

Require Import ZFC.EST8_4.
Require Import ZFC.EX7_1.
Require Import ZFC.lib.NatIsomorphism.
Require Import ZFC.lib.FuncFacts.
Require Import ZFC.lib.Real.
Require Import ZFC.lib.LoStruct.
Require Import ZFC.lib.WosetMin.

(** EX8_17 **)

(* 无界序 *)
Definition unbounded := λ A R, ∀x ∈ A,
  (∃y ∈ A, (x <ᵣ y) R) ∧ ∃w ∈ A, (w <ᵣ x) R.

(* 有理数的序是无界序 *)
Fact ratLt_unbounded : unbounded ℚ RatLt.
Proof with auto.
  intros x Hx. split.
  - pose proof (rat_archimedean x Hx) as [y [Hy Hxy]].
    exists y. split...
  - pose proof (rat_archimedean (-x)%q) as [w [Hw Hxw]].
    apply ratAddInv_ran...
    exists (-w)%q. split. apply ratAddInv_ran...
    apply ratLt_addInv... apply ratAddInv_ran...
    rewrite ratAddInv_double...
Qed.

(* 稠密序 *)
Definition dense := λ R, ∀ x z, (x <ᵣ z) R → ∃ y, (x <ᵣ y) R ∧ (y <ᵣ z) R.

(* 有理数的序是稠密序 *)
Fact ratLt_dense : dense RatLt.
Proof with auto.
  intros x z Hxz.
  apply binRelE2 in Hxz as H. destruct H as [Hx [Hz _]].
  apply rat_dense in Hxz as [y [Hy [Hxy Hyz]]]...
  exists y. split...
Qed.

(* 有限线序与某个自然数同构 *)
Lemma finite_loset_iso_nat : ∀ S, finite (A S) →
  ∃ T, T ⊑ 𝛚 ∧ A T ∈ ω ∧ S ≅ T.
Proof with eauto.
  intros S Hfin.
  assert (H := Hfin). destruct Hfin as [n [Hn Hqn]].
  assert (HloT: loset n (Lt ⥏ n)). {
    eapply subRel_loset. apply Lt_wellOrder.
    apply trans_sub... apply ω_trans.
  }
  assert (HwoS: woset (A S) (R S)). apply finite_loset_is_woset...
  set (WoStruct.constr (A S) (R S) HwoS) as Sʷ.
  set (LoStruct.constr n (Lt ⥏ n) HloT) as T.
  Import WoStruct.
  Import WoStruct.EpsilonImageOfNats.
  set (Seg n 𝛚) as Tʷ.
  assert (Hiso: Sʷ ≅ Tʷ). {
    apply ord_well_defined.
    rewrite finite_ord_eq_card... simpl.
    apply CardAx1 in Hqn.
    rewrite Hqn, <- (card_of_nat n)...
    symmetry. apply α_nat...
  }
  destruct Hiso as [f [Hf Hop]]. unfold Tʷ in Hf.
  rewrite seg_a_eq, seg_of_nat in Hf...
  assert (Hsub: n ⊆ ω). apply trans_sub... apply ω_trans.
  assert (Hlo: loset n (Lt ⥏ n)). {
    eapply subRel_loset... apply Lt_wellOrder.
  }
  exists T. repeat split... exists f. split...
  apply bijection_is_func in Hf as [Hf _].
  intros x Hx y Hy. split; intros Hlt.
  - apply Hop in Hlt... apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran...
  - apply Hop... apply SepE1 in Hlt. apply seg_lt... apply SepI.
    + apply CProdI... apply (ω_trans _ n)... eapply ap_ran...
    + zfc_simple. eapply ap_ran...
Qed.

Import LoStruct.
Import SimpleVer.

(* 可数无穷稠密线序集有可数无穷稠密无界子集 *)
Lemma countable_dense_loset_has_unbounded_subset :
  ∀ S, ω ≈ A S → dense (R S) → ∃ T, T ⊑ S ∧
    ω ≈ A T ∧ dense (R T) ∧ unbounded (A T) (R T).
Proof with neauto; try congruence.
  intros S [a Hba] Hdn.
  destruct (lo S) as [Hbr [Htr _]].
  assert (Hir: irrefl (R S)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  cut ((∃ x y ∈ A S, (x <ᵣ y) (R S)) → ∃ T, T ⊑ S ∧
    ω ≈ A T ∧ dense (R T) ∧ unbounded (A T) (R T)). {
    destruct (classic (a[0] = a[1])) as [|Hnq]. {
      exfalso. apply injectiveE in H...
      rewrite Hda... rewrite Hda...
    }
    assert (Ha0: a[0] ∈ A S). eapply ap_ran...
    assert (Ha1: a[1] ∈ A S). eapply ap_ran...
    intros H. apply (lo_connected (R S) (A S) (lo S)) in Hnq as []...
    - apply H. exists (a[0]). split... exists (a[1]). split...
    - apply H. exists (a[1]). split... exists (a[0]). split...
  }
  intros [c [HcA [d [HdA Hcd]]]].
  apply Hdn in Hcd as [e [Hcd Hed]].
  apply Hbr in Hed as HeA. apply CProdE2 in HeA as [HeA _].
  set {x ∊ A S | λ x, (c <ᵣ x) (R S) ∧ (x <ᵣ d) (R S)} as C.
  set (λ x, {n ∊ ω | λ n, (c <ᵣ a[n]) (R S) ∧ (a[n] <ᵣ x) (R S)}) as Nₗ.
  set (λ x, {n ∊ ω | λ n, (x <ᵣ a[n]) (R S) ∧ (a[n] <ᵣ d) (R S)}) as Nᵣ.
  set (λ x, (Min Lt)[Nₗ x]) as mₗ.
  set (λ x, (Min Lt)[Nᵣ x]) as mᵣ.
  set (Func C C (λ x, a[mₗ x])) as fₗ.
  set (Func C C (λ x, a[mᵣ x])) as fᵣ.
  assert (HeC: e ∈ C). apply SepI...
  assert (Hmₗ: ∀x ∈ C, mₗ x ∈ ω ∧ (c <ᵣ a[mₗ x]) (R S) ∧ (a[mₗ x] <ᵣ x) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (ω_min (Nₗ x)) as [H _]. {
      apply Hdn in Hcx as [y [Hcy Hyx]].
      apply Hbr in Hyx as Hy. apply CProdE2 in Hy as [Hy _].
      exists (a⁻¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mₗ x) in H. apply SepE in H as [Hm [Hcm Hmx]]. split...
  }
  assert (Hmᵣ: ∀x ∈ C, mᵣ x ∈ ω ∧ (x <ᵣ a[mᵣ x]) (R S) ∧ (a[mᵣ x] <ᵣ d) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (ω_min (Nᵣ x)) as [H _]. {
      apply Hdn in Hxd as [y [Hxy Hyd]].
      apply Hbr in Hyd as Hy. apply CProdE2 in Hy as [Hy _].
      exists (a⁻¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mᵣ x) in H. apply SepE in H as [Hm [Hxm Hmd]]. split...
  }
  assert (Hfₗ: fₗ: C ⇒ C). {
    apply meta_maps_into. intros x Hx.
    apply Hmₗ in Hx as H. destruct H as [Hm [Hcm Hmx]].
    apply SepE2 in Hx as [_ Hxd].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  assert (Hfᵣ: fᵣ: C ⇒ C). {
    apply meta_maps_into. intros x Hx.
    apply Hmᵣ in Hx as H. destruct H as [Hm [Hxm Hmd]].
    apply SepE2 in Hx as [Hcx _].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  pose proof (ω_recursion fₗ C e Hfₗ HeC) as [hₗ [Hhₗ [Hhₗ0 Hhₗn]]].
  pose proof (ω_recursion fᵣ C e Hfᵣ HeC) as [hᵣ [Hhᵣ [Hhᵣ0 Hhᵣn]]].
  set {x ∊ A S | λ x, ∃n ∈ ω, (hₗ[n] ≤ᵣ x) (R S) ∧ (x ≤ᵣ hᵣ[n]) (R S)} as B.
  assert (HBA: B ⊆ A S). apply SepE1.
  assert (HCA: C ⊆ A S). apply SepE1.
  assert (Hdesc: ∀x ∈ C, (fₗ[x] <ᵣ x) (R S)). {
    intros x Hx. unfold fₗ. rewrite meta_func_ap... apply Hmₗ...
  }
  assert (Hasc: ∀x ∈ C, (x <ᵣ fᵣ[x]) (R S)). {
    intros x Hx. unfold fᵣ. rewrite meta_func_ap... apply Hmᵣ...
  }
  assert (Hmonoₗ: ∀ n m ∈ ω, n ∈ m → (hₗ[m] <ᵣ hₗ[n]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (hₗ[k] <ᵣ hₗ[n]) (R S)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhₗn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hdesc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hdesc... eapply ap_ran...
  }
  assert (Hmonoᵣ: ∀ n m ∈ ω, n ∈ m → (hᵣ[n] <ᵣ hᵣ[m]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (hᵣ[n] <ᵣ hᵣ[k]) (R S)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhᵣn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hasc... eapply ap_ran...
  }
  assert (Hihₗ: hₗ : ω ⇔ B). {
    destruct Hhₗ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoₗ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: x⁺ ∈ ω). apply ω_inductive...
      exists x. split... split; [right|]...
      ω_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
      + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
  }
  assert (Hihᵣ: hᵣ : ω ⇔ B). {
    destruct Hhᵣ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoᵣ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: x⁺ ∈ ω). apply ω_inductive...
      exists x. split... split; [|right]...
      ω_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
      + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
  }
  assert (Hlo: loset B (R S ⥏ B)). eapply subRel_loset...
  set (constr B (R S ⥏ B) Hlo) as T.
  exists T. split... split... split; [|split].
  - (* ω ≈ A T *)
    apply Schröeder_Bernstein.
    + exists hₗ...
    + assert (A S ≈ ω). symmetry. exists a...
      apply dominate_sub in HBA.
      eapply dominate_rewrite_r...
  - (* dense (R T) *)
    intros x y Hxy. apply SepE in Hxy as [Hxy H].
    apply CProdE2 in H as [Hx Hy].
    apply Hdn in Hxy as [z [Hxz Hzy]].
    cut (z ∈ B). {
      intros Hz. exists z; split;
      apply SepI; auto; apply CProdI...
    }
    apply Hbr in Hzy as H.
    apply CProdE2 in H as [Hz _]. apply SepI...
    apply SepE2 in Hx as [n [Hn [Hnx Hxn]]].
    apply SepE2 in Hy as [m [Hm [Hmy Hym]]].
    destruct (classic (n = m)). {
      subst m. exists n. split... split; left.
      eapply relLe_lt_tranr; revgoals...
      eapply relLt_le_tranr...
    }
    apply nat_connected in H as [Hnm|Hmn]...
    + apply Hmonoₗ in Hnm...
      exists m. split... split; left.
      * eapply relLe_lt_tranr; revgoals... left.
        eapply relLt_le_tranr...
      * eapply relLt_le_tranr...
    + apply Hmonoᵣ in Hmn...
      exists n. split... split; left.
      * eapply relLe_lt_tranr...
      * eapply relLe_lt_tranr... left.
        eapply relLt_le_tranr...
  - (* unbounded (A T) (R T)) *)
    intros x Hx. assert (H := Hx).
    apply SepE2 in H as [n [Hn [Hnx Hxn]]].
    destruct (lo T) as [_ [Htr' _]]. split. {
      destruct Hihᵣ as [[Hf _] [Hd Hr]].
      assert (Hnp: n⁺ ∈ ω). apply ω_inductive...
      exists (hᵣ[n⁺]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists n⁺. split... split; [left|right]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
        + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
      - apply (relLe_lt_tranr _ (hᵣ[n]))...
        + destruct Hxn; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
        + apply SepI. apply Hmonoᵣ...
          apply CProdI; eapply ap_ran; eauto; split...
    } {
      destruct Hihₗ as [[Hf _] [Hd Hr]].
      assert (Hnp: n⁺ ∈ ω). apply ω_inductive...
      exists (hₗ[n⁺]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists n⁺. split... split; [right|left]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
        + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
      - apply (relLt_le_tranr _ (hₗ[n]))...
        + apply SepI. apply Hmonoₗ...
          apply CProdI; eapply ap_ran; eauto; split...
        + destruct Hnx; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
    }
Qed.

(* 可数无穷稠密线序集有可数无穷良序子集 *)
Lemma countable_dense_loset_has_wo_subset :
  ∀ S, ω ≈ A S → dense (R S) → ∃ T, T ⊑ S ∧ 𝛚 ≅ T.
Proof with neauto; try congruence.
  intros S Hqn Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset
    S Hqn Hdn) as [T [[Hsub Hrel] [[a Hba] [_ Hubd]]]].
  destruct (lo T) as [_ [Htr _]].
  assert (Hir: irrefl (R T)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (λ x, {n ∊ ω | λ n, (x <ᵣ a[n]) (R S)}) as M.
  set (λ x, (Min Lt)[M x]) as m.
  set (Func (A T) (A T) (λ x, a[m x])) as f.
  assert (Hmx: ∀x ∈ A T, m x ∈ ω ∧ (x <ᵣ a[m x]) (R S)). {
    intros x Hx.
    cut (m x ∈ M x). intros H. apply SepE in H...
    apply ω_min; [|apply SepE1].
    apply Hubd in Hx as [[y [Hy Hxy]] _].
    rewrite Hrel in Hxy. apply SepE1 in Hxy.
    exists (a⁻¹[y]). apply SepI. apply (ap_ran (A T))...
    apply bijection_is_func. apply inv_bijection...
    rewrite inv_ran_reduction...
  }
  assert (Hf: f: A T ⇒ A T). {
    apply meta_maps_into. intros x Hx.
    eapply ap_ran... apply Hmx...
  }
  assert (Ha0: a[0] ∈ A T). eapply ap_ran...
  pose proof (ω_recursion f (A T) (a[0]) Hf Ha0) as [h [Hh [Hh0 Hhn]]].
  assert (Hasc: ∀x ∈ A T, (x <ᵣ f[x]) (R T)). {
    intros x Hx. unfold f. rewrite meta_func_ap, Hrel...
    apply SepI. apply Hmx... apply CProdI...
    eapply ap_ran... apply Hmx...
  }
  assert (Hmono: ∀ n m ∈ ω, n ∈ m → (h[n] <ᵣ h[m]) (R T)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (h[n] <ᵣ h[k]) (R T)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m0.
      apply Hasc... eapply ap_ran...
  }
  assert (Hop: ∀ n m ∈ ω, (h[n] <ᵣ h[m]) (R T) → n ∈ m). {
    intros n Hn k Hk Hnk.
    destruct (classic (n = k)).
    - subst k. exfalso. eapply relLt_irrefl...
    - apply nat_connected in H as []...
      apply Hmono in H... exfalso.
      eapply relLt_irrefl... eapply relLt_tranr...
  }
  assert (Hbh: h: ω ⟺ ran h). {
    destruct Hh as [Hfh [Hd Hr]].
    split; split...
    intros y Hy. split. apply ranE in Hy...
    intros x1 x2 H1 H2.
    apply domI in H1 as Hx1. rewrite Hd in Hx1.
    apply domI in H2 as Hx2. rewrite Hd in Hx2.
    apply func_ap in H1...
    apply func_ap in H2...
    destruct (classic (x1 = x2))... exfalso.
    apply nat_connected in H as []; auto;
    apply Hmono in H; auto; rewrite H1, H2 in H; eapply Hir...
  }
  assert (Hsub': ran h ⊆ A S). {
    destruct Hh as [_ [_ Hr]]. eapply sub_tran...
  }
  assert (Hlo: loset (ran h) (R S ⥏ ran h)). {
    eapply subRel_loset...
  }
  set (constr (ran h) (R S ⥏ ran h) Hlo) as U.
  exists U. split. split... exists h. split... simpl.
  intros x Hx y Hy. split; intros Hlt.
  - apply binRelE3 in Hlt.
    apply Hmono in Hlt... rewrite Hrel in Hlt.
    apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran; eauto; apply bijection_is_func...
  - apply SepE1 in Hlt. apply SepI. apply CProdI...
    zfc_simple. apply Hop... rewrite Hrel. apply SepI...
    apply CProdI; eapply ap_ran...
Qed.

(* 有限线序集与可数无穷稠密线序集的子集同构 *)
Lemma finite_loset_iso_subset_of_dense_infinite_loset :
  ∀ S, finite (A S) → ∀ T, ω ≈ A T → dense (R T) →
  ∃ U, U ⊑ T ∧ S ≅ U.
Proof with eauto; try congruence.
  intros S Hfin T Hqn Hdn.
  pose proof (finite_loset_iso_nat S Hfin)
    as [S' [[HsubS HrS] [Hn [f [Hf Hopf]]]]].
  pose proof (countable_dense_loset_has_wo_subset T Hqn Hdn)
    as [T' [[HsubT HrT] [g [Hg Hopg]]]].
  simpl in *.
  set (A S') as n.
  set ((g ↾ n) ∘ f) as h.
  assert (Hg': g ↾ n: n ⟺ g⟦n⟧). eapply restr_bijection...
  assert (Hh: h: A S ⟺ g⟦n⟧). eapply compo_bijection...
  assert (Hsub: g⟦n⟧ ⊆ A T). {
    eapply sub_tran; revgoals...
    destruct Hg as [_ [_ Hr]]. rewrite <- Hr.
    apply img_included.
  }
  assert (Hlo: loset (g⟦n⟧) (R T ⥏ g⟦n⟧)). eapply subRel_loset...
  set (constr (g⟦n⟧) (R T ⥏ g⟦n⟧) Hlo) as U.
  exists U. repeat split... exists h. split...
  destruct Hf as [[Hff _] [Hdf Hdr]].
  destruct Hg as [[Hfg _] [Hdg Hrg]].
  destruct Hg' as [[Hfg' _] _].
  assert (Hfx: ∀x ∈ A S, f[x] ∈ n). {
    intros x Hx. unfold n. rewrite <- Hdr.
    eapply ranI. apply func_correct...
  }
  assert (Hd: ∀x ∈ A S, x ∈ dom ((g ↾ n) ∘ f)). {
    intros x Hx. rewrite compo_dom... apply SepI...
    assert (dom (g ↾ n) = n). apply restr_dom... rewrite Hdg...
    rewrite H. apply Hfx...
  }
  intros x Hx y Hy.
  apply Hfx in Hx as Hfx0. apply Hfx in Hy as Hfy.
  apply Hd in Hx as Hdx. apply Hd in Hy as Hdy.
  assert (Hfxω: f[x] ∈ ω). eapply ω_trans...
  assert (Hfyω: f[y] ∈ ω). eapply ω_trans...
  unfold h. rewrite compo_correct, compo_correct...
  rewrite restr_ap, restr_ap...
  split; intros Hlt.
  - apply Hopf in Hlt...
    rewrite HrS in Hlt. apply SepE1 in Hlt.
    apply Hopg in Hlt; [|apply HsubS; apply Hfx..]...
    rewrite HrT in Hlt. apply SepE1 in Hlt.
    apply SepI... apply CProdI.
    + apply (imgI _ _ (f[x]))... apply func_correct...
    + apply (imgI _ _ (f[y]))... apply func_correct...
  - apply Hopf... rewrite HrS. apply SepI; [|apply CProdI..]...
    apply Hopg... rewrite HrT. apply SepI... apply SepE1 in Hlt...
    apply CProdI; rewrite <- Hrg; eapply ranI; apply func_correct...
Qed.

Section EX8_17.
Import FullVer.

Let FinLoMax := λ R B, (Min B (R ⥏ B)⁻¹) [B].
Let FinLoMin := λ R B, (Min B (R ⥏ B)) [B].

Local Lemma finite_loset_has_max : ∀ A R B, loset A R →
  B ≠ ∅ → B ⊆ A → finite B → maximum (FinLoMax R B) B (R ⥏ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin. apply maximum_iff_minimum_inv.
  apply min_correct... apply finite_loset_is_woset...
  apply inv_lo... eapply subRel_loset... apply EmptyNE...
Qed.

Local Lemma finite_loset_has_min : ∀ A R B, loset A R →
  B ≠ ∅ → B ⊆ A → finite B → minimum (FinLoMin R B) B (R ⥏ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin.
  apply min_correct... apply finite_loset_is_woset...
  eapply subRel_loset... apply EmptyNE...
Qed.

Import SimpleVer.

(* 对任意可数无穷线序集A和B，如果B是稠密的，那么对A的任意有限子集，
  存在B的子集与之同构，且存在以ω为定义域的函数F作为这些同构映射的枚举 *)
(* For any countably infinite loset A, B, if B is dense,
  then for any finite fragment of A, there exists subset of B that is
  isomorphic to A, and there exists a function F with domain ω,
  such that F is the enumeration of these isomorphisms *)
Local Lemma ex_enumeration_of_all_finite_isomorphisms :
  ∀ A R a, a: ω ⟺ A → loset A R →
  ∀ B S, ω ≈ B → loset B S → dense S →
  ∃ G, is_function G ∧ dom G = ω ∧ ∀n ∈ ω, G[n]: a⟦n⟧ ⇔ B ∧
    (∀ x y ∈ a⟦n⟧, (x <ᵣ y) R ↔ (G[n][x] <ᵣ G[n][y]) (S ⥏ ran G[n])) ∧
    (∀m ∈ n, ∀x ∈ a⟦m⟧, G[m][x] = G[n][x]) ∧
    (∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, G[n][x] ∉ ran G[m]).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S HqnB HloS HdnS.
  assert (H := HloR). destruct H as [_ [HtrR _]].
  assert (HirR: irrefl R). eapply lo_irrefl...
  pose proof (countable_dense_loset_has_unbounded_subset
    (constr B S HloS) HqnB HdnS)
    as [U [[Hsub HrT] [[c Hbc] [HdnT Hubd]]]].
  destruct (lo U) as [Hbr [HtrT _]].
  simpl in *. rewrite HrT in HdnT, Hubd, Hbr, HtrT.
  remember (LoStruct.A U) as C.
  remember (S ⥏ C) as T.
  assert (HirT: irrefl T). rewrite <- HrT. eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hbc). apply bijection_is_func in H as [Hmc [Hic Hrc]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (λ f, ∀ x y ∈ dom f, (x <ᵣ y) R ↔ (f[x] <ᵣ f[y]) (T ⥏ ran f)) as op.
  set (⋃{λ X, X ⟶ C | X ∊ 𝒫 A}) as fs0.
  set {f ∊ fs0 | λ f, (∃n ∈ ω, f: a⟦n⟧ ⇔ C) ∧ op f} as fs.
  set (λ f, {y ∊ dom f | λ y, (y <ᵣ a[|dom f|]) R}) as 𝐋.
  set (λ f, {y ∊ dom f | λ y, (a[|dom f|] <ᵣ y) R}) as 𝐑.
  set (λ f, FinLoMax R (𝐋 f)) as aₗ.
  set (λ f, FinLoMin R (𝐑 f)) as aᵣ.
  set (λ f, {k ∊ ω | λ k, (c[k] <ᵣ f[aᵣ f]) T}) as Nᵣ.
  set (λ f, {k ∊ ω | λ k, (f[aₗ f] <ᵣ c[k]) T}) as Nₗ.
  set (λ f, {k ∊ ω | λ k, (f[aₗ f] <ᵣ c[k]) T ∧ (c[k] <ᵣ f[aᵣ f]) T}) as Nₘ.
  set (λ f,
    match (ixm (𝐋 f = ∅)) with
    | inl _ => match (ixm (𝐑 f = ∅)) with
      | inl _ => c[0]
      | inr _ => c[(Min Lt)[Nᵣ f]]
      end
    | inr _ => match (ixm (𝐑 f = ∅)) with
      | inl _ => c[(Min Lt)[Nₗ f]]
      | inr _ => c[(Min Lt)[Nₘ f]]
      end
    end
  ) as add.
  set (λ f, f ∪ ⎨<a[|dom f|], add f>⎬) as F.
  set (Func fs fs F) as g.
  assert (Hcdn: ∀n ∈ ω, |a⟦n⟧| = n). {
    intros n Hn. rewrite (card_of_nat n) at 2...
    apply CardAx1. symmetry. exists (a ↾ n).
    eapply restr_bijection; revgoals...
    apply trans_sub... apply ω_trans.
  }
  assert (Haₗ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ C → 𝐋 f ≠ ∅ →
    ∃k ∈ n, a[k] = aₗ f ∧ (a[k] <ᵣ a[n]) R ∧
    ∀l ∈ n, (a[l] <ᵣ a[n]) R → (a[l] ≤ᵣ a[k]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_max A R (𝐋 f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [H Hlt].
      rewrite Hd in H, Hlt. rewrite Hcdn in Hlt...
      apply imgE in H as [k [Hk Hak]].
      apply func_ap in Hak... exists k. repeat split...
      intros m Hm Hamk. assert (a[m] ∈ 𝐋 f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (Haᵣ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ C → 𝐑 f ≠ ∅ →
    ∃k ∈ n, a[k] = aᵣ f ∧ (a[n] <ᵣ a[k]) R ∧
    ∀l ∈ n, (a[n] <ᵣ a[l]) R → (a[k] ≤ᵣ a[l]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_min A R (𝐑 f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [H Hlt].
      rewrite Hd in H, Hlt. rewrite Hcdn in Hlt...
      apply imgE in H as [k [Hk Hak]].
      apply func_ap in Hak... exists k. repeat split...
      intros m Hm Hamk. assert (a[m] ∈ 𝐑 f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (HNₗ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ C → 𝐋 f ≠ ∅ →
    (Min Lt)[Nₗ f] ∈ Nₗ f ∧ ∀ m ∈ Nₗ f, (Min Lt)[Nₗ f] ⋸ m). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (ω_min (Nₗ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aₗ f] ∈ C). {
        apply Hr. eapply ranI. apply func_correct...
        pose proof Haₗ as [k [Hk [Hak _]]]...
        rewrite <- Hak, Hd. eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      pose proof (Hubd (f[aₗ f]) H) as [[w [Hw Hlt]] _].
      exists (c⁻¹[w]). apply SepI.
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNᵣ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ C → 𝐑 f ≠ ∅ →
    (Min Lt)[Nᵣ f] ∈ Nᵣ f ∧ ∀ m ∈ Nᵣ f, (Min Lt)[Nᵣ f] ⋸ m). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (ω_min (Nᵣ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aᵣ f] ∈ C). {
        apply Hr. eapply ranI. apply func_correct...
        pose proof Haᵣ as [k [Hk [Hak _]]]...
        rewrite <- Hak, Hd. eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      pose proof (Hubd (f[aᵣ f]) H) as [_ [w [Hw Hlt]]].
      exists (c⁻¹[w]). apply SepI.
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Himg0: a⟦∅⟧ = ∅). {
    apply ExtAx. split; intros Hx; [|exfalso0].
    apply imgE in Hx as [w [Hw _]]. exfalso0.
  }
  assert (HNₘ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ C → op f → 𝐋 f ≠ ∅ → 𝐑 f ≠ ∅ →
    (Min Lt)[Nₘ f] ∈ Nₘ f ∧ ∀ m ∈ Nₘ f, (Min Lt)[Nₘ f] ⋸ m). {
    intros n Hn f Hif Hop HneL HneR.
    apply injection_is_func in Hif as H. destruct H as [Hmf _].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    apply (ω_min (Nₘ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - pose proof (HdnT (f[aₗ f]) (f[aᵣ f])) as [qₘ [H1 H2]]. {
        pose proof Haₗ as [k [Hk [Hak [H1 _]]]]...
        pose proof Haᵣ as [l [Hl [Hal [H2 _]]]]...
        rewrite <- Hak, <- Hal.
        assert (Hakl: (a[k] <ᵣ a[l]) R). eapply relLt_tranr...
        eapply Hop in Hakl.
        - apply SepE1 in Hakl...
        - rewrite Hdf. apply (imgI _ _ k)... apply func_correct...
          rewrite Hda. eapply ω_trans...
        - rewrite Hdf. apply (imgI _ _ l)... apply func_correct...
            rewrite Hda. eapply ω_trans...
      }
      assert (Hqₘ: qₘ ∈ C). {
        apply Hbr in H1. apply CProdE2 in H1 as [_ H]...
      }
      exists (c⁻¹[qₘ]). apply SepI...
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Hadd: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ C → op f → add f ∈ C). {
    intros n Hn f Hif Hop. unfold add.
    apply injection_is_func in Hif as H. destruct H as [Hmf _].
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    destruct (ixm (𝐋 f = ∅)) as [HL|HL];
    destruct (ixm (𝐑 f = ∅)) as [HR|HR]; eapply ap_ran...
    - pose proof HNᵣ as [H _]... apply SepE1 in H...
    - pose proof HNₗ as [H _]... apply SepE1 in H...
    - pose proof HNₘ as [H _]... apply SepE1 in H...
  }
  assert (H00: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ C → n = ∅ ↔ 𝐋 f = ∅ ∧ 𝐑 f = ∅). {
    intros n Hn f [Hf [Hd _]]. split.
    - intros Heq. subst n. rewrite Himg0 in Hd.
      split; [unfold 𝐋|unfold 𝐑]; rewrite Hd; apply sep_empty.
    - intros [HL0 HR0]. destruct (classic (n = ∅))...
      exfalso. apply pred_exists in H as [k [Hk Heq]]... subst n.
      destruct (classic (a[k] = a[k⁺])). {
        apply injectiveE in H... assert (k ∈ k⁺)...
        rewrite <- H in H0 at 1. eapply nat_irrefl...
      }
      apply (lo_connected R A) in H as []; revgoals.
      eapply ap_ran... eapply ap_ran... apply HloR.
      + eapply EmptyNI in HR0... exists (a[k]).
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
      + eapply EmptyNI in HL0... exists (a[k]).
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
  }
  assert (Hout: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ C → op f → add f ∉ ran f). {
    intros n Hn f Hif Hop Hin.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: a⟦n⟧ ⟺ ran f). split...
    apply ranE in Hin as [x Hfx]. apply domI in Hfx as Hx.
    rewrite Hdf in Hx. apply imgE in Hx as [k [Hk Hak]].
    apply func_ap in Hak... apply func_ap in Hfx...
    subst x. unfold add in Hfx.
    assert (Hkω: k ∈ ω). eapply ω_trans...
    destruct (classic (a[k] = a[n])) as [|Hnq]. {
      apply injectiveE in H... eapply nat_not_lt_self...
    }
    assert (Hak: a[k] ∈ a⟦n⟧). {
      apply (imgI _ _ k)... apply func_correct...
    }
    destruct (ixm (𝐋 f = ∅)) as [HL|HL];
    destruct (ixm (𝐑 f = ∅)) as [HR|HR].
    + assert (n = ∅). eapply H00... subst n. exfalso0.
    + pose proof HNᵣ as [Hkl _]; revgoals...
      pose proof Haᵣ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
      apply SepE2 in Hkl. rewrite <- Hfx, <- Heq in Hkl.
      assert (Hal: a[l] ∈ a⟦n⟧). {
        apply (imgI _ _ l)... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      assert (Hakl: (a[k] <ᵣ a[l]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
      * eapply EmptyNI in HL... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
    + pose proof HNₗ as [Hlk _]; revgoals...
      pose proof Haₗ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
      apply SepE2 in Hlk. rewrite <- Hfx, <- Heq in Hlk.
      assert (Hal: a[l] ∈ a⟦n⟧). {
        apply (imgI _ _ l)... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      assert (Halk: (a[l] <ᵣ a[k]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * eapply EmptyNI in HR... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
    + pose proof HNₘ as [Hkl _]; revgoals...
      pose proof Haₗ as [lₗ [Hlₗ [Heqₗ [Hnlₗ Hleₗ]]]]; revgoals...
      pose proof Haᵣ as [lᵣ [Hlᵣ [Heqᵣ [Hnlᵣ Hleᵣ]]]]; revgoals...
      apply SepE2 in Hkl. rewrite <- Hfx, <- Heqₗ, <- Heqᵣ in Hkl.
      destruct Hkl as [Hlk Hkl].
      assert (Halₗ: a[lₗ] ∈ a⟦n⟧). {
        apply (imgI _ _ lₗ)... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      assert (Halᵣ: a[lᵣ] ∈ a⟦n⟧). {
        apply (imgI _ _ lᵣ)... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      assert (Halk: (a[lₗ] <ᵣ a[k]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      assert (Hakl: (a[k] <ᵣ a[lᵣ]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hleᵣ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
      * apply Hleₗ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
  }
  assert (Himg: ∀n ∈ ω, a⟦n⁺⟧ = a⟦n⟧ ∪ ⎨a[n]⎬). {
    intros n Hn. replace ⎨a[n]⎬ with (a⟦⎨n⎬⟧).
    apply img_bunion_distr.
    apply ExtAx. split; intros Hx.
    - apply imgE in Hx as [w [Hw Hp]]. apply SingE in Hw; subst.
      apply func_ap in Hp... subst x...
    - apply SingE in Hx; subst. apply (imgI _ _ n)...
      apply func_correct...
  }
  assert (Hdj1: ∀n ∈ ω, disjoint (a⟦n⟧) ⎨a[n]⎬). {
    intros n Hn. apply disjointI. intros [x [H1 H2]].
    apply SingE in H2; subst x.
    apply imgE in H1 as [k [Hk Hp]].
    apply func_ap in Hp... apply injectiveE in Hp...
    eapply nat_not_lt_self... rewrite Hda. eapply ω_trans...
  }
  assert (Hdj2: ∀n ∈ ω, ∀f, f: a⟦n⟧ ⇔ C → op f → disjoint (ran f) ⎨add f⎬). {
    intros n Hn f Hif Hop. apply disjointI. intros [x [H1 H2]].
    apply SingE in H2; subst x. eapply Hout...
  }
  assert (Hind: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ C → op f → F f : a⟦n⁺⟧ ⇔ C ∧ op (F f)). {
    intros n Hn f Hif Hop.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: a⟦n⟧ ⟺ ran f). split...
    cut (F f: a⟦n⁺⟧ ⟺ ran f ∪ ⎨add f⎬ ∧ op (F f)). {
      intros [[HiFf [HdFf HrFf]] HopFf].
      split... split... split...
      intros x Hx. rewrite HrFf in Hx.
      apply BUnionE in Hx as []... apply Hrf...
      apply SingE in H. subst x. eapply Hadd...
    }
    assert (HFf: F f : a⟦n⁺⟧ ⟺ ran f ∪ ⎨add f⎬). {
      unfold F. rewrite Hdf, Hcdn, Himg...
      apply bijection_add_point...
      apply Hdj1... eapply Hdj2...
    }
    split...
    assert (Hop': ∀ x y ∈ a⟦n⟧, (x <ᵣ y) R ↔ (f[x] <ᵣ f[y]) T). {
      unfold op in Hop. rewrite Hdf in Hop.
      intros x Hx y Hy. split; intros Hlt.
      - apply Hop in Hlt... apply SepE1 in Hlt...
      - apply Hop... apply SepI...
        apply CProdI; auto; eapply ranI; apply func_correct...
    }
    destruct HFf as [[Hf _] [Hd Hr]].
    intros u Hu v Hv.
    cut ((u <ᵣ v) R ↔ ((F f)[u] <ᵣ (F f)[v]) T). {
      intros H. split; intros Hlt.
      - apply SepI. apply H...
        apply CProdI; eapply ap_ran; eauto; split...
      - apply SepE1 in Hlt. apply H...
    }
    assert (Hap: ∀x ∈ dom (F f),
      x ∈ a⟦n⟧ ∧ (F f)[x] = f[x] ∨
      x = a[n] ∧ (F f)[x] = add f).
    {
      rewrite Hd, Himg... unfold F. rewrite Hdf, Hcdn...
      eapply add_point_func_ap'...
      apply Hdj1... eapply Hdj2...
    }
    apply Hap in Hu as [[Hu HFfu]|[Hu HFfu]];
    apply Hap in Hv as [[Hv HFfv]|[Hv HFfv]];
    rewrite HFfu, HFfv.
    - apply Hop'...
    - subst v. unfold add.
      apply imgE in Hu as [k [Hk Hak]].
      apply func_ap in Hak... subst u. 
      assert (Hak: a[k] ∈ a⟦n⟧). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply ω_trans...
      }
      destruct (ixm (𝐋 f = ∅)) as [HL|HL];
      destruct (ixm (𝐑 f = ∅)) as [HR|HR];
      split; intros Hlt.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNᵣ as [H _]; revgoals...
        pose proof Haᵣ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop'...
        eapply relLt_tranr...
      + pose proof HNₗ as [H _]; revgoals...
        pose proof Haₗ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNₘ as [H _]; revgoals...
        pose proof Haₗ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H as [H _]. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + pose proof HNₘ as [H _]; revgoals...
        pose proof Haᵣ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H as [_ H]. rewrite <- Heq in H.
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop'...
        eapply relLt_tranr...
    - subst u. unfold add.
      apply imgE in Hv as [k [Hk Hak]].
      apply func_ap in Hak... subst v. 
      assert (Hak: a[k] ∈ a⟦n⟧). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply ω_trans...
      }
      destruct (ixm (𝐋 f = ∅)) as [HL|HL];
      destruct (ixm (𝐑 f = ∅)) as [HR|HR];
      split; intros Hlt.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + pose proof HNᵣ as [H _]; revgoals...
        pose proof Haᵣ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNₗ as [H _]; revgoals...
        pose proof Haₗ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop'...
        eapply relLt_tranr...
      + pose proof HNₘ as [H _]; revgoals...
        pose proof Haᵣ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H as [_ H]. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + pose proof HNₘ as [H _]; revgoals...
        pose proof Haₗ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] ∈ a⟦n⟧). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply ω_trans...
        }
        apply SepE2 in H as [H _]. rewrite <- Heq in H.
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop'...
        eapply relLt_tranr...
    - split; intros Hlt; exfalso.
      + rewrite Hu, Hv in Hlt. eapply relLt_irrefl; revgoals...
      + eapply relLt_irrefl; revgoals...
  }
  assert (Hfs: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ C → op f → F f ∈ fs). {
    intros n Hn f Hf Hop. apply SepI.
    - apply UnionAx. exists (a⟦n⁺⟧ ⟶ C). split.
      + apply ReplAx. exists (a⟦n⁺⟧). split...
        apply PowerAx. rewrite <- Hra. apply img_included.
      + apply arrowI. apply Hind in Hf as [Hf _]...
        apply injection_is_func...
    - split; [|eapply Hind]...
      exists n⁺. split. apply ω_inductive... apply Hind...
  }
  assert (Hg: g: fs ⇒ fs). {
    apply meta_maps_into. intros f Hf.
    apply SepE in Hf as [Hf [[n [Hn Hif]] Hop]]. eapply Hfs...
  }
  assert (Hi0: ∅: a⟦∅⟧ ⇔ C). {
    rewrite Himg0. apply empty_injective.
  }
  assert (Hop0: op ∅). {
    intros x Hx. rewrite dom_of_empty in Hx. exfalso0.
  }
  pose proof (ω_recursion g fs ∅ Hg) as [G [HG [HG0 HGn]]]. {
    apply SepI.
    - apply UnionAx. exists (∅ ⟶ C). split.
      + apply ReplAx. exists ∅. split... apply empty_in_all_power.
      + apply arrowI. apply injection_is_func. apply empty_injective.
    - split... exists ∅. split...
  }
  assert (HiGn: ∀n ∈ ω, G[n] : a⟦n⟧ ⇔ C ∧ op G[n]). {
    intros n Hn.
    destruct HG as [HfG [HdG HrG]].
    set {n ∊ ω | λ n, G[n] : a⟦n⟧ ⇔ C ∧ op G[n]} as N.
    ω_induction N Hn. rewrite HG0...
    rewrite HGn... unfold g.
    rewrite meta_func_ap... apply Hind; auto; apply IH.
    apply HrG. eapply ranI. apply func_correct...
  }
  assert (HinG: ∀m ∈ ω, ∀x ∈ a⟦m⟧, G[m][x] = G[m⁺][x]). {
    intros m Hm x Hx. rewrite HGn... unfold g.
    rewrite meta_func_ap; [|auto|eapply ap_ran]...
    pose proof (HiGn m Hm) as [Hi Hop].
    assert (H := Hi). destruct H as [Hf [Hd Hr]].
    assert (G[m]: a⟦m⟧ ⟺ ran G[m]). split...
    symmetry. eapply add_point_func_ap...
    rewrite Hd, Hcdn... apply Hdj1... eapply Hdj2...
  }
  assert (HoutG: ∀m ∈ ω, G[m⁺][a[m]] ∉ ran G[m]). {
    intros m Hm Hr.
    pose proof (HiGn m Hm) as [HGm Hop].
    apply injection_is_func in HGm as [HGm Him].
    assert (H := HGm). destruct H as [Hfm [Hdm Hrm]].
    apply ranE in Hr as [x Hp]. apply domI in Hp as Hx.
    apply func_ap in Hp... rewrite HGn in Hp...
    unfold g in Hp. rewrite meta_func_ap in Hp; [|auto|eapply ap_ran]...
    unfold F in Hp. rewrite Hdm, Hcdn in Hp...
    assert (∀x ∈ ⎨a[m]⎬, (G[m] ∪ ⎨<a[m], add G[m]>⎬)[x] = ⎨<a[m], add G[m]>⎬[x]). {
      assert (G[m]: a⟦m⟧ ⟺ ran G[m]). split...
      eapply add_point_func_ap...
      apply Hdj1... eapply Hdj2... split...
    }
    rewrite H, single_pair_ap in Hp...
    eapply Hout... split... rewrite <- Hp.
    eapply ranI. apply func_correct...
  }
  assert (HinGn: ∀n ∈ ω, ∀m ∈ n, ∀x ∈ a⟦m⟧, (G[m])[x] = (G[n])[x]). {
    intros n Hn.
    set {n ∊ ω | λ n, ∀k ∈ n, ∀x ∈ a⟦k⟧, G[k][x] = G[n][x]} as N.
    ω_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [].
    - rewrite IH... apply HinG...
      apply imgE in Hx as [l [Hl Hp]].
      apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in H; subst k. apply HinG...
  }
  assert (HoutGn: ∀n ∈ ω, ∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, (G[n])[x] ∉ ran G[m]). {
    intros n Hn.
    set {n ∊ ω | λ n, ∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, G[n][x] ∉ ran G[m]} as N.
    ω_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [Hkm|Hkm].
    assert (Hk: k ∈ ω). eapply ω_trans...
    pose proof (HiGn k Hk) as [[[Hfk _] [Hdk _]] _].
    pose proof (HiGn m Hm) as [[[Hfm _] [Hdm _]] _].
    + apply SepE in Hx as [Hx Hx']. rewrite Himg in Hx...
      apply BUnionE in Hx as [Hx|Hx].
      * assert (x ∈ a⟦m⟧ - a⟦k⟧). apply SepI...
        apply IH in H... intros H1. apply H.
        apply ranE in H1 as [w Hp]. apply domI in Hp as Hw.
        apply func_ap in Hp... rewrite HinG...
        apply (ranI _ w). rewrite <- Hp. apply func_correct...
      * apply SingE in Hx; subst x. intros H. apply (HoutG m)...
        apply ranE in H as [x Hp]. apply domI in Hp as Hx.
        apply func_ap in Hp... rewrite <- Hp.
        apply (ranI _ x). rewrite (HinGn m)...
        apply func_correct... rewrite Hdk in Hx. rewrite Hdm.
        apply imgE in Hx as [l [Hl Ha]].
        apply (imgI _ _ l)... eapply nat_trans...
    + apply SingE in Hkm; subst k.
      rewrite img_comp_distr in Hx; [|apply Hia].
      rewrite suc_comp, img_single in Hx...
      apply SingE in Hx; subst. apply HoutG...
  }
  exists G. split; [|split]; [apply HG..|intros n Hn].
  pose proof (HiGn n Hn) as [[Hi [Hd Hr]] Hop].
  unfold op in Hop. rewrite Hd in Hop.
  rewrite HeqT, subRel_absorption in Hop...
  split. split... split... eapply sub_tran...
  split... split. apply HinGn... apply HoutGn...
Qed.

(* 有限同构映射的并 *)
Local Lemma sup_finite_isomorphisms :
  ∀ A R a, a: ω ⟺ A → loset A R → 
  ∀ B S, ω ≈ B → loset B S → dense S →
  ∃ f, f: A ⇔ B ∧ ∀ x y ∈ A, (x <ᵣ y) R ↔ (f[x] <ᵣ f[y]) (S ⥏ ran f).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S HqnB HloS HdnS.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  pose proof (ex_enumeration_of_all_finite_isomorphisms)
    as [G [HfG [HdG Hstar]]]...
  set (sup{ap G | n ∊ ω}) as f.
  assert (HG: ∀p ∈ f, ∃n ∈ ω, p ∈ G[n]). {
    intros p Hp. apply UnionAx in Hp as [y [Hy Hp]].
    apply ReplAx in Hy as [n [Hn Hap]]. subst y.
    exists n. split...
  }
  assert (Hf: f: A ⇔ B). {
    split; split.
    - (* is_function f *)
      split. intros p Hp.
      apply HG in Hp as [n [Hn Hp]]. apply (Hstar n Hn)...
      intros x Hx. split. apply domE in Hx...
      intros y1 y2 H1 H2.
      apply HG in H1 as [n [Hn H1]].
      apply HG in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 _]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 _]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y1 y2.
      destruct (classic (m = n))...
      apply nat_connected in H as []...
      symmetry. apply Hin1... apply Hin2...
    - (* single_rooted f *)
      intros y Hy. split. apply ranE in Hy...
      intros y1 y2 H1 H2.
      apply HG in H1 as [n [Hn H1]].
      apply HG in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 Hout1]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 Hout2]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y.
      destruct (classic (m = n)). eapply injectiveE...
      apply nat_connected in H as []...
      + destruct (classic (y1 ∈ a⟦m⟧)).
        * rewrite <- Hin1 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout1 m H y1).
          apply SepI... rewrite <- H2. eapply ranI.
          apply func_correct... apply Hi2.
      + destruct (classic (y2 ∈ a⟦n⟧)).
        * rewrite <- Hin2 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout2 n H y2).
          apply SepI... rewrite H2. eapply ranI.
          apply func_correct... apply Hi1.
    - (* dom f = A *)
      apply ExtAx. split; intros Hx.
      + apply domE in Hx as [y Hp].
        apply HG in Hp as [n [Hn Hp]]. apply domI in Hp.
        pose proof (Hstar n Hn) as [[_ [Hd _]] _].
        rewrite Hd in Hp. apply imgE in Hp as [k [Hk Hak]].
        apply func_ap in Hak... subst x.
        eapply ap_ran... eapply ω_trans...
      + set (a⁻¹[x]) as n.
        assert (Hnp: n⁺ ∈ ω). {
          apply ω_inductive. eapply ap_ran...
          apply bijection_is_func. apply inv_bijection...
        }
        pose proof (Hstar n⁺ Hnp) as [[[Hf _] [Hd _]] _].
        apply (domI _ _ G[n⁺][x]).
        apply UnionAx. exists (G[n⁺]). split. eapply ReplI...
        apply func_correct... rewrite Hd.
        apply (imgI _ _ n)... rewrite inv_op.
        apply func_correct. apply inv_func_iff_sr.
        apply Hia. rewrite inv_dom...
    - (* ran f ⊆ B *)
      intros y Hy. apply ranE in Hy as [x Hp].
      apply HG in Hp as [n [Hn Hp]]. apply domI in Hp as Hx.
      pose proof (Hstar n Hn) as [[[Hf _] [Hd Hr]] _].
      apply func_ap in Hp... subst y.
      eapply ap_ran... split...
  }
  assert (Hap: ∀x ∈ A, ∃n ∈ ω, <x, f[x]> ∈ G[n]). {
    intros x Hx. destruct Hf as [[Hf _] [Hd _]].
    apply HG... apply func_correct...
  }
  exists f. split...
  intros x Hx y Hy.
  apply Hap in Hx as [n [Hn H1]]. apply domI in H1 as Hx.
  apply Hap in Hy as [m [Hm H2]]. apply domI in H2 as Hy.
  pose proof (Hstar n Hn) as [[[Hf1 _] [Hd1 _]] [Hop1 [Hin1 Hout1]]].
  pose proof (Hstar m Hm) as [[[Hf2 _] [Hd2 _]] [Hop2 [Hin2 _]]].
  apply func_ap in H1... rewrite <- H1.
  apply func_ap in H2... rewrite <- H2.
  destruct (classic (n = m)). {
    subst m. split; intros Hlt.
    - apply Hop1 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[n]);
      (split; [eapply ReplI|apply func_correct])...
    - apply Hop1... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
  }
  apply nat_connected in H as []...
  - assert (Hxm: x ∈ a⟦m⟧). {
      rewrite Hd1 in Hx. apply imgE in Hx as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite Hin2... split; intros Hlt.
    + apply Hop2 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[m]);
      (split; [eapply ReplI|apply func_correct])...
    + apply Hop2... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
  - assert (Hyn: y ∈ a⟦n⟧). {
      rewrite Hd2 in Hy. apply imgE in Hy as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite (Hin1 m H)... split; intros Hlt.
    + apply Hop1 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[n]);
      (split; [eapply ReplI|apply func_correct])...
    + apply Hop1... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
Qed.

(* 可数无穷线序集与可数无穷稠密线序集的子集同构 *)
Lemma infinite_loset_iso_subset_of_dense_infinite_loset :
  ∀ S, ω ≈ A S → ∀ T, ω ≈ A T → dense (R T) →
  ∃ T', T' ⊑ T ∧ S ≅ T'.
Proof with eauto.
  intros S [a Hba] T HqnT Hdn.
  assert (Hf: ∃ f, f: A S ⇔ A T ∧ ∀ x y ∈ A S,
    (x <ᵣ y) (R S) ↔ (f[x] <ᵣ f[y]) (R T ⥏ ran f)). {
    eapply sup_finite_isomorphisms...
  }
  destruct Hf as [f [Hf Hop]].
  assert (H := Hf). destruct H as [Hif [Hd Hr]].
  set (ran f) as B.
  assert (Hlo: loset B (R T ⥏ B)). {
    apply (subRel_loset (A T))...
  }
  set (constr B (R T ⥏ B) Hlo) as T'.
  exists T'. repeat split... exists f. split... split...
Qed.

(* 可数无穷线序集与无穷稠密线序集的子集同构 *)
Theorem countable_loset_iso_subset_of_dense_loset :
  ∀ S T, countable (A S) → ω ≈ (A T) → dense (R T) →
  ∃ T', T' ⊑ T ∧ S ≅ T'.
Proof with auto.
  intros S T Hcnt Hqn Hdn.
  apply countable_iff in Hcnt as [Hfin|Hinf].
  - apply finite_loset_iso_subset_of_dense_infinite_loset...
  - apply infinite_loset_iso_subset_of_dense_infinite_loset... symmetry... 
Qed.

(* ex8_17 可数无穷线序集与有理数集的子集同构 *)
(* The assumption in the textbook about being dense seems to be redundant *)
Corollary countable_loset_iso_subset_of_rat :
  ∀ S, countable (A S) →
  ∃ T, A T ⊆ ℚ ∧ R T = RatLt ⥏ A T ∧ S ≅ T.
Proof with auto.
  intros S Hcnt.
  set (constr ℚ RatLt ratLt_linearOrder) as Q.
  pose proof (countable_loset_iso_subset_of_dense_loset S Q)
    as [Q' [[Hsub Hrel] Hiso]]...
  - apply CardAx1. symmetry. apply card_rat_eq_aleph0.
  - apply ratLt_dense.
  - exists Q'. repeat split...
Qed.

End EX8_17.
