(** Coq coding by choukh, Mar 2021 **)

Require Import ZFC.EST8_4.
Require Import ZFC.EX7_1.
Require Import ZFC.lib.NatIsomorphism.
Require Import ZFC.lib.FuncFacts.
Require Import ZFC.lib.Real.
Require Import ZFC.lib.LoStruct.
Require Import ZFC.lib.WosetMin.
Require Import ZFC.lib.IndexedFamilyUnion.

(** EX8_17 **)

(* 无界序 *)
Definition left_unbounded  := λ A R, ∀x ∈ A, ∃w ∈ A, (w <ᵣ x) R.
Definition right_unbounded := λ A R, ∀x ∈ A, ∃y ∈ A, (x <ᵣ y) R.
Definition unbounded := λ A R, left_unbounded A R ∧ right_unbounded A R.

(* 有理数的序是无界序 *)
Fact ratLt_unbounded : unbounded ℚ RatLt.
Proof with auto.
  split; intros x Hx.
  - pose proof (rat_archimedean (-x)%q) as [w [Hw Hxw]].
    apply ratAddInv_ran...
    exists (-w)%q. split. apply ratAddInv_ran...
    apply ratLt_addInv... apply ratAddInv_ran...
    rewrite ratAddInv_double...
  - pose proof (rat_archimedean x Hx) as [y [Hy Hxy]].
    exists y. split...
Qed.

(* 稠密序 *)
Definition dense := λ R, ∀ x z, (x <ᵣ z) R → ∃ y, (x <ᵣ y) R ∧ (y <ᵣ z) R.

(* 有理数的序是稠密序 *)
Fact ratLt_dense : dense RatLt.
Proof with auto.
  intros x z Hxz.
  apply binRelE2 in Hxz as H. destruct H as [Hx [Hz _]].
  apply rat_dense in Hxz as [y [Hy [Hxy Hyz]]]...
  exists y. split...
Qed.

(* 有限线序与某个自然数同构 *)
Lemma finite_loset_iso_nat : ∀ S, finite (A S) →
  ∃ T, T ⊑ 𝛚 ∧ A T ∈ ω ∧ S ≅ T.
Proof with eauto.
  intros S Hfin.
  assert (H := Hfin). destruct Hfin as [n [Hn Hqn]].
  assert (HloT: loset n (Lt ⥏ n)). {
    eapply subRel_loset. apply Lt_wellOrder.
    apply trans_sub... apply ω_trans.
  }
  assert (HwoS: woset (A S) (R S)). apply finite_loset_is_woset...
  set (WoStruct.constr (A S) (R S) HwoS) as Sʷ.
  set (LoStruct.constr n (Lt ⥏ n) HloT) as T.
  Import WoStruct.
  Import WoStruct.EpsilonImageOfNats.
  set (Seg n 𝛚) as Tʷ.
  assert (Hiso: Sʷ ≅ Tʷ). {
    apply ord_well_defined.
    rewrite finite_ord_eq_card... simpl.
    apply CardAx1 in Hqn.
    rewrite Hqn, <- (card_of_nat n)...
    symmetry. apply α_nat...
  }
  destruct Hiso as [f [Hf Hop]]. unfold Tʷ in Hf.
  rewrite seg_a_eq, seg_of_nat in Hf...
  assert (Hsub: n ⊆ ω). apply trans_sub... apply ω_trans.
  assert (Hlo: loset n (Lt ⥏ n)). {
    eapply subRel_loset... apply Lt_wellOrder.
  }
  exists T. repeat split... exists f. split...
  apply bijection_is_func in Hf as [Hf _].
  intros x Hx y Hy. split; intros Hlt.
  - apply Hop in Hlt... apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran...
  - apply Hop... apply SepE1 in Hlt. apply seg_lt... apply SepI.
    + apply CProdI... apply (ω_trans _ n)... eapply ap_ran...
    + zfc_simple. eapply ap_ran...
Qed.

Import LoStruct.
Import SimpleVer.

(* 可数无穷稠密线序集有可数无穷稠密无界子集 *)
Lemma countable_dense_loset_has_unbounded_subset :
  ∀ S, ω ≈ A S → dense (R S) → ∃ T, T ⊑ S ∧
    ω ≈ A T ∧ dense (R T) ∧ unbounded (A T) (R T).
Proof with neauto; try congruence.
  intros S [a Hba] Hdn.
  destruct (lo S) as [Hbr [Htr _]].
  assert (Hir: irrefl (R S)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  cut ((∃ x y ∈ A S, (x <ᵣ y) (R S)) → ∃ T, T ⊑ S ∧
    ω ≈ A T ∧ dense (R T) ∧ unbounded (A T) (R T)). {
    destruct (classic (a[0] = a[1])) as [|Hnq]. {
      exfalso. apply injectiveE in H...
      rewrite Hda... rewrite Hda...
    }
    assert (Ha0: a[0] ∈ A S). eapply ap_ran...
    assert (Ha1: a[1] ∈ A S). eapply ap_ran...
    intros H. apply (lo_connected (R S) (A S) (lo S)) in Hnq as []...
    - apply H. exists (a[0]). split... exists (a[1]). split...
    - apply H. exists (a[1]). split... exists (a[0]). split...
  }
  intros [c [HcA [d [HdA Hcd]]]].
  apply Hdn in Hcd as [e [Hcd Hed]].
  apply Hbr in Hed as HeA. apply CProdE2 in HeA as [HeA _].
  set {x ∊ A S | λ x, (c <ᵣ x) (R S) ∧ (x <ᵣ d) (R S)} as C.
  set (λ x, {n ∊ ω | λ n, (c <ᵣ a[n]) (R S) ∧ (a[n] <ᵣ x) (R S)}) as Nₗ.
  set (λ x, {n ∊ ω | λ n, (x <ᵣ a[n]) (R S) ∧ (a[n] <ᵣ d) (R S)}) as Nᵣ.
  set (λ x, (Min Lt)[Nₗ x]) as mₗ.
  set (λ x, (Min Lt)[Nᵣ x]) as mᵣ.
  set (Func C C (λ x, a[mₗ x])) as fₗ.
  set (Func C C (λ x, a[mᵣ x])) as fᵣ.
  assert (HeC: e ∈ C). apply SepI...
  assert (Hmₗ: ∀x ∈ C, mₗ x ∈ ω ∧ (c <ᵣ a[mₗ x]) (R S) ∧ (a[mₗ x] <ᵣ x) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (ω_min (Nₗ x)) as [H _]. {
      apply Hdn in Hcx as [y [Hcy Hyx]].
      apply Hbr in Hyx as Hy. apply CProdE2 in Hy as [Hy _].
      exists (a⁻¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mₗ x) in H. apply SepE in H as [Hm [Hcm Hmx]]. split...
  }
  assert (Hmᵣ: ∀x ∈ C, mᵣ x ∈ ω ∧ (x <ᵣ a[mᵣ x]) (R S) ∧ (a[mᵣ x] <ᵣ d) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (ω_min (Nᵣ x)) as [H _]. {
      apply Hdn in Hxd as [y [Hxy Hyd]].
      apply Hbr in Hyd as Hy. apply CProdE2 in Hy as [Hy _].
      exists (a⁻¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mᵣ x) in H. apply SepE in H as [Hm [Hxm Hmd]]. split...
  }
  assert (Hfₗ: fₗ: C ⇒ C). {
    apply meta_function. intros x Hx.
    apply Hmₗ in Hx as H. destruct H as [Hm [Hcm Hmx]].
    apply SepE2 in Hx as [_ Hxd].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  assert (Hfᵣ: fᵣ: C ⇒ C). {
    apply meta_function. intros x Hx.
    apply Hmᵣ in Hx as H. destruct H as [Hm [Hxm Hmd]].
    apply SepE2 in Hx as [Hcx _].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  pose proof (ω_recursion fₗ C e Hfₗ HeC) as [hₗ [Hhₗ [Hhₗ0 Hhₗn]]].
  pose proof (ω_recursion fᵣ C e Hfᵣ HeC) as [hᵣ [Hhᵣ [Hhᵣ0 Hhᵣn]]].
  set {x ∊ A S | λ x, ∃n ∈ ω, (hₗ[n] ≤ᵣ x) (R S) ∧ (x ≤ᵣ hᵣ[n]) (R S)} as B.
  assert (HBA: B ⊆ A S). apply SepE1.
  assert (HCA: C ⊆ A S). apply SepE1.
  assert (Hdesc: ∀x ∈ C, (fₗ[x] <ᵣ x) (R S)). {
    intros x Hx. unfold fₗ. rewrite meta_func_ap... apply Hmₗ...
  }
  assert (Hasc: ∀x ∈ C, (x <ᵣ fᵣ[x]) (R S)). {
    intros x Hx. unfold fᵣ. rewrite meta_func_ap... apply Hmᵣ...
  }
  assert (Hmonoₗ: ∀ n m ∈ ω, n ∈ m → (hₗ[m] <ᵣ hₗ[n]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (hₗ[k] <ᵣ hₗ[n]) (R S)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhₗn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hdesc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hdesc... eapply ap_ran...
  }
  assert (Hmonoᵣ: ∀ n m ∈ ω, n ∈ m → (hᵣ[n] <ᵣ hᵣ[m]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (hᵣ[n] <ᵣ hᵣ[k]) (R S)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhᵣn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hasc... eapply ap_ran...
  }
  assert (Hihₗ: hₗ : ω ⇔ B). {
    destruct Hhₗ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoₗ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: x⁺ ∈ ω). apply ω_inductive...
      exists x. split... split; [right|]...
      ω_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
      + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
  }
  assert (Hihᵣ: hᵣ : ω ⇔ B). {
    destruct Hhᵣ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoᵣ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: x⁺ ∈ ω). apply ω_inductive...
      exists x. split... split; [|right]...
      ω_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
      + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
  }
  assert (Hlo: loset B (R S ⥏ B)). eapply subRel_loset...
  set (constr B (R S ⥏ B) Hlo) as T.
  exists T. split... split... split; [|split].
  - (* ω ≈ A T *)
    apply Schröeder_Bernstein.
    + exists hₗ...
    + assert (A S ≈ ω). symmetry. exists a...
      apply dominate_sub in HBA.
      eapply dominate_rewrite_r...
  - (* dense (R T) *)
    intros x y Hxy. apply SepE in Hxy as [Hxy H].
    apply CProdE2 in H as [Hx Hy].
    apply Hdn in Hxy as [z [Hxz Hzy]].
    cut (z ∈ B). {
      intros Hz. exists z; split;
      apply SepI; auto; apply CProdI...
    }
    apply Hbr in Hzy as H.
    apply CProdE2 in H as [Hz _]. apply SepI...
    apply SepE2 in Hx as [n [Hn [Hnx Hxn]]].
    apply SepE2 in Hy as [m [Hm [Hmy Hym]]].
    destruct (classic (n = m)). {
      subst m. exists n. split... split; left.
      eapply relLe_lt_tranr; revgoals...
      eapply relLt_le_tranr...
    }
    apply nat_connected in H as [Hnm|Hmn]...
    + apply Hmonoₗ in Hnm...
      exists m. split... split; left.
      * eapply relLe_lt_tranr; revgoals... left.
        eapply relLt_le_tranr...
      * eapply relLt_le_tranr...
    + apply Hmonoᵣ in Hmn...
      exists n. split... split; left.
      * eapply relLe_lt_tranr...
      * eapply relLe_lt_tranr... left.
        eapply relLt_le_tranr...
  - (* unbounded (A T) (R T)) *)
    destruct (lo T) as [_ [Htr' _]].
    split; intros x Hx. {
      assert (H := Hx). apply SepE2 in H as [n [Hn [Hnx Hxn]]].
      destruct Hihₗ as [[Hf _] [Hd Hr]].
      assert (Hnp: n⁺ ∈ ω). apply ω_inductive...
      exists (hₗ[n⁺]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists n⁺. split... split; [right|left]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
        + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
      - apply (relLt_le_tranr _ (hₗ[n]))...
        + apply SepI. apply Hmonoₗ...
          apply CProdI; eapply ap_ran; eauto; split...
        + destruct Hnx; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
    } {
      assert (H := Hx). apply SepE2 in H as [n [Hn [Hnx Hxn]]].
      destruct Hihᵣ as [[Hf _] [Hd Hr]].
      assert (Hnp: n⁺ ∈ ω). apply ω_inductive...
      exists (hᵣ[n⁺]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists n⁺. split... split; [left|right]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhₗ0. apply Hmonoₗ... apply suc_has_0...
        + rewrite <- Hhᵣ0. apply Hmonoᵣ... apply suc_has_0...
      - apply (relLe_lt_tranr _ (hᵣ[n]))...
        + destruct Hxn; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
        + apply SepI. apply Hmonoᵣ...
          apply CProdI; eapply ap_ran; eauto; split...
    }
Qed.

(* 可数无穷稠密线序集有可数无穷良序子集 *)
Lemma countable_dense_loset_has_wo_subset :
  ∀ S, ω ≈ A S → dense (R S) → ∃ T, T ⊑ S ∧ 𝛚 ≅ T.
Proof with neauto; try congruence.
  intros S Hqn Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset
    S Hqn Hdn) as [T [[Hsub Hrel] [[a Hba] [_ [Hul Hur]]]]].
  destruct (lo T) as [_ [Htr _]].
  assert (Hir: irrefl (R T)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (λ x, {n ∊ ω | λ n, (x <ᵣ a[n]) (R S)}) as M.
  set (λ x, (Min Lt)[M x]) as m.
  set (Func (A T) (A T) (λ x, a[m x])) as f.
  assert (Hmx: ∀x ∈ A T, m x ∈ ω ∧ (x <ᵣ a[m x]) (R S)). {
    intros x Hx.
    cut (m x ∈ M x). intros H. apply SepE in H...
    apply ω_min; [|apply SepE1].
    apply Hur in Hx as [y [Hy Hxy]].
    rewrite Hrel in Hxy. apply SepE1 in Hxy.
    exists (a⁻¹[y]). apply SepI. apply (ap_ran (A T))...
    apply bijection_is_func. apply inv_bijection...
    rewrite inv_ran_reduction...
  }
  assert (Hf: f: A T ⇒ A T). {
    apply meta_function. intros x Hx.
    eapply ap_ran... apply Hmx...
  }
  assert (Ha0: a[0] ∈ A T). eapply ap_ran...
  pose proof (ω_recursion f (A T) (a[0]) Hf Ha0) as [h [Hh [Hh0 Hhn]]].
  assert (Hasc: ∀x ∈ A T, (x <ᵣ f[x]) (R T)). {
    intros x Hx. unfold f. rewrite meta_func_ap, Hrel...
    apply SepI. apply Hmx... apply CProdI...
    eapply ap_ran... apply Hmx...
  }
  assert (Hmono: ∀ n m ∈ ω, n ∈ m → (h[n] <ᵣ h[m]) (R T)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k ∊ ω | λ k, ∀ n, n ∈ ω → n ∈ k → (h[n] <ᵣ h[k]) (R T)} as N.
    ω_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m0.
      apply Hasc... eapply ap_ran...
  }
  assert (Hop: ∀ n m ∈ ω, (h[n] <ᵣ h[m]) (R T) → n ∈ m). {
    intros n Hn k Hk Hnk.
    destruct (classic (n = k)).
    - subst k. exfalso. eapply relLt_irrefl...
    - apply nat_connected in H as []...
      apply Hmono in H... exfalso.
      eapply relLt_irrefl... eapply relLt_tranr...
  }
  assert (Hbh: h: ω ⟺ ran h). {
    destruct Hh as [Hfh [Hd Hr]].
    split; split...
    intros y Hy. split. apply ranE in Hy...
    intros x1 x2 H1 H2.
    apply domI in H1 as Hx1. rewrite Hd in Hx1.
    apply domI in H2 as Hx2. rewrite Hd in Hx2.
    apply func_ap in H1...
    apply func_ap in H2...
    destruct (classic (x1 = x2))... exfalso.
    apply nat_connected in H as []; auto;
    apply Hmono in H; auto; rewrite H1, H2 in H; eapply Hir...
  }
  assert (Hsub': ran h ⊆ A S). {
    destruct Hh as [_ [_ Hr]]. eapply sub_tran...
  }
  assert (Hlo: loset (ran h) (R S ⥏ ran h)). {
    eapply subRel_loset...
  }
  set (constr (ran h) (R S ⥏ ran h) Hlo) as U.
  exists U. split. split... exists h. split... simpl.
  intros x Hx y Hy. split; intros Hlt.
  - apply binRelE3 in Hlt.
    apply Hmono in Hlt... rewrite Hrel in Hlt.
    apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran; eauto; apply bijection_is_func...
  - apply SepE1 in Hlt. apply SepI. apply CProdI...
    zfc_simple. apply Hop... rewrite Hrel. apply SepI...
    apply CProdI; eapply ap_ran...
Qed.

(* 有限线序集可嵌入可数无穷稠密线序集 *)
Lemma finite_loset_embeddable_in_dense_infinite_loset :
  ∀ S, finite (A S) → ∀ T, ω ≈ A T → dense (R T) →
  ∃ U, U ⊑ T ∧ S ≅ U.
Proof with eauto; try congruence.
  intros S Hfin T Hqn Hdn.
  pose proof (finite_loset_iso_nat S Hfin)
    as [S' [[HsubS HrS] [Hn [f [Hf Hopf]]]]].
  pose proof (countable_dense_loset_has_wo_subset T Hqn Hdn)
    as [T' [[HsubT HrT] [g [Hg Hopg]]]].
  simpl in *.
  set (A S') as n.
  set ((g ↾ n) ∘ f) as h.
  assert (Hg': g ↾ n: n ⟺ g⟦n⟧). eapply restr_bijection...
  assert (Hh: h: A S ⟺ g⟦n⟧). eapply compo_bijection...
  assert (Hsub: g⟦n⟧ ⊆ A T). {
    eapply sub_tran; revgoals...
    destruct Hg as [_ [_ Hr]]. rewrite <- Hr.
    apply img_included.
  }
  assert (Hlo: loset (g⟦n⟧) (R T ⥏ g⟦n⟧)). eapply subRel_loset...
  set (constr (g⟦n⟧) (R T ⥏ g⟦n⟧) Hlo) as U.
  exists U. repeat split... exists h. split...
  destruct Hf as [[Hff _] [Hdf Hdr]].
  destruct Hg as [[Hfg _] [Hdg Hrg]].
  destruct Hg' as [[Hfg' _] _].
  assert (Hfx: ∀x ∈ A S, f[x] ∈ n). {
    intros x Hx. unfold n. rewrite <- Hdr.
    eapply ranI. apply func_correct...
  }
  assert (Hd: ∀x ∈ A S, x ∈ dom ((g ↾ n) ∘ f)). {
    intros x Hx. rewrite compo_dom... apply SepI...
    assert (dom (g ↾ n) = n). apply restr_dom... rewrite Hdg...
    rewrite H. apply Hfx...
  }
  intros x Hx y Hy.
  apply Hfx in Hx as Hfx0. apply Hfx in Hy as Hfy.
  apply Hd in Hx as Hdx. apply Hd in Hy as Hdy.
  assert (Hfxω: f[x] ∈ ω). eapply ω_trans...
  assert (Hfyω: f[y] ∈ ω). eapply ω_trans...
  unfold h. rewrite compo_correct, compo_correct...
  rewrite restr_ap, restr_ap...
  split; intros Hlt.
  - apply Hopf in Hlt...
    rewrite HrS in Hlt. apply SepE1 in Hlt.
    apply Hopg in Hlt; [|apply HsubS; apply Hfx..]...
    rewrite HrT in Hlt. apply SepE1 in Hlt.
    apply SepI... apply CProdI.
    + apply (imgI _ _ (f[x]))... apply func_correct...
    + apply (imgI _ _ (f[y]))... apply func_correct...
  - apply Hopf... rewrite HrS. apply SepI; [|apply CProdI..]...
    apply Hopg... rewrite HrT. apply SepI... apply SepE1 in Hlt...
    apply CProdI; rewrite <- Hrg; eapply ranI; apply func_correct...
Qed.

Import FullVer.

(* 有限线序的最值 *)
Definition FinLoMax := λ R B, (Min B (R ⥏ B)⁻¹) [B].
Definition FinLoMin := λ R B, (Min B (R ⥏ B)) [B].

Lemma finite_loset_has_max : ∀ A R B, loset A R →
  B ≠ ∅ → B ⊆ A → finite B → maximum (FinLoMax R B) B (R ⥏ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin. apply maximum_iff_minimum_inv.
  apply min_correct... apply finite_loset_is_woset...
  apply inv_lo... eapply subRel_loset... apply EmptyNE...
Qed.

Lemma finite_loset_has_min : ∀ A R B, loset A R →
  B ≠ ∅ → B ⊆ A → finite B → minimum (FinLoMin R B) B (R ⥏ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin.
  apply min_correct... apply finite_loset_is_woset...
  eapply subRel_loset... apply EmptyNE...
Qed.

Lemma card_of_img_of_enumeration :
  ∀ A f, f: ω ⟺ A → ∀n ∈ ω, |f⟦n⟧| = n.
Proof with eauto.
  intros A f Hbi n Hn. rewrite (card_of_nat n) at 2...
  apply CardAx1. symmetry. exists (f ↾ n).
  eapply restr_bijection; revgoals...
  apply trans_sub... apply ω_trans.
Qed.

Lemma img_0 : ∀ f, f⟦∅⟧ = ∅.
Proof.
  intros f. apply ExtAx. split; intros Hx; [|exfalso0].
  apply imgE in Hx as [w [Hw _]]. exfalso0.
Qed.

Lemma img_suc : ∀ f, is_function f → dom f = ω →
  ∀n ∈ ω, f⟦n⁺⟧ = f⟦n⟧ ∪ ⎨f[n]⎬.
Proof with auto.
  intros f Hf Hd n Hn. replace ⎨f[n]⎬ with (f⟦⎨n⎬⟧).
  apply img_bunion_distr.
  apply ExtAx. split; intros Hx.
  - apply imgE in Hx as [w [Hw Hp]]. apply SingE in Hw; subst.
    apply func_ap in Hp... subst x...
  - apply SingE in Hx; subst. apply (imgI _ _ n)...
    apply func_correct... congruence.
Qed.

Import SimpleVer.

(* 对任意可数无穷线序集A和B，如果B无界稠密，
  那么存在以ω为定义域的函数F作为从A到B的部分嵌入的枚举 *)
(* For any countably infinite loset A and B, if B is unbounded and dense,
  then there exists a function F with domain ω as the enumeration of
  all partial embeddings from A to B *)
Lemma enumeration_of_partial_embeddings :
  ∀ A R a, a: ω ⟺ A → loset A R →
  ∀ B S, ω ≈ B → loset B S → unbounded B S → dense S →
  ∃ G, is_function G ∧ dom G = ω ∧ ∀n ∈ ω, G[n]: a⟦n⟧ ⇔ B ∧
    (∀ x y ∈ a⟦n⟧, (x <ᵣ y) R ↔ (G[n][x] <ᵣ G[n][y]) S) ∧
    (∀m ∈ n, ∀x ∈ a⟦m⟧, G[m][x] = G[n][x]) ∧
    (∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, G[n][x] ∉ ran G[m]).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S [b Hbb] HloS [Hul Hur] HdnS.
  assert (H := HloR). destruct H as [_ [HtrR _]].
  assert (HirR: irrefl R). eapply lo_irrefl...
  assert (H := HloS).  destruct H as [Hbr [HtrS _]].
  assert (HirS: irrefl S). eapply lo_irrefl...
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hbb). apply bijection_is_func in H as [Hmb [Hib Hrb]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (λ f, ∀ x y ∈ dom f, (x <ᵣ y) R ↔ (f[x] <ᵣ f[y]) S) as op.
  set (⋃{λ X, X ⟶ B | X ∊ 𝒫 A}) as fs0.
  set {f ∊ fs0 | λ f, (∃n ∈ ω, f: a⟦n⟧ ⇔ B) ∧ op f} as fs.
  set (λ f, {y ∊ dom f | λ y, (y <ᵣ a[|dom f|]) R}) as 𝐋.
  set (λ f, {y ∊ dom f | λ y, (a[|dom f|] <ᵣ y) R}) as 𝐑.
  set (λ f, FinLoMax R (𝐋 f)) as aₗ.
  set (λ f, FinLoMin R (𝐑 f)) as aᵣ.
  set (λ f, {k ∊ ω | λ k, (b[k] <ᵣ f[aᵣ f]) S}) as Nᵣ.
  set (λ f, {k ∊ ω | λ k, (f[aₗ f] <ᵣ b[k]) S}) as Nₗ.
  set (λ f, {k ∊ ω | λ k, (f[aₗ f] <ᵣ b[k]) S ∧ (b[k] <ᵣ f[aᵣ f]) S}) as Nₘ.
  set (λ f,
    match (ixm (𝐋 f = ∅)) with
    | inl _ => match (ixm (𝐑 f = ∅)) with
      | inl _ => b[0]
      | inr _ => b[(Min Lt)[Nᵣ f]]
      end
    | inr _ => match (ixm (𝐑 f = ∅)) with
      | inl _ => b[(Min Lt)[Nₗ f]]
      | inr _ => b[(Min Lt)[Nₘ f]]
      end
    end
  ) as Pairing.
  set (λ f, f ∪ ⎨<a[|dom f|], Pairing f>⎬) as Add.
  set (Func fs fs Add) as g.
  pose proof (card_of_img_of_enumeration A a Hba) as Hcdn.
  assert (Haₗ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → 𝐋 f ≠ ∅ →
    aₗ f ∈ dom f ∧ (aₗ f <ᵣ a[n]) R ∧
    ∀l ∈ n, (a[l] <ᵣ a[n]) R → (a[l] ≤ᵣ aₗ f) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_max A R (𝐋 f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [Haₗd Hlt]. 
      rewrite Hd, Hcdn in Hlt... repeat split...
      intros m Hm Hamk. assert (a[m] ∈ 𝐋 f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (Haᵣ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → 𝐑 f ≠ ∅ →
    aᵣ f ∈ dom f ∧ (a[n] <ᵣ aᵣ f) R ∧
    ∀l ∈ n, (a[n] <ᵣ a[l]) R → (aᵣ f ≤ᵣ a[l]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_min A R (𝐑 f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [Haᵣd Hlt].
      rewrite Hd, Hcdn in Hlt... repeat split...
      intros m Hm Hamk. assert (a[m] ∈ 𝐑 f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (HNₗ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → 𝐋 f ≠ ∅ →
    (Min Lt)[Nₗ f] ∈ Nₗ f). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (ω_min (Nₗ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aₗ f] ∈ B). {
        apply Hr. eapply ranI. apply func_correct... eapply Haₗ...
      }
      pose proof (Hur (f[aₗ f]) H) as [w [Hw Hlt]].
      exists (b⁻¹[w]). apply SepI.
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNᵣ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → 𝐑 f ≠ ∅ →
    (Min Lt)[Nᵣ f] ∈ Nᵣ f). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (ω_min (Nᵣ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aᵣ f] ∈ B). {
        apply Hr. eapply ranI. apply func_correct... eapply Haᵣ...
      }
      pose proof (Hul (f[aᵣ f]) H) as [w [Hw Hlt]].
      exists (b⁻¹[w]). apply SepI.
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNₘ: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → op f → 𝐋 f ≠ ∅ → 𝐑 f ≠ ∅ →
    (Min Lt)[Nₘ f] ∈ Nₘ f). {
    intros n Hn f Hmf Hop HneL HneR.
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    apply (ω_min (Nₘ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - pose proof (HdnS (f[aₗ f]) (f[aᵣ f])) as [qₘ [H1 H2]]. {
        pose proof Haₗ as [Haₗd [Hlt1 _]]...
        pose proof Haᵣ as [Haᵣd [Hlt2 _]]...
        eapply Hop... eapply relLt_tranr...
      }
      assert (Hqₘ: qₘ ∈ B). {
        apply Hbr in H1. apply CProdE2 in H1 as [_ H]...
      }
      exists (b⁻¹[qₘ]). apply SepI...
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Hpair: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → op f → Pairing f ∈ B). {
    intros n Hn f Hmf Hop. unfold Pairing.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    destruct (ixm (𝐋 f = ∅)) as [HL|HL];
    destruct (ixm (𝐑 f = ∅)) as [HR|HR]; eapply ap_ran...
    - eapply SepE1 in HNᵣ...
    - eapply SepE1 in HNₗ...
    - eapply SepE1 in HNₘ...
  }
  assert (Hout1: ∀n ∈ ω, a[n] ∉ a⟦n⟧). {
    intros n Hn H.
    apply imgE in H as [k [Hk Hp]].
    apply func_ap in Hp... apply injectiveE in Hp...
    eapply nat_not_lt_self... rewrite Hda. eapply ω_trans...
  }
  assert (H00: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇒ B → 𝐋 f = ∅ → 𝐑 f = ∅ → n = ∅). {
    intros n Hn f [Hf [Hd _]] HL0 HR0.
    destruct (classic (n = ∅))...
    exfalso. apply pred_exists in H as [k [Hk Heq]]... subst n.
    destruct (classic (a[k] = a[k⁺])). {
      apply injectiveE in H... assert (k ∈ k⁺)...
      rewrite <- H in H0 at 1. eapply nat_irrefl...
    }
    apply (lo_connected R A) in H as []; revgoals.
    eapply ap_ran... eapply ap_ran... apply HloR.
    - eapply EmptyNI in HR0... exists (a[k]).
      apply SepI; rewrite Hd; [|rewrite Hcdn]...
      eapply imgI... apply func_correct...
    - eapply EmptyNI in HL0... exists (a[k]).
      apply SepI; rewrite Hd; [|rewrite Hcdn]...
      eapply imgI... apply func_correct...
  }
  assert (Hout2: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ B → op f → Pairing f ∉ ran f). {
    intros n Hn f Hif Hop Hin.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: a⟦n⟧ ⟺ ran f). split...
    apply ranE in Hin as [x Hfx]. apply domI in Hfx as Hx.
    rewrite Hdf in Hx. apply imgE in Hx as [k [Hk Hak]].
    apply func_ap in Hak... apply func_ap in Hfx...
    subst x. unfold Pairing in Hfx.
    assert (Hkω: k ∈ ω). eapply ω_trans...
    destruct (classic (a[k] = a[n])) as [|Hnq]. {
      apply injectiveE in H... eapply nat_not_lt_self...
    }
    assert (Hak: a[k] ∈ a⟦n⟧). {
      apply (imgI _ _ k)... apply func_correct...
    }
    destruct (ixm (𝐋 f = ∅)) as [HL|HL];
    destruct (ixm (𝐑 f = ∅)) as [HR|HR].
    + assert (n = ∅). eapply H00... subst n. exfalso0.
    + pose proof (HNᵣ n Hn f Hmf HR) as Hfkr.
      apply SepE2 in Hfkr. rewrite <- Hfx in Hfkr.
      pose proof Haᵣ as [Haᵣd [Hnr Hle]]; revgoals...
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
      * eapply EmptyNI in HL... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
    + pose proof (HNₗ n Hn f Hmf HL) as Hflk.
      apply SepE2 in Hflk. rewrite <- Hfx in Hflk.
      pose proof Haₗ as [Haₗd [Hln Hle]]; revgoals...
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * eapply EmptyNI in HR... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
    + pose proof (HNₘ n Hn f Hmf Hop HL HR) as Hflr.
      apply SepE2 in Hflr. rewrite <- Hfx in Hflr.
      pose proof Haₗ as [Haₗd [Hln Hleₗ]]; revgoals...
      pose proof Haᵣ as [Haᵣd [Hnr Hleᵣ]]; revgoals...
      destruct Hflr as [Hflk Hfkr].
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hleᵣ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
      * apply Hleₗ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
  }
  assert (Hind: ∀n ∈ ω, ∀ f, f: a⟦n⟧ ⇔ B → op f → Add f : a⟦n⁺⟧ ⇔ B ∧ op (Add f)). {
    intros n Hn f Hif Hop.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: a⟦n⟧ ⟺ ran f). split...
    cut (Add f: a⟦n⁺⟧ ⟺ ran f ∪ ⎨Pairing f⎬ ∧ op (Add f)). {
      intros [[HiFf [HdFf HrFf]] HopFf].
      split... split... split...
      intros x Hx. rewrite HrFf in Hx.
      apply BUnionE in Hx as []... apply Hrf...
      apply SingE in H. subst x. eapply Hpair...
    }
    assert (Hadd: Add f : a⟦n⁺⟧ ⟺ ran f ∪ ⎨Pairing f⎬). {
      unfold Add. rewrite Hdf, Hcdn, img_suc...
      apply bijection_add_point...
      apply Hout1... eapply Hout2...
    }
    split...
    destruct Hadd as [[Hf _] [Hd Hr]].
    pose proof (add_point_func_ap) as [H1 H2]...
    apply Hout1... eapply Hout2...
    intros u Hu v Hv.
    rewrite Hd, img_suc in Hu, Hv...
    apply BUnionE in Hu as [Hu|Hu];
    apply BUnionE in Hv as [Hv|Hv];
    unfold Add; rewrite Hdf, Hcdn; auto; [
      rewrite H1, H1|rewrite H1, H2|
      rewrite H2, H1|rewrite H2, H2
    ]...
    - apply Hop...
    - apply SingE in Hv; subst v. unfold Pairing.
      apply imgE in Hu as [k [Hk Hak]].
      apply func_ap in Hak... subst u. 
      assert (Hak: a[k] ∈ a⟦n⟧). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply ω_trans...
      }
      destruct (ixm (𝐋 f = ∅)) as [HL|HL];
      destruct (ixm (𝐑 f = ∅)) as [HR|HR];
      split; intros Hlt.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNᵣ n Hn f Hmf HR). apply SepE2 in H.
        pose proof Haᵣ as [Haᵣd [_ Hle]]...
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop...
        eapply relLt_tranr...
      + pose proof (HNₗ n Hn f Hmf HL). apply SepE2 in H.
        pose proof Haₗ as [Haₗd [_ Hle]]...
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNₘ n Hn f Hmf Hop HL HR).
        pose proof Haₗ as [Haₗd [_ Hle]]...
        apply SepE2 in H as [H _].
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + pose proof (HNₘ n Hn f Hmf Hop HL HR).
        pose proof Haᵣ as [Haᵣd [_ Hle]]...
        apply SepE2 in H as [_ H].
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop...
        eapply relLt_tranr...
    - apply SingE in Hu; subst u. unfold Pairing.
      apply imgE in Hv as [k [Hk Hak]].
      apply func_ap in Hak... subst v. 
      assert (Hak: a[k] ∈ a⟦n⟧). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply ω_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply ω_trans...
      }
      destruct (ixm (𝐋 f = ∅)) as [HL|HL];
      destruct (ixm (𝐑 f = ∅)) as [HR|HR];
      split; intros Hlt.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + assert (n = ∅). eapply H00... subst n. exfalso0.
      + pose proof (HNᵣ n Hn f Hmf HR). apply SepE2 in H.
        pose proof Haᵣ as [Haᵣd [_ Hle]]...
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNₗ n Hn f Hmf HL). apply SepE2 in H.
        pose proof Haₗ as [Haₗd [_ Hle]]...
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop...
        eapply relLt_tranr...
      + pose proof (HNₘ n Hn f Hmf Hop HL HR).
        pose proof Haᵣ as [Haᵣd [_ Hle]]...
        apply SepE2 in H as [_ H].
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + pose proof (HNₘ n Hn f Hmf Hop HL HR).
        pose proof Haₗ as [Haₗd [_ Hle]]...
        apply SepE2 in H as [H _].
        assert (Hkω: k ∈ ω). eapply ω_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop...
        eapply relLt_tranr...
    - apply SingE in Hu; apply SingE in Hv; subst.
      split; intros Hlt; exfalso; eapply relLt_irrefl; revgoals...
  }
  assert (Hg: g: fs ⇒ fs). {
    apply meta_function. intros f Hf.
    apply SepE2 in Hf as [[n [Hn Hf]] Hop]. apply SepI.
    - apply UnionAx. exists (a⟦n⁺⟧ ⟶ B). split.
      + apply ReplAx. exists (a⟦n⁺⟧). split...
        apply PowerAx. rewrite <- Hra. apply img_included.
      + apply arrowI. apply Hind in Hf as [Hf _]...
        apply injection_is_func...
    - split; [|eapply Hind]...
      exists n⁺. split. apply ω_inductive... apply Hind...
  }
  assert (Hi0: ∅: a⟦∅⟧ ⇔ B). {
    rewrite img_0. apply empty_injection.
  }
  assert (Hop0: op ∅). {
    intros x Hx. rewrite dom_of_empty in Hx. exfalso0.
  }
  pose proof (ω_recursion g fs ∅ Hg) as [G [HG [HG0 HGnp]]]. {
    apply SepI.
    - apply UnionAx. exists (∅ ⟶ B). split.
      + apply ReplAx. exists ∅. split... apply empty_in_all_power.
      + apply arrowI. apply injection_is_func. apply empty_injection.
    - split... exists ∅. split...
  }
  assert (HiGn: ∀n ∈ ω, G[n] : a⟦n⟧ ⇔ B ∧ op G[n]). {
    intros n Hn.
    destruct HG as [HfG [HdG HrG]].
    set {n ∊ ω | λ n, G[n] : a⟦n⟧ ⇔ B ∧ op G[n]} as N.
    ω_induction N Hn. rewrite HG0...
    rewrite HGnp... unfold g.
    rewrite meta_func_ap... apply Hind; auto; apply IH.
    apply HrG. eapply ranI. apply func_correct...
  }
  assert (Hin0: ∀n ∈ ω, ∀x ∈ a⟦n⟧, G[n][x] = G[n⁺][x]). {
    intros n Hn x Hx. rewrite HGnp... unfold g.
    rewrite meta_func_ap; [|auto|eapply ap_ran]...
    pose proof (HiGn n Hn) as [Hi Hop].
    assert (H := Hi). destruct H as [Hf [Hd Hr]].
    assert (G[n]: a⟦n⟧ ⟺ ran G[n]). split...
    symmetry. eapply add_point_func_ap...
    rewrite Hd, Hcdn... apply Hout1... eapply Hout2...
  }
  assert (Hout0: ∀n ∈ ω, G[n⁺][a[n]] ∉ ran G[n]). {
    intros n Hn Hr.
    pose proof (HiGn n Hn) as [HGn Hop].
    apply injection_is_func in HGn as [HGn Hin].
    assert (H := HGn). destruct H as [Hfn [Hdn Hrn]].
    apply ranE in Hr as [x Hp]. apply domI in Hp as Hx.
    apply func_ap in Hp... rewrite HGnp in Hp...
    unfold g in Hp. rewrite meta_func_ap in Hp; [|auto|eapply ap_ran]...
    unfold Add in Hp. rewrite Hdn, Hcdn in Hp...
    assert (∀x ∈ ⎨a[n]⎬, (G[n] ∪ ⎨<a[n], Pairing G[n]>⎬)[x] = Pairing G[n]). {
      assert (G[n]: a⟦n⟧ ⟺ ran G[n]). split...
      eapply add_point_func_ap...
      apply Hout1... eapply Hout2... split...
    }
    rewrite H in Hp... eapply Hout2... split...
    rewrite <- Hp. eapply ranI. apply func_correct...
  }
  assert (Hin: ∀n ∈ ω, ∀m ∈ n, ∀x ∈ a⟦m⟧, (G[m])[x] = (G[n])[x]). {
    intros n Hn.
    set {n ∊ ω | λ n, ∀k ∈ n, ∀x ∈ a⟦k⟧, G[k][x] = G[n][x]} as N.
    ω_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [].
    - rewrite IH... apply Hin0...
      apply imgE in Hx as [l [Hl Hp]].
      apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in H; subst k. apply Hin0...
  }
  assert (Hout: ∀n ∈ ω, ∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, (G[n])[x] ∉ ran G[m]). {
    intros n Hn.
    set {n ∊ ω | λ n, ∀m ∈ n, ∀x ∈ a⟦n⟧ - a⟦m⟧, G[n][x] ∉ ran G[m]} as N.
    ω_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [Hkm|Hkm].
    - assert (Hk: k ∈ ω). eapply ω_trans...
      pose proof (HiGn k Hk) as [[[Hfk _] [Hdk _]] _].
      pose proof (HiGn m Hm) as [[[Hfm _] [Hdm _]] _].
      apply SepE in Hx as [Hx Hx']. rewrite img_suc in Hx...
      apply BUnionE in Hx as [Hx|Hx].
      + assert (x ∈ a⟦m⟧ - a⟦k⟧). apply SepI...
        apply IH in H... intros H1. apply H.
        apply ranE in H1 as [w Hp]. apply domI in Hp as Hw.
        apply func_ap in Hp... rewrite Hin0...
        apply (ranI _ w). rewrite <- Hp. apply func_correct...
      + apply SingE in Hx; subst x. intros H. apply (Hout0 m)...
        apply ranE in H as [x Hp]. apply domI in Hp as Hx.
        apply func_ap in Hp... rewrite <- Hp.
        apply (ranI _ x). rewrite (Hin m)...
        apply func_correct... rewrite Hdk in Hx. rewrite Hdm.
        apply imgE in Hx as [l [Hl Ha]].
        apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in Hkm; subst k.
      rewrite img_comp_distr in Hx; [|apply Hia].
      rewrite suc_comp, img_single in Hx...
      apply SingE in Hx; subst. apply Hout0...
  }
  exists G. split; [|split]; [apply HG..|intros n Hn].
  pose proof (HiGn n Hn) as [[Hi [Hd Hr]] Hop].
  unfold op in Hop. rewrite Hd in Hop.
  split. split... split...
  split. apply Hin... apply Hout...
Qed.

(* 所有部分嵌入的并是完整嵌入 *)
Lemma union_of_partial_embeddings :
  ∀ A R, ω ≈ A → loset A R → 
  ∀ B S, ω ≈ B → loset B S → dense S → unbounded B S →
  ∃ f, f: A ⇔ B ∧ ∀ x y ∈ A, (x <ᵣ y) R ↔ (f[x] <ᵣ f[y]) S.
Proof with neauto; try congruence.
  intros A R [a Hba] HloR B S HqnB HloS HdnS Hubd.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  pose proof (enumeration_of_partial_embeddings)
    as [G [HfG [HdG Hstar]]]...
  set (⋃ᵢ (ap G)) as f.
  assert (Hf: f: A ⇔ B). {
    split; split.
    - (* is_function f *)
      split. intros p Hp.
      apply IFUnionE in Hp as [n [Hn Hp]]. apply (Hstar n Hn)...
      intros x Hx. split. apply domE in Hx...
      intros y1 y2 H1 H2.
      apply IFUnionE in H1 as [n [Hn H1]].
      apply IFUnionE in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 _]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 _]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y1 y2.
      destruct (classic (m = n))...
      apply nat_connected in H as []...
      symmetry. apply Hin1... apply Hin2...
    - (* single_rooted f *)
      intros y Hy. split. apply ranE in Hy...
      intros y1 y2 H1 H2.
      apply IFUnionE in H1 as [n [Hn H1]].
      apply IFUnionE in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 Hout1]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 Hout2]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y.
      destruct (classic (m = n)). eapply injectiveE...
      apply nat_connected in H as []...
      + destruct (classic (y1 ∈ a⟦m⟧)).
        * rewrite <- Hin1 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout1 m H y1).
          apply SepI... rewrite <- H2. eapply ranI.
          apply func_correct... apply Hi2.
      + destruct (classic (y2 ∈ a⟦n⟧)).
        * rewrite <- Hin2 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout2 n H y2).
          apply SepI... rewrite H2. eapply ranI.
          apply func_correct... apply Hi1.
    - (* dom f = A *)
      apply ExtAx. split; intros Hx.
      + apply domE in Hx as [y Hp].
        apply IFUnionE in Hp as [n [Hn Hp]]. apply domI in Hp.
        pose proof (Hstar n Hn) as [[_ [Hd _]] _].
        rewrite Hd in Hp. apply imgE in Hp as [k [Hk Hak]].
        apply func_ap in Hak... subst x.
        eapply ap_ran... eapply ω_trans...
      + set (a⁻¹[x]) as n.
        assert (Hnp: n⁺ ∈ ω). {
          apply ω_inductive. eapply ap_ran...
          apply bijection_is_func. apply inv_bijection...
        }
        pose proof (Hstar n⁺ Hnp) as [[[Hf _] [Hd _]] _].
        apply (domI _ _ G[n⁺][x]).
        apply UnionAx. exists (G[n⁺]). split. eapply ReplI...
        apply func_correct... rewrite Hd.
        apply (imgI _ _ n)... rewrite inv_op.
        apply func_correct. apply inv_func_iff_sr.
        apply Hia. rewrite inv_dom...
    - (* ran f ⊆ B *)
      intros y Hy. apply ranE in Hy as [x Hp].
      apply IFUnionE in Hp as [n [Hn Hp]]. apply domI in Hp as Hx.
      pose proof (Hstar n Hn) as [[[Hf _] [Hd Hr]] _].
      apply func_ap in Hp... subst y.
      eapply ap_ran... split...
  }
  assert (Hap: ∀x ∈ A, ∃n ∈ ω, <x, f[x]> ∈ G[n]). {
    intros x Hx. destruct Hf as [[Hf _] [Hd _]].
    apply IFUnionE. fold f. apply func_correct...
  }
  exists f. split...
  intros x Hx y Hy.
  apply Hap in Hx as [n [Hn H1]]. apply domI in H1 as Hx.
  apply Hap in Hy as [m [Hm H2]]. apply domI in H2 as Hy.
  pose proof (Hstar n Hn) as [[[Hf1 _] [Hd1 _]] [Hop1 [Hin1 Hout1]]].
  pose proof (Hstar m Hm) as [[[Hf2 _] [Hd2 _]] [Hop2 [Hin2 _]]].
  apply func_ap in H1... rewrite <- H1.
  apply func_ap in H2... rewrite <- H2.
  destruct (classic (n = m)). {
    subst m. split; intros Hlt; apply Hop1...
  }
  apply nat_connected in H as []...
  - assert (Hxm: x ∈ a⟦m⟧). {
      rewrite Hd1 in Hx. apply imgE in Hx as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite Hin2... split; intros Hlt; apply Hop2...
  - assert (Hyn: y ∈ a⟦n⟧). {
      rewrite Hd2 in Hy. apply imgE in Hy as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite (Hin1 m H)... split; intros Hlt; apply Hop1...
Qed.

(* 可数无穷线序集可嵌入可数无穷稠密线序集 *)
Lemma infinite_loset_embeddable_in_dense_infinite_loset :
  ∀ S, ω ≈ A S → ∀ T, ω ≈ A T → dense (R T) →
  ∃ T', T' ⊑ T ∧ S ≅ T'.
Proof with eauto.
  intros S HqnS T HqnT Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset T HqnT Hdn)
    as [U [[Hsub HrT] [HqnC [HdnT Hubd]]]].
  assert (Hf: ∃ f, f: A S ⇔ A U ∧ ∀ x y ∈ A S,
    (x <ᵣ y) (R S) ↔ (f[x] <ᵣ f[y]) (R U)). {
    eapply union_of_partial_embeddings...
  }
  destruct Hf as [f [Hf Hop]].
  assert (H := Hf). destruct H as [Hif [Hd Hr]].
  set (ran f) as B.
  assert (Hlo: loset B (R U ⥏ B)). {
    apply (subRel_loset (A U))...
  }
  set (constr B (R U ⥏ B) Hlo) as T'.
  exists T'. repeat split. eapply sub_tran...
  simpl. rewrite HrT, subRel_absorption...
  exists f. split... split...
  intros x Hx y Hy. split; intros Hlt.
  - apply SepI. apply Hop...
    apply CProdI; eapply ap_ran; eauto; split; auto; apply Hif.
  - apply SepE1 in Hlt. apply Hop...
Qed.

(* 可数线序集可嵌入可数无穷稠密线序集 *)
Theorem countable_loset_embeddable_in_infinite_dense_loset :
  ∀ S T, countable (A S) → ω ≈ (A T) → dense (R T) →
  ∃ T', T' ⊑ T ∧ S ≅ T'.
Proof with auto.
  intros S T Hcnt Hqn Hdn.
  apply countable_iff in Hcnt as [Hfin|Hinf].
  - apply finite_loset_embeddable_in_dense_infinite_loset...
  - apply infinite_loset_embeddable_in_dense_infinite_loset... symmetry... 
Qed.

(* ex8_17 可数无穷线序集可嵌入有理数集 *)
(* The assumption in the textbook about being dense seems to be redundant *)
Corollary countable_loset_embeddable_in_rat :
  ∀ S, countable (A S) →
  ∃ T, A T ⊆ ℚ ∧ R T = RatLt ⥏ A T ∧ S ≅ T.
Proof with auto.
  intros S Hcnt.
  set (constr ℚ RatLt ratLt_linearOrder) as Q.
  pose proof (countable_loset_embeddable_in_infinite_dense_loset S Q)
    as [Q' [[Hsub Hrel] Hiso]]...
  - apply CardAx1. symmetry. apply card_rat_eq_aleph0.
  - apply ratLt_dense.
  - exists Q'. repeat split...
Qed.
