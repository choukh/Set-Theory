(** Coq coding by choukh, Mar 2021 **)

Require Import ZFC.EST8_4.
Require Import ZFC.EX7_1.
Require Import ZFC.lib.NatIsomorphism.
Require Import ZFC.lib.FuncFacts.
Require Import ZFC.lib.Real.
Require Import ZFC.lib.LoStruct.
Require Import ZFC.lib.WosetMin.

(** EX8_17 **)

(* æ— ç•Œåº *)
Definition unbounded := Î» A R, âˆ€x âˆˆ A,
  (âˆƒy âˆˆ A, (x <áµ£ y) R) âˆ§ âˆƒw âˆˆ A, (w <áµ£ x) R.

(* æœ‰ç†æ•°çš„åºæ˜¯æ— ç•Œåº *)
Fact ratLt_unbounded : unbounded â„š RatLt.
Proof with auto.
  intros x Hx. split.
  - pose proof (rat_archimedean x Hx) as [y [Hy Hxy]].
    exists y. split...
  - pose proof (rat_archimedean (-x)%q) as [w [Hw Hxw]].
    apply ratAddInv_ran...
    exists (-w)%q. split. apply ratAddInv_ran...
    apply ratLt_addInv... apply ratAddInv_ran...
    rewrite ratAddInv_double...
Qed.

(* ç¨ å¯†åº *)
Definition dense := Î» R, âˆ€ x z, (x <áµ£ z) R â†’ âˆƒ y, (x <áµ£ y) R âˆ§ (y <áµ£ z) R.

(* æœ‰ç†æ•°çš„åºæ˜¯ç¨ å¯†åº *)
Fact ratLt_dense : dense RatLt.
Proof with auto.
  intros x z Hxz.
  apply binRelE2 in Hxz as H. destruct H as [Hx [Hz _]].
  apply rat_dense in Hxz as [y [Hy [Hxy Hyz]]]...
  exists y. split...
Qed.

(* æœ‰é™çº¿åºä¸æŸä¸ªè‡ªç„¶æ•°åŒæ„ *)
Lemma finite_loset_iso_nat : âˆ€ S, finite (A S) â†’
  âˆƒ T, T âŠ‘ ğ›š âˆ§ A T âˆˆ Ï‰ âˆ§ S â‰… T.
Proof with eauto.
  intros S Hfin.
  assert (H := Hfin). destruct Hfin as [n [Hn Hqn]].
  assert (HloT: loset n (Lt â¥ n)). {
    eapply subRel_loset. apply Lt_wellOrder.
    apply trans_sub... apply Ï‰_trans.
  }
  assert (HwoS: woset (A S) (R S)). apply finite_loset_is_woset...
  set (WoStruct.constr (A S) (R S) HwoS) as SÊ·.
  set (LoStruct.constr n (Lt â¥ n) HloT) as T.
  Import WoStruct.
  Import WoStruct.EpsilonImageOfNats.
  set (Seg n ğ›š) as TÊ·.
  assert (Hiso: SÊ· â‰… TÊ·). {
    apply ord_well_defined.
    rewrite finite_ord_eq_card... simpl.
    apply CardAx1 in Hqn.
    rewrite Hqn, <- (card_of_nat n)...
    symmetry. apply Î±_nat...
  }
  destruct Hiso as [f [Hf Hop]]. unfold TÊ· in Hf.
  rewrite seg_a_eq, seg_of_nat in Hf...
  assert (Hsub: n âŠ† Ï‰). apply trans_sub... apply Ï‰_trans.
  assert (Hlo: loset n (Lt â¥ n)). {
    eapply subRel_loset... apply Lt_wellOrder.
  }
  exists T. repeat split... exists f. split...
  apply bijection_is_func in Hf as [Hf _].
  intros x Hx y Hy. split; intros Hlt.
  - apply Hop in Hlt... apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran...
  - apply Hop... apply SepE1 in Hlt. apply seg_lt... apply SepI.
    + apply CProdI... apply (Ï‰_trans _ n)... eapply ap_ran...
    + zfc_simple. eapply ap_ran...
Qed.

Import LoStruct.
Import SimpleVer.

(* å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†æœ‰å¯æ•°æ— ç©·ç¨ å¯†æ— ç•Œå­é›† *)
Lemma countable_dense_loset_has_unbounded_subset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ dense (R S) â†’ âˆƒ T, T âŠ‘ S âˆ§
    Ï‰ â‰ˆ A T âˆ§ dense (R T) âˆ§ unbounded (A T) (R T).
Proof with neauto; try congruence.
  intros S [a Hba] Hdn.
  destruct (lo S) as [Hbr [Htr _]].
  assert (Hir: irrefl (R S)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  cut ((âˆƒ x y âˆˆ A S, (x <áµ£ y) (R S)) â†’ âˆƒ T, T âŠ‘ S âˆ§
    Ï‰ â‰ˆ A T âˆ§ dense (R T) âˆ§ unbounded (A T) (R T)). {
    destruct (classic (a[0] = a[1])) as [|Hnq]. {
      exfalso. apply injectiveE in H...
      rewrite Hda... rewrite Hda...
    }
    assert (Ha0: a[0] âˆˆ A S). eapply ap_ran...
    assert (Ha1: a[1] âˆˆ A S). eapply ap_ran...
    intros H. apply (lo_connected (R S) (A S) (lo S)) in Hnq as []...
    - apply H. exists (a[0]). split... exists (a[1]). split...
    - apply H. exists (a[1]). split... exists (a[0]). split...
  }
  intros [c [HcA [d [HdA Hcd]]]].
  apply Hdn in Hcd as [e [Hcd Hed]].
  apply Hbr in Hed as HeA. apply CProdE2 in HeA as [HeA _].
  set {x âˆŠ A S | Î» x, (c <áµ£ x) (R S) âˆ§ (x <áµ£ d) (R S)} as C.
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (c <áµ£ a[n]) (R S) âˆ§ (a[n] <áµ£ x) (R S)}) as Nâ‚—.
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (x <áµ£ a[n]) (R S) âˆ§ (a[n] <áµ£ d) (R S)}) as Náµ£.
  set (Î» x, (Min Lt)[Nâ‚— x]) as mâ‚—.
  set (Î» x, (Min Lt)[Náµ£ x]) as máµ£.
  set (Func C C (Î» x, a[mâ‚— x])) as fâ‚—.
  set (Func C C (Î» x, a[máµ£ x])) as fáµ£.
  assert (HeC: e âˆˆ C). apply SepI...
  assert (Hmâ‚—: âˆ€x âˆˆ C, mâ‚— x âˆˆ Ï‰ âˆ§ (c <áµ£ a[mâ‚— x]) (R S) âˆ§ (a[mâ‚— x] <áµ£ x) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (Ï‰_min (Nâ‚— x)) as [H _]. {
      apply Hdn in Hcx as [y [Hcy Hyx]].
      apply Hbr in Hyx as Hy. apply CProdE2 in Hy as [Hy _].
      exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mâ‚— x) in H. apply SepE in H as [Hm [Hcm Hmx]]. split...
  }
  assert (Hmáµ£: âˆ€x âˆˆ C, máµ£ x âˆˆ Ï‰ âˆ§ (x <áµ£ a[máµ£ x]) (R S) âˆ§ (a[máµ£ x] <áµ£ d) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (Ï‰_min (Náµ£ x)) as [H _]. {
      apply Hdn in Hxd as [y [Hxy Hyd]].
      apply Hbr in Hyd as Hy. apply CProdE2 in Hy as [Hy _].
      exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (máµ£ x) in H. apply SepE in H as [Hm [Hxm Hmd]]. split...
  }
  assert (Hfâ‚—: fâ‚—: C â‡’ C). {
    apply meta_maps_into. intros x Hx.
    apply Hmâ‚— in Hx as H. destruct H as [Hm [Hcm Hmx]].
    apply SepE2 in Hx as [_ Hxd].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  assert (Hfáµ£: fáµ£: C â‡’ C). {
    apply meta_maps_into. intros x Hx.
    apply Hmáµ£ in Hx as H. destruct H as [Hm [Hxm Hmd]].
    apply SepE2 in Hx as [Hcx _].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  pose proof (Ï‰_recursion fâ‚— C e Hfâ‚— HeC) as [hâ‚— [Hhâ‚— [Hhâ‚—0 Hhâ‚—n]]].
  pose proof (Ï‰_recursion fáµ£ C e Hfáµ£ HeC) as [háµ£ [Hháµ£ [Hháµ£0 Hháµ£n]]].
  set {x âˆŠ A S | Î» x, âˆƒn âˆˆ Ï‰, (hâ‚—[n] â‰¤áµ£ x) (R S) âˆ§ (x â‰¤áµ£ háµ£[n]) (R S)} as B.
  assert (HBA: B âŠ† A S). apply SepE1.
  assert (HCA: C âŠ† A S). apply SepE1.
  assert (Hdesc: âˆ€x âˆˆ C, (fâ‚—[x] <áµ£ x) (R S)). {
    intros x Hx. unfold fâ‚—. rewrite meta_func_ap... apply Hmâ‚—...
  }
  assert (Hasc: âˆ€x âˆˆ C, (x <áµ£ fáµ£[x]) (R S)). {
    intros x Hx. unfold fáµ£. rewrite meta_func_ap... apply Hmáµ£...
  }
  assert (Hmonoâ‚—: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (hâ‚—[m] <áµ£ hâ‚—[n]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (hâ‚—[k] <áµ£ hâ‚—[n]) (R S)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhâ‚—n... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hdesc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hdesc... eapply ap_ran...
  }
  assert (Hmonoáµ£: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (háµ£[n] <áµ£ háµ£[m]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (háµ£[n] <áµ£ háµ£[k]) (R S)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hháµ£n... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hasc... eapply ap_ran...
  }
  assert (Hihâ‚—: hâ‚— : Ï‰ â‡” B). {
    destruct Hhâ‚— as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoâ‚— in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: xâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists x. split... split; [right|]...
      Ï‰_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
      + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
  }
  assert (Hiháµ£: háµ£ : Ï‰ â‡” B). {
    destruct Hháµ£ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoáµ£ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: xâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists x. split... split; [|right]...
      Ï‰_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
      + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
  }
  assert (Hlo: loset B (R S â¥ B)). eapply subRel_loset...
  set (constr B (R S â¥ B) Hlo) as T.
  exists T. split... split... split; [|split].
  - (* Ï‰ â‰ˆ A T *)
    apply SchrÃ¶eder_Bernstein.
    + exists hâ‚—...
    + assert (A S â‰ˆ Ï‰). symmetry. exists a...
      apply dominate_sub in HBA.
      eapply dominate_rewrite_r...
  - (* dense (R T) *)
    intros x y Hxy. apply SepE in Hxy as [Hxy H].
    apply CProdE2 in H as [Hx Hy].
    apply Hdn in Hxy as [z [Hxz Hzy]].
    cut (z âˆˆ B). {
      intros Hz. exists z; split;
      apply SepI; auto; apply CProdI...
    }
    apply Hbr in Hzy as H.
    apply CProdE2 in H as [Hz _]. apply SepI...
    apply SepE2 in Hx as [n [Hn [Hnx Hxn]]].
    apply SepE2 in Hy as [m [Hm [Hmy Hym]]].
    destruct (classic (n = m)). {
      subst m. exists n. split... split; left.
      eapply relLe_lt_tranr; revgoals...
      eapply relLt_le_tranr...
    }
    apply nat_connected in H as [Hnm|Hmn]...
    + apply Hmonoâ‚— in Hnm...
      exists m. split... split; left.
      * eapply relLe_lt_tranr; revgoals... left.
        eapply relLt_le_tranr...
      * eapply relLt_le_tranr...
    + apply Hmonoáµ£ in Hmn...
      exists n. split... split; left.
      * eapply relLe_lt_tranr...
      * eapply relLe_lt_tranr... left.
        eapply relLt_le_tranr...
  - (* unbounded (A T) (R T)) *)
    intros x Hx. assert (H := Hx).
    apply SepE2 in H as [n [Hn [Hnx Hxn]]].
    destruct (lo T) as [_ [Htr' _]]. split. {
      destruct Hiháµ£ as [[Hf _] [Hd Hr]].
      assert (Hnp: nâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists (háµ£[nâº]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists nâº. split... split; [left|right]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
        + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
      - apply (relLe_lt_tranr _ (háµ£[n]))...
        + destruct Hxn; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
        + apply SepI. apply Hmonoáµ£...
          apply CProdI; eapply ap_ran; eauto; split...
    } {
      destruct Hihâ‚— as [[Hf _] [Hd Hr]].
      assert (Hnp: nâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists (hâ‚—[nâº]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists nâº. split... split; [right|left]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
        + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
      - apply (relLt_le_tranr _ (hâ‚—[n]))...
        + apply SepI. apply Hmonoâ‚—...
          apply CProdI; eapply ap_ran; eauto; split...
        + destruct Hnx; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
    }
Qed.

(* å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†æœ‰å¯æ•°æ— ç©·è‰¯åºå­é›† *)
Lemma countable_dense_loset_has_wo_subset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ dense (R S) â†’ âˆƒ T, T âŠ‘ S âˆ§ ğ›š â‰… T.
Proof with neauto; try congruence.
  intros S Hqn Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset
    S Hqn Hdn) as [T [[Hsub Hrel] [[a Hba] [_ Hubd]]]].
  destruct (lo T) as [_ [Htr _]].
  assert (Hir: irrefl (R T)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (x <áµ£ a[n]) (R S)}) as M.
  set (Î» x, (Min Lt)[M x]) as m.
  set (Func (A T) (A T) (Î» x, a[m x])) as f.
  assert (Hmx: âˆ€x âˆˆ A T, m x âˆˆ Ï‰ âˆ§ (x <áµ£ a[m x]) (R S)). {
    intros x Hx.
    cut (m x âˆˆ M x). intros H. apply SepE in H...
    apply Ï‰_min; [|apply SepE1].
    apply Hubd in Hx as [[y [Hy Hxy]] _].
    rewrite Hrel in Hxy. apply SepE1 in Hxy.
    exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A T))...
    apply bijection_is_func. apply inv_bijection...
    rewrite inv_ran_reduction...
  }
  assert (Hf: f: A T â‡’ A T). {
    apply meta_maps_into. intros x Hx.
    eapply ap_ran... apply Hmx...
  }
  assert (Ha0: a[0] âˆˆ A T). eapply ap_ran...
  pose proof (Ï‰_recursion f (A T) (a[0]) Hf Ha0) as [h [Hh [Hh0 Hhn]]].
  assert (Hasc: âˆ€x âˆˆ A T, (x <áµ£ f[x]) (R T)). {
    intros x Hx. unfold f. rewrite meta_func_ap, Hrel...
    apply SepI. apply Hmx... apply CProdI...
    eapply ap_ran... apply Hmx...
  }
  assert (Hmono: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (h[n] <áµ£ h[m]) (R T)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (h[n] <áµ£ h[k]) (R T)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m0.
      apply Hasc... eapply ap_ran...
  }
  assert (Hop: âˆ€ n m âˆˆ Ï‰, (h[n] <áµ£ h[m]) (R T) â†’ n âˆˆ m). {
    intros n Hn k Hk Hnk.
    destruct (classic (n = k)).
    - subst k. exfalso. eapply relLt_irrefl...
    - apply nat_connected in H as []...
      apply Hmono in H... exfalso.
      eapply relLt_irrefl... eapply relLt_tranr...
  }
  assert (Hbh: h: Ï‰ âŸº ran h). {
    destruct Hh as [Hfh [Hd Hr]].
    split; split...
    intros y Hy. split. apply ranE in Hy...
    intros x1 x2 H1 H2.
    apply domI in H1 as Hx1. rewrite Hd in Hx1.
    apply domI in H2 as Hx2. rewrite Hd in Hx2.
    apply func_ap in H1...
    apply func_ap in H2...
    destruct (classic (x1 = x2))... exfalso.
    apply nat_connected in H as []; auto;
    apply Hmono in H; auto; rewrite H1, H2 in H; eapply Hir...
  }
  assert (Hsub': ran h âŠ† A S). {
    destruct Hh as [_ [_ Hr]]. eapply sub_tran...
  }
  assert (Hlo: loset (ran h) (R S â¥ ran h)). {
    eapply subRel_loset...
  }
  set (constr (ran h) (R S â¥ ran h) Hlo) as U.
  exists U. split. split... exists h. split... simpl.
  intros x Hx y Hy. split; intros Hlt.
  - apply binRelE3 in Hlt.
    apply Hmono in Hlt... rewrite Hrel in Hlt.
    apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran; eauto; apply bijection_is_func...
  - apply SepE1 in Hlt. apply SepI. apply CProdI...
    zfc_simple. apply Hop... rewrite Hrel. apply SepI...
    apply CProdI; eapply ap_ran...
Qed.

(* æœ‰é™çº¿åºé›†ä¸å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†çš„å­é›†åŒæ„ *)
Lemma finite_loset_iso_subset_of_dense_infinite_loset :
  âˆ€ S, finite (A S) â†’ âˆ€ T, Ï‰ â‰ˆ A T â†’ dense (R T) â†’
  âˆƒ U, U âŠ‘ T âˆ§ S â‰… U.
Proof with eauto; try congruence.
  intros S Hfin T Hqn Hdn.
  pose proof (finite_loset_iso_nat S Hfin)
    as [S' [[HsubS HrS] [Hn [f [Hf Hopf]]]]].
  pose proof (countable_dense_loset_has_wo_subset T Hqn Hdn)
    as [T' [[HsubT HrT] [g [Hg Hopg]]]].
  simpl in *.
  set (A S') as n.
  set ((g â†¾ n) âˆ˜ f) as h.
  assert (Hg': g â†¾ n: n âŸº gâŸ¦nâŸ§). eapply restr_bijection...
  assert (Hh: h: A S âŸº gâŸ¦nâŸ§). eapply compo_bijection...
  assert (Hsub: gâŸ¦nâŸ§ âŠ† A T). {
    eapply sub_tran; revgoals...
    destruct Hg as [_ [_ Hr]]. rewrite <- Hr.
    apply img_included.
  }
  assert (Hlo: loset (gâŸ¦nâŸ§) (R T â¥ gâŸ¦nâŸ§)). eapply subRel_loset...
  set (constr (gâŸ¦nâŸ§) (R T â¥ gâŸ¦nâŸ§) Hlo) as U.
  exists U. repeat split... exists h. split...
  destruct Hf as [[Hff _] [Hdf Hdr]].
  destruct Hg as [[Hfg _] [Hdg Hrg]].
  destruct Hg' as [[Hfg' _] _].
  assert (Hfx: âˆ€x âˆˆ A S, f[x] âˆˆ n). {
    intros x Hx. unfold n. rewrite <- Hdr.
    eapply ranI. apply func_correct...
  }
  assert (Hd: âˆ€x âˆˆ A S, x âˆˆ dom ((g â†¾ n) âˆ˜ f)). {
    intros x Hx. rewrite compo_dom... apply SepI...
    assert (dom (g â†¾ n) = n). apply restr_dom... rewrite Hdg...
    rewrite H. apply Hfx...
  }
  intros x Hx y Hy.
  apply Hfx in Hx as Hfx0. apply Hfx in Hy as Hfy.
  apply Hd in Hx as Hdx. apply Hd in Hy as Hdy.
  assert (HfxÏ‰: f[x] âˆˆ Ï‰). eapply Ï‰_trans...
  assert (HfyÏ‰: f[y] âˆˆ Ï‰). eapply Ï‰_trans...
  unfold h. rewrite compo_correct, compo_correct...
  rewrite restr_ap, restr_ap...
  split; intros Hlt.
  - apply Hopf in Hlt...
    rewrite HrS in Hlt. apply SepE1 in Hlt.
    apply Hopg in Hlt; [|apply HsubS; apply Hfx..]...
    rewrite HrT in Hlt. apply SepE1 in Hlt.
    apply SepI... apply CProdI.
    + apply (imgI _ _ (f[x]))... apply func_correct...
    + apply (imgI _ _ (f[y]))... apply func_correct...
  - apply Hopf... rewrite HrS. apply SepI; [|apply CProdI..]...
    apply Hopg... rewrite HrT. apply SepI... apply SepE1 in Hlt...
    apply CProdI; rewrite <- Hrg; eapply ranI; apply func_correct...
Qed.

Section EX8_17.
Import FullVer.

Let FinLoMax := Î» R B, (Min B (R â¥ B)â»Â¹) [B].
Let FinLoMin := Î» R B, (Min B (R â¥ B)) [B].

Local Lemma finite_loset_has_max : âˆ€ A R B, loset A R â†’
  B â‰  âˆ… â†’ B âŠ† A â†’ finite B â†’ maximum (FinLoMax R B) B (R â¥ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin. apply maximum_iff_minimum_inv.
  apply min_correct... apply finite_loset_is_woset...
  apply inv_lo... eapply subRel_loset... apply EmptyNE...
Qed.

Local Lemma finite_loset_has_min : âˆ€ A R B, loset A R â†’
  B â‰  âˆ… â†’ B âŠ† A â†’ finite B â†’ minimum (FinLoMin R B) B (R â¥ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin.
  apply min_correct... apply finite_loset_is_woset...
  eapply subRel_loset... apply EmptyNE...
Qed.

Import SimpleVer.

(* å¯¹ä»»æ„å¯æ•°æ— ç©·çº¿åºé›†Aå’ŒBï¼Œå¦‚æœBæ˜¯ç¨ å¯†çš„ï¼Œé‚£ä¹ˆå¯¹Açš„ä»»æ„æœ‰é™å­é›†ï¼Œ
  å­˜åœ¨Bçš„å­é›†ä¸ä¹‹åŒæ„ï¼Œä¸”å­˜åœ¨ä»¥Ï‰ä¸ºå®šä¹‰åŸŸçš„å‡½æ•°Fä½œä¸ºè¿™äº›åŒæ„æ˜ å°„çš„æšä¸¾ *)
(* For any countably infinite loset A, B, if B is dense,
  then for any finite fragment of A, there exists subset of B that is
  isomorphic to A, and there exists a function F with domain Ï‰,
  such that F is the enumeration of these isomorphisms *)
Local Lemma ex_enumeration_of_all_finite_isomorphisms :
  âˆ€ A R a, a: Ï‰ âŸº A â†’ loset A R â†’
  âˆ€ B S, Ï‰ â‰ˆ B â†’ loset B S â†’ dense S â†’
  âˆƒ G, is_function G âˆ§ dom G = Ï‰ âˆ§ âˆ€n âˆˆ Ï‰, G[n]: aâŸ¦nâŸ§ â‡” B âˆ§
    (âˆ€ x y âˆˆ aâŸ¦nâŸ§, (x <áµ£ y) R â†” (G[n][x] <áµ£ G[n][y]) (S â¥ ran G[n])) âˆ§
    (âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦mâŸ§, G[m][x] = G[n][x]) âˆ§
    (âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, G[n][x] âˆ‰ ran G[m]).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S HqnB HloS HdnS.
  assert (H := HloR). destruct H as [_ [HtrR _]].
  assert (HirR: irrefl R). eapply lo_irrefl...
  pose proof (countable_dense_loset_has_unbounded_subset
    (constr B S HloS) HqnB HdnS)
    as [U [[Hsub HrT] [[c Hbc] [HdnT Hubd]]]].
  destruct (lo U) as [Hbr [HtrT _]].
  simpl in *. rewrite HrT in HdnT, Hubd, Hbr, HtrT.
  remember (LoStruct.A U) as C.
  remember (S â¥ C) as T.
  assert (HirT: irrefl T). rewrite <- HrT. eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hbc). apply bijection_is_func in H as [Hmc [Hic Hrc]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (Î» f, âˆ€ x y âˆˆ dom f, (x <áµ£ y) R â†” (f[x] <áµ£ f[y]) (T â¥ ran f)) as op.
  set (â‹ƒ{Î» X, X âŸ¶ C | X âˆŠ ğ’« A}) as fs0.
  set {f âˆŠ fs0 | Î» f, (âˆƒn âˆˆ Ï‰, f: aâŸ¦nâŸ§ â‡” C) âˆ§ op f} as fs.
  set (Î» f, {y âˆŠ dom f | Î» y, (y <áµ£ a[|dom f|]) R}) as ğ‹.
  set (Î» f, {y âˆŠ dom f | Î» y, (a[|dom f|] <áµ£ y) R}) as ğ‘.
  set (Î» f, FinLoMax R (ğ‹ f)) as aâ‚—.
  set (Î» f, FinLoMin R (ğ‘ f)) as aáµ£.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (c[k] <áµ£ f[aáµ£ f]) T}) as Náµ£.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (f[aâ‚— f] <áµ£ c[k]) T}) as Nâ‚—.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (f[aâ‚— f] <áµ£ c[k]) T âˆ§ (c[k] <áµ£ f[aáµ£ f]) T}) as Nâ‚˜.
  set (Î» f,
    match (ixm (ğ‹ f = âˆ…)) with
    | inl _ => match (ixm (ğ‘ f = âˆ…)) with
      | inl _ => c[0]
      | inr _ => c[(Min Lt)[Náµ£ f]]
      end
    | inr _ => match (ixm (ğ‘ f = âˆ…)) with
      | inl _ => c[(Min Lt)[Nâ‚— f]]
      | inr _ => c[(Min Lt)[Nâ‚˜ f]]
      end
    end
  ) as add.
  set (Î» f, f âˆª â¨<a[|dom f|], add f>â¬) as F.
  set (Func fs fs F) as g.
  assert (Hcdn: âˆ€n âˆˆ Ï‰, |aâŸ¦nâŸ§| = n). {
    intros n Hn. rewrite (card_of_nat n) at 2...
    apply CardAx1. symmetry. exists (a â†¾ n).
    eapply restr_bijection; revgoals...
    apply trans_sub... apply Ï‰_trans.
  }
  assert (Haâ‚—: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ C â†’ ğ‹ f â‰  âˆ… â†’
    âˆƒk âˆˆ n, a[k] = aâ‚— f âˆ§ (a[k] <áµ£ a[n]) R âˆ§
    âˆ€l âˆˆ n, (a[l] <áµ£ a[n]) R â†’ (a[l] â‰¤áµ£ a[k]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_max A R (ğ‹ f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [H Hlt].
      rewrite Hd in H, Hlt. rewrite Hcdn in Hlt...
      apply imgE in H as [k [Hk Hak]].
      apply func_ap in Hak... exists k. repeat split...
      intros m Hm Hamk. assert (a[m] âˆˆ ğ‹ f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (Haáµ£: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ C â†’ ğ‘ f â‰  âˆ… â†’
    âˆƒk âˆˆ n, a[k] = aáµ£ f âˆ§ (a[n] <áµ£ a[k]) R âˆ§
    âˆ€l âˆˆ n, (a[n] <áµ£ a[l]) R â†’ (a[k] â‰¤áµ£ a[l]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_min A R (ğ‘ f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [H Hlt].
      rewrite Hd in H, Hlt. rewrite Hcdn in Hlt...
      apply imgE in H as [k [Hk Hak]].
      apply func_ap in Hak... exists k. repeat split...
      intros m Hm Hamk. assert (a[m] âˆˆ ğ‘ f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (HNâ‚—: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ C â†’ ğ‹ f â‰  âˆ… â†’
    (Min Lt)[Nâ‚— f] âˆˆ Nâ‚— f âˆ§ âˆ€ m âˆˆ Nâ‚— f, (Min Lt)[Nâ‚— f] â‹¸ m). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (Ï‰_min (Nâ‚— f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aâ‚— f] âˆˆ C). {
        apply Hr. eapply ranI. apply func_correct...
        pose proof Haâ‚— as [k [Hk [Hak _]]]...
        rewrite <- Hak, Hd. eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      pose proof (Hubd (f[aâ‚— f]) H) as [[w [Hw Hlt]] _].
      exists (câ»Â¹[w]). apply SepI.
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNáµ£: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ C â†’ ğ‘ f â‰  âˆ… â†’
    (Min Lt)[Náµ£ f] âˆˆ Náµ£ f âˆ§ âˆ€ m âˆˆ Náµ£ f, (Min Lt)[Náµ£ f] â‹¸ m). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (Ï‰_min (Náµ£ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aáµ£ f] âˆˆ C). {
        apply Hr. eapply ranI. apply func_correct...
        pose proof Haáµ£ as [k [Hk [Hak _]]]...
        rewrite <- Hak, Hd. eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      pose proof (Hubd (f[aáµ£ f]) H) as [_ [w [Hw Hlt]]].
      exists (câ»Â¹[w]). apply SepI.
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Himg0: aâŸ¦âˆ…âŸ§ = âˆ…). {
    apply ExtAx. split; intros Hx; [|exfalso0].
    apply imgE in Hx as [w [Hw _]]. exfalso0.
  }
  assert (HNâ‚˜: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ ğ‹ f â‰  âˆ… â†’ ğ‘ f â‰  âˆ… â†’
    (Min Lt)[Nâ‚˜ f] âˆˆ Nâ‚˜ f âˆ§ âˆ€ m âˆˆ Nâ‚˜ f, (Min Lt)[Nâ‚˜ f] â‹¸ m). {
    intros n Hn f Hif Hop HneL HneR.
    apply injection_is_func in Hif as H. destruct H as [Hmf _].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    apply (Ï‰_min (Nâ‚˜ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - pose proof (HdnT (f[aâ‚— f]) (f[aáµ£ f])) as [qâ‚˜ [H1 H2]]. {
        pose proof Haâ‚— as [k [Hk [Hak [H1 _]]]]...
        pose proof Haáµ£ as [l [Hl [Hal [H2 _]]]]...
        rewrite <- Hak, <- Hal.
        assert (Hakl: (a[k] <áµ£ a[l]) R). eapply relLt_tranr...
        eapply Hop in Hakl.
        - apply SepE1 in Hakl...
        - rewrite Hdf. apply (imgI _ _ k)... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        - rewrite Hdf. apply (imgI _ _ l)... apply func_correct...
            rewrite Hda. eapply Ï‰_trans...
      }
      assert (Hqâ‚˜: qâ‚˜ âˆˆ C). {
        apply Hbr in H1. apply CProdE2 in H1 as [_ H]...
      }
      exists (câ»Â¹[qâ‚˜]). apply SepI...
      + apply (ap_ran C)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Hadd: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ add f âˆˆ C). {
    intros n Hn f Hif Hop. unfold add.
    apply injection_is_func in Hif as H. destruct H as [Hmf _].
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
    destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR]; eapply ap_ran...
    - pose proof HNáµ£ as [H _]... apply SepE1 in H...
    - pose proof HNâ‚— as [H _]... apply SepE1 in H...
    - pose proof HNâ‚˜ as [H _]... apply SepE1 in H...
  }
  assert (H00: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ C â†’ n = âˆ… â†” ğ‹ f = âˆ… âˆ§ ğ‘ f = âˆ…). {
    intros n Hn f [Hf [Hd _]]. split.
    - intros Heq. subst n. rewrite Himg0 in Hd.
      split; [unfold ğ‹|unfold ğ‘]; rewrite Hd; apply sep_empty.
    - intros [HL0 HR0]. destruct (classic (n = âˆ…))...
      exfalso. apply pred_exists in H as [k [Hk Heq]]... subst n.
      destruct (classic (a[k] = a[kâº])). {
        apply injectiveE in H... assert (k âˆˆ kâº)...
        rewrite <- H in H0 at 1. eapply nat_irrefl...
      }
      apply (lo_connected R A) in H as []; revgoals.
      eapply ap_ran... eapply ap_ran... apply HloR.
      + eapply EmptyNI in HR0... exists (a[k]).
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
      + eapply EmptyNI in HL0... exists (a[k]).
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
  }
  assert (Hout: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ add f âˆ‰ ran f). {
    intros n Hn f Hif Hop Hin.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: aâŸ¦nâŸ§ âŸº ran f). split...
    apply ranE in Hin as [x Hfx]. apply domI in Hfx as Hx.
    rewrite Hdf in Hx. apply imgE in Hx as [k [Hk Hak]].
    apply func_ap in Hak... apply func_ap in Hfx...
    subst x. unfold add in Hfx.
    assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
    destruct (classic (a[k] = a[n])) as [|Hnq]. {
      apply injectiveE in H... eapply nat_not_lt_self...
    }
    assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
      apply (imgI _ _ k)... apply func_correct...
    }
    destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
    destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR].
    + assert (n = âˆ…). eapply H00... subst n. exfalso0.
    + pose proof HNáµ£ as [Hkl _]; revgoals...
      pose proof Haáµ£ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
      apply SepE2 in Hkl. rewrite <- Hfx, <- Heq in Hkl.
      assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
        apply (imgI _ _ l)... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      assert (Hakl: (a[k] <áµ£ a[l]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
      * eapply EmptyNI in HL... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
    + pose proof HNâ‚— as [Hlk _]; revgoals...
      pose proof Haâ‚— as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
      apply SepE2 in Hlk. rewrite <- Hfx, <- Heq in Hlk.
      assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
        apply (imgI _ _ l)... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      assert (Halk: (a[l] <áµ£ a[k]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * eapply EmptyNI in HR... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
    + pose proof HNâ‚˜ as [Hkl _]; revgoals...
      pose proof Haâ‚— as [lâ‚— [Hlâ‚— [Heqâ‚— [Hnlâ‚— Hleâ‚—]]]]; revgoals...
      pose proof Haáµ£ as [láµ£ [Hláµ£ [Heqáµ£ [Hnláµ£ Hleáµ£]]]]; revgoals...
      apply SepE2 in Hkl. rewrite <- Hfx, <- Heqâ‚—, <- Heqáµ£ in Hkl.
      destruct Hkl as [Hlk Hkl].
      assert (Halâ‚—: a[lâ‚—] âˆˆ aâŸ¦nâŸ§). {
        apply (imgI _ _ lâ‚—)... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      assert (Haláµ£: a[láµ£] âˆˆ aâŸ¦nâŸ§). {
        apply (imgI _ _ láµ£)... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      assert (Halk: (a[lâ‚—] <áµ£ a[k]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      assert (Hakl: (a[k] <áµ£ a[láµ£]) R). {
        eapply Hop; revgoals...
        apply SepI... apply CProdI.
        eapply ap_ran... apply bijection_is_func...
        eapply ap_ran... apply bijection_is_func...
      }
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hleáµ£ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
      * apply Hleâ‚— in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals...
  }
  assert (Himg: âˆ€n âˆˆ Ï‰, aâŸ¦nâºâŸ§ = aâŸ¦nâŸ§ âˆª â¨a[n]â¬). {
    intros n Hn. replace â¨a[n]â¬ with (aâŸ¦â¨nâ¬âŸ§).
    apply img_bunion_distr.
    apply ExtAx. split; intros Hx.
    - apply imgE in Hx as [w [Hw Hp]]. apply SingE in Hw; subst.
      apply func_ap in Hp... subst x...
    - apply SingE in Hx; subst. apply (imgI _ _ n)...
      apply func_correct...
  }
  assert (Hdj1: âˆ€n âˆˆ Ï‰, disjoint (aâŸ¦nâŸ§) â¨a[n]â¬). {
    intros n Hn. apply disjointI. intros [x [H1 H2]].
    apply SingE in H2; subst x.
    apply imgE in H1 as [k [Hk Hp]].
    apply func_ap in Hp... apply injectiveE in Hp...
    eapply nat_not_lt_self... rewrite Hda. eapply Ï‰_trans...
  }
  assert (Hdj2: âˆ€n âˆˆ Ï‰, âˆ€f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ disjoint (ran f) â¨add fâ¬). {
    intros n Hn f Hif Hop. apply disjointI. intros [x [H1 H2]].
    apply SingE in H2; subst x. eapply Hout...
  }
  assert (Hind: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ F f : aâŸ¦nâºâŸ§ â‡” C âˆ§ op (F f)). {
    intros n Hn f Hif Hop.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: aâŸ¦nâŸ§ âŸº ran f). split...
    cut (F f: aâŸ¦nâºâŸ§ âŸº ran f âˆª â¨add fâ¬ âˆ§ op (F f)). {
      intros [[HiFf [HdFf HrFf]] HopFf].
      split... split... split...
      intros x Hx. rewrite HrFf in Hx.
      apply BUnionE in Hx as []... apply Hrf...
      apply SingE in H. subst x. eapply Hadd...
    }
    assert (HFf: F f : aâŸ¦nâºâŸ§ âŸº ran f âˆª â¨add fâ¬). {
      unfold F. rewrite Hdf, Hcdn, Himg...
      apply bijection_add_point...
      apply Hdj1... eapply Hdj2...
    }
    split...
    assert (Hop': âˆ€ x y âˆˆ aâŸ¦nâŸ§, (x <áµ£ y) R â†” (f[x] <áµ£ f[y]) T). {
      unfold op in Hop. rewrite Hdf in Hop.
      intros x Hx y Hy. split; intros Hlt.
      - apply Hop in Hlt... apply SepE1 in Hlt...
      - apply Hop... apply SepI...
        apply CProdI; auto; eapply ranI; apply func_correct...
    }
    destruct HFf as [[Hf _] [Hd Hr]].
    intros u Hu v Hv.
    cut ((u <áµ£ v) R â†” ((F f)[u] <áµ£ (F f)[v]) T). {
      intros H. split; intros Hlt.
      - apply SepI. apply H...
        apply CProdI; eapply ap_ran; eauto; split...
      - apply SepE1 in Hlt. apply H...
    }
    assert (Hap: âˆ€x âˆˆ dom (F f),
      x âˆˆ aâŸ¦nâŸ§ âˆ§ (F f)[x] = f[x] âˆ¨
      x = a[n] âˆ§ (F f)[x] = add f).
    {
      rewrite Hd, Himg... unfold F. rewrite Hdf, Hcdn...
      eapply add_point_func_ap'...
      apply Hdj1... eapply Hdj2...
    }
    apply Hap in Hu as [[Hu HFfu]|[Hu HFfu]];
    apply Hap in Hv as [[Hv HFfv]|[Hv HFfv]];
    rewrite HFfu, HFfv.
    - apply Hop'...
    - subst v. unfold add.
      apply imgE in Hu as [k [Hk Hak]].
      apply func_ap in Hak... subst u. 
      assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
      destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR];
      split; intros Hlt.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNáµ£ as [H _]; revgoals...
        pose proof Haáµ£ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop'...
        eapply relLt_tranr...
      + pose proof HNâ‚— as [H _]; revgoals...
        pose proof Haâ‚— as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNâ‚˜ as [H _]; revgoals...
        pose proof Haâ‚— as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H as [H _]. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + pose proof HNâ‚˜ as [H _]; revgoals...
        pose proof Haáµ£ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H as [_ H]. rewrite <- Heq in H.
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop'...
        eapply relLt_tranr...
    - subst u. unfold add.
      apply imgE in Hv as [k [Hk Hak]].
      apply func_ap in Hak... subst v. 
      assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
      destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR];
      split; intros Hlt.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + pose proof HNáµ£ as [H _]; revgoals...
        pose proof Haáµ£ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof HNâ‚— as [H _]; revgoals...
        pose proof Haâ‚— as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H. rewrite <- Heq in H.
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop'...
        eapply relLt_tranr...
      + pose proof HNâ‚˜ as [H _]; revgoals...
        pose proof Haáµ£ as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H as [_ H]. rewrite <- Heq in H.
        pose proof (Hle k Hk Hlt) as []...
        eapply relLt_tranr... apply Hop'...
      + pose proof HNâ‚˜ as [H _]; revgoals...
        pose proof Haâ‚— as [l [Hl [Heq [Hnl Hle]]]]; revgoals...
        assert (Hal: a[l] âˆˆ aâŸ¦nâŸ§). {
          eapply imgI... apply func_correct...
          rewrite Hda. eapply Ï‰_trans...
        }
        apply SepE2 in H as [H _]. rewrite <- Heq in H.
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop'...
        eapply relLt_tranr...
    - split; intros Hlt; exfalso.
      + rewrite Hu, Hv in Hlt. eapply relLt_irrefl; revgoals...
      + eapply relLt_irrefl; revgoals...
  }
  assert (Hfs: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” C â†’ op f â†’ F f âˆˆ fs). {
    intros n Hn f Hf Hop. apply SepI.
    - apply UnionAx. exists (aâŸ¦nâºâŸ§ âŸ¶ C). split.
      + apply ReplAx. exists (aâŸ¦nâºâŸ§). split...
        apply PowerAx. rewrite <- Hra. apply img_included.
      + apply arrowI. apply Hind in Hf as [Hf _]...
        apply injection_is_func...
    - split; [|eapply Hind]...
      exists nâº. split. apply Ï‰_inductive... apply Hind...
  }
  assert (Hg: g: fs â‡’ fs). {
    apply meta_maps_into. intros f Hf.
    apply SepE in Hf as [Hf [[n [Hn Hif]] Hop]]. eapply Hfs...
  }
  assert (Hi0: âˆ…: aâŸ¦âˆ…âŸ§ â‡” C). {
    rewrite Himg0. apply empty_injective.
  }
  assert (Hop0: op âˆ…). {
    intros x Hx. rewrite dom_of_empty in Hx. exfalso0.
  }
  pose proof (Ï‰_recursion g fs âˆ… Hg) as [G [HG [HG0 HGn]]]. {
    apply SepI.
    - apply UnionAx. exists (âˆ… âŸ¶ C). split.
      + apply ReplAx. exists âˆ…. split... apply empty_in_all_power.
      + apply arrowI. apply injection_is_func. apply empty_injective.
    - split... exists âˆ…. split...
  }
  assert (HiGn: âˆ€n âˆˆ Ï‰, G[n] : aâŸ¦nâŸ§ â‡” C âˆ§ op G[n]). {
    intros n Hn.
    destruct HG as [HfG [HdG HrG]].
    set {n âˆŠ Ï‰ | Î» n, G[n] : aâŸ¦nâŸ§ â‡” C âˆ§ op G[n]} as N.
    Ï‰_induction N Hn. rewrite HG0...
    rewrite HGn... unfold g.
    rewrite meta_func_ap... apply Hind; auto; apply IH.
    apply HrG. eapply ranI. apply func_correct...
  }
  assert (HinG: âˆ€m âˆˆ Ï‰, âˆ€x âˆˆ aâŸ¦mâŸ§, G[m][x] = G[mâº][x]). {
    intros m Hm x Hx. rewrite HGn... unfold g.
    rewrite meta_func_ap; [|auto|eapply ap_ran]...
    pose proof (HiGn m Hm) as [Hi Hop].
    assert (H := Hi). destruct H as [Hf [Hd Hr]].
    assert (G[m]: aâŸ¦mâŸ§ âŸº ran G[m]). split...
    symmetry. eapply add_point_func_ap...
    rewrite Hd, Hcdn... apply Hdj1... eapply Hdj2...
  }
  assert (HoutG: âˆ€m âˆˆ Ï‰, G[mâº][a[m]] âˆ‰ ran G[m]). {
    intros m Hm Hr.
    pose proof (HiGn m Hm) as [HGm Hop].
    apply injection_is_func in HGm as [HGm Him].
    assert (H := HGm). destruct H as [Hfm [Hdm Hrm]].
    apply ranE in Hr as [x Hp]. apply domI in Hp as Hx.
    apply func_ap in Hp... rewrite HGn in Hp...
    unfold g in Hp. rewrite meta_func_ap in Hp; [|auto|eapply ap_ran]...
    unfold F in Hp. rewrite Hdm, Hcdn in Hp...
    assert (âˆ€x âˆˆ â¨a[m]â¬, (G[m] âˆª â¨<a[m], add G[m]>â¬)[x] = â¨<a[m], add G[m]>â¬[x]). {
      assert (G[m]: aâŸ¦mâŸ§ âŸº ran G[m]). split...
      eapply add_point_func_ap...
      apply Hdj1... eapply Hdj2... split...
    }
    rewrite H, single_pair_ap in Hp...
    eapply Hout... split... rewrite <- Hp.
    eapply ranI. apply func_correct...
  }
  assert (HinGn: âˆ€n âˆˆ Ï‰, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦mâŸ§, (G[m])[x] = (G[n])[x]). {
    intros n Hn.
    set {n âˆŠ Ï‰ | Î» n, âˆ€k âˆˆ n, âˆ€x âˆˆ aâŸ¦kâŸ§, G[k][x] = G[n][x]} as N.
    Ï‰_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [].
    - rewrite IH... apply HinG...
      apply imgE in Hx as [l [Hl Hp]].
      apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in H; subst k. apply HinG...
  }
  assert (HoutGn: âˆ€n âˆˆ Ï‰, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, (G[n])[x] âˆ‰ ran G[m]). {
    intros n Hn.
    set {n âˆŠ Ï‰ | Î» n, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, G[n][x] âˆ‰ ran G[m]} as N.
    Ï‰_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [Hkm|Hkm].
    assert (Hk: k âˆˆ Ï‰). eapply Ï‰_trans...
    pose proof (HiGn k Hk) as [[[Hfk _] [Hdk _]] _].
    pose proof (HiGn m Hm) as [[[Hfm _] [Hdm _]] _].
    + apply SepE in Hx as [Hx Hx']. rewrite Himg in Hx...
      apply BUnionE in Hx as [Hx|Hx].
      * assert (x âˆˆ aâŸ¦mâŸ§ - aâŸ¦kâŸ§). apply SepI...
        apply IH in H... intros H1. apply H.
        apply ranE in H1 as [w Hp]. apply domI in Hp as Hw.
        apply func_ap in Hp... rewrite HinG...
        apply (ranI _ w). rewrite <- Hp. apply func_correct...
      * apply SingE in Hx; subst x. intros H. apply (HoutG m)...
        apply ranE in H as [x Hp]. apply domI in Hp as Hx.
        apply func_ap in Hp... rewrite <- Hp.
        apply (ranI _ x). rewrite (HinGn m)...
        apply func_correct... rewrite Hdk in Hx. rewrite Hdm.
        apply imgE in Hx as [l [Hl Ha]].
        apply (imgI _ _ l)... eapply nat_trans...
    + apply SingE in Hkm; subst k.
      rewrite img_comp_distr in Hx; [|apply Hia].
      rewrite suc_comp, img_single in Hx...
      apply SingE in Hx; subst. apply HoutG...
  }
  exists G. split; [|split]; [apply HG..|intros n Hn].
  pose proof (HiGn n Hn) as [[Hi [Hd Hr]] Hop].
  unfold op in Hop. rewrite Hd in Hop.
  rewrite HeqT, subRel_absorption in Hop...
  split. split... split... eapply sub_tran...
  split... split. apply HinGn... apply HoutGn...
Qed.

(* æœ‰é™åŒæ„æ˜ å°„çš„å¹¶ *)
Local Lemma sup_finite_isomorphisms :
  âˆ€ A R a, a: Ï‰ âŸº A â†’ loset A R â†’ 
  âˆ€ B S, Ï‰ â‰ˆ B â†’ loset B S â†’ dense S â†’
  âˆƒ f, f: A â‡” B âˆ§ âˆ€ x y âˆˆ A, (x <áµ£ y) R â†” (f[x] <áµ£ f[y]) (S â¥ ran f).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S HqnB HloS HdnS.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  pose proof (ex_enumeration_of_all_finite_isomorphisms)
    as [G [HfG [HdG Hstar]]]...
  set (sup{ap G | n âˆŠ Ï‰}) as f.
  assert (HG: âˆ€p âˆˆ f, âˆƒn âˆˆ Ï‰, p âˆˆ G[n]). {
    intros p Hp. apply UnionAx in Hp as [y [Hy Hp]].
    apply ReplAx in Hy as [n [Hn Hap]]. subst y.
    exists n. split...
  }
  assert (Hf: f: A â‡” B). {
    split; split.
    - (* is_function f *)
      split. intros p Hp.
      apply HG in Hp as [n [Hn Hp]]. apply (Hstar n Hn)...
      intros x Hx. split. apply domE in Hx...
      intros y1 y2 H1 H2.
      apply HG in H1 as [n [Hn H1]].
      apply HG in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 _]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 _]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y1 y2.
      destruct (classic (m = n))...
      apply nat_connected in H as []...
      symmetry. apply Hin1... apply Hin2...
    - (* single_rooted f *)
      intros y Hy. split. apply ranE in Hy...
      intros y1 y2 H1 H2.
      apply HG in H1 as [n [Hn H1]].
      apply HG in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 Hout1]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 Hout2]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y.
      destruct (classic (m = n)). eapply injectiveE...
      apply nat_connected in H as []...
      + destruct (classic (y1 âˆˆ aâŸ¦mâŸ§)).
        * rewrite <- Hin1 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout1 m H y1).
          apply SepI... rewrite <- H2. eapply ranI.
          apply func_correct... apply Hi2.
      + destruct (classic (y2 âˆˆ aâŸ¦nâŸ§)).
        * rewrite <- Hin2 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout2 n H y2).
          apply SepI... rewrite H2. eapply ranI.
          apply func_correct... apply Hi1.
    - (* dom f = A *)
      apply ExtAx. split; intros Hx.
      + apply domE in Hx as [y Hp].
        apply HG in Hp as [n [Hn Hp]]. apply domI in Hp.
        pose proof (Hstar n Hn) as [[_ [Hd _]] _].
        rewrite Hd in Hp. apply imgE in Hp as [k [Hk Hak]].
        apply func_ap in Hak... subst x.
        eapply ap_ran... eapply Ï‰_trans...
      + set (aâ»Â¹[x]) as n.
        assert (Hnp: nâº âˆˆ Ï‰). {
          apply Ï‰_inductive. eapply ap_ran...
          apply bijection_is_func. apply inv_bijection...
        }
        pose proof (Hstar nâº Hnp) as [[[Hf _] [Hd _]] _].
        apply (domI _ _ G[nâº][x]).
        apply UnionAx. exists (G[nâº]). split. eapply ReplI...
        apply func_correct... rewrite Hd.
        apply (imgI _ _ n)... rewrite inv_op.
        apply func_correct. apply inv_func_iff_sr.
        apply Hia. rewrite inv_dom...
    - (* ran f âŠ† B *)
      intros y Hy. apply ranE in Hy as [x Hp].
      apply HG in Hp as [n [Hn Hp]]. apply domI in Hp as Hx.
      pose proof (Hstar n Hn) as [[[Hf _] [Hd Hr]] _].
      apply func_ap in Hp... subst y.
      eapply ap_ran... split...
  }
  assert (Hap: âˆ€x âˆˆ A, âˆƒn âˆˆ Ï‰, <x, f[x]> âˆˆ G[n]). {
    intros x Hx. destruct Hf as [[Hf _] [Hd _]].
    apply HG... apply func_correct...
  }
  exists f. split...
  intros x Hx y Hy.
  apply Hap in Hx as [n [Hn H1]]. apply domI in H1 as Hx.
  apply Hap in Hy as [m [Hm H2]]. apply domI in H2 as Hy.
  pose proof (Hstar n Hn) as [[[Hf1 _] [Hd1 _]] [Hop1 [Hin1 Hout1]]].
  pose proof (Hstar m Hm) as [[[Hf2 _] [Hd2 _]] [Hop2 [Hin2 _]]].
  apply func_ap in H1... rewrite <- H1.
  apply func_ap in H2... rewrite <- H2.
  destruct (classic (n = m)). {
    subst m. split; intros Hlt.
    - apply Hop1 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[n]);
      (split; [eapply ReplI|apply func_correct])...
    - apply Hop1... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
  }
  apply nat_connected in H as []...
  - assert (Hxm: x âˆˆ aâŸ¦mâŸ§). {
      rewrite Hd1 in Hx. apply imgE in Hx as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite Hin2... split; intros Hlt.
    + apply Hop2 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[m]);
      (split; [eapply ReplI|apply func_correct])...
    + apply Hop2... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
  - assert (Hyn: y âˆˆ aâŸ¦nâŸ§). {
      rewrite Hd2 in Hy. apply imgE in Hy as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite (Hin1 m H)... split; intros Hlt.
    + apply Hop1 in Hlt... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply UnionAx; exists (G[n]);
      (split; [eapply ReplI|apply func_correct])...
    + apply Hop1... apply SepE1 in Hlt. apply SepI...
      apply CProdI; eapply ranI; apply func_correct...
Qed.

(* å¯æ•°æ— ç©·çº¿åºé›†ä¸å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†çš„å­é›†åŒæ„ *)
Lemma infinite_loset_iso_subset_of_dense_infinite_loset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ âˆ€ T, Ï‰ â‰ˆ A T â†’ dense (R T) â†’
  âˆƒ T', T' âŠ‘ T âˆ§ S â‰… T'.
Proof with eauto.
  intros S [a Hba] T HqnT Hdn.
  assert (Hf: âˆƒ f, f: A S â‡” A T âˆ§ âˆ€ x y âˆˆ A S,
    (x <áµ£ y) (R S) â†” (f[x] <áµ£ f[y]) (R T â¥ ran f)). {
    eapply sup_finite_isomorphisms...
  }
  destruct Hf as [f [Hf Hop]].
  assert (H := Hf). destruct H as [Hif [Hd Hr]].
  set (ran f) as B.
  assert (Hlo: loset B (R T â¥ B)). {
    apply (subRel_loset (A T))...
  }
  set (constr B (R T â¥ B) Hlo) as T'.
  exists T'. repeat split... exists f. split... split...
Qed.

(* å¯æ•°æ— ç©·çº¿åºé›†ä¸æ— ç©·ç¨ å¯†çº¿åºé›†çš„å­é›†åŒæ„ *)
Theorem countable_loset_iso_subset_of_dense_loset :
  âˆ€ S T, countable (A S) â†’ Ï‰ â‰ˆ (A T) â†’ dense (R T) â†’
  âˆƒ T', T' âŠ‘ T âˆ§ S â‰… T'.
Proof with auto.
  intros S T Hcnt Hqn Hdn.
  apply countable_iff in Hcnt as [Hfin|Hinf].
  - apply finite_loset_iso_subset_of_dense_infinite_loset...
  - apply infinite_loset_iso_subset_of_dense_infinite_loset... symmetry... 
Qed.

(* ex8_17 å¯æ•°æ— ç©·çº¿åºé›†ä¸æœ‰ç†æ•°é›†çš„å­é›†åŒæ„ *)
(* The assumption in the textbook about being dense seems to be redundant *)
Corollary countable_loset_iso_subset_of_rat :
  âˆ€ S, countable (A S) â†’
  âˆƒ T, A T âŠ† â„š âˆ§ R T = RatLt â¥ A T âˆ§ S â‰… T.
Proof with auto.
  intros S Hcnt.
  set (constr â„š RatLt ratLt_linearOrder) as Q.
  pose proof (countable_loset_iso_subset_of_dense_loset S Q)
    as [Q' [[Hsub Hrel] Hiso]]...
  - apply CardAx1. symmetry. apply card_rat_eq_aleph0.
  - apply ratLt_dense.
  - exists Q'. repeat split...
Qed.

End EX8_17.
