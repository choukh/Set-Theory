(** Coq coding by choukh, Mar 2021 **)

Require Import ZFC.EST8_4.
Require Import ZFC.EX7_1.
Require Import ZFC.lib.NatIsomorphism.
Require Import ZFC.lib.FuncFacts.
Require Import ZFC.lib.Real.
Require Import ZFC.lib.LoStruct.
Require Import ZFC.lib.WosetMin.
Require Import ZFC.lib.IndexedFamilyUnion.

(** EX8_17 **)

(* æ— ç•Œåº *)
Definition left_unbounded  := Î» A R, âˆ€x âˆˆ A, âˆƒw âˆˆ A, (w <áµ£ x) R.
Definition right_unbounded := Î» A R, âˆ€x âˆˆ A, âˆƒy âˆˆ A, (x <áµ£ y) R.
Definition unbounded := Î» A R, left_unbounded A R âˆ§ right_unbounded A R.

(* æœ‰ç†æ•°çš„åºæ˜¯æ— ç•Œåº *)
Fact ratLt_unbounded : unbounded â„š RatLt.
Proof with auto.
  split; intros x Hx.
  - pose proof (rat_archimedean (-x)%q) as [w [Hw Hxw]].
    apply ratAddInv_ran...
    exists (-w)%q. split. apply ratAddInv_ran...
    apply ratLt_addInv... apply ratAddInv_ran...
    rewrite ratAddInv_double...
  - pose proof (rat_archimedean x Hx) as [y [Hy Hxy]].
    exists y. split...
Qed.

(* ç¨ å¯†åº *)
Definition dense := Î» R, âˆ€ x z, (x <áµ£ z) R â†’ âˆƒ y, (x <áµ£ y) R âˆ§ (y <áµ£ z) R.

(* æœ‰ç†æ•°çš„åºæ˜¯ç¨ å¯†åº *)
Fact ratLt_dense : dense RatLt.
Proof with auto.
  intros x z Hxz.
  apply binRelE2 in Hxz as H. destruct H as [Hx [Hz _]].
  apply rat_dense in Hxz as [y [Hy [Hxy Hyz]]]...
  exists y. split...
Qed.

(* æœ‰é™çº¿åºä¸æŸä¸ªè‡ªç„¶æ•°åŒæ„ *)
Lemma finite_loset_iso_nat : âˆ€ S, finite (A S) â†’
  âˆƒ T, T âŠ‘ ğ›š âˆ§ A T âˆˆ Ï‰ âˆ§ S â‰… T.
Proof with eauto.
  intros S Hfin.
  assert (H := Hfin). destruct Hfin as [n [Hn Hqn]].
  assert (HloT: loset n (Lt â¥ n)). {
    eapply subRel_loset. apply Lt_wellOrder.
    apply trans_sub... apply Ï‰_trans.
  }
  assert (HwoS: woset (A S) (R S)). apply finite_loset_is_woset...
  set (WoStruct.constr (A S) (R S) HwoS) as SÊ·.
  set (LoStruct.constr n (Lt â¥ n) HloT) as T.
  Import WoStruct.
  Import WoStruct.EpsilonImageOfNats.
  set (Seg n ğ›š) as TÊ·.
  assert (Hiso: SÊ· â‰… TÊ·). {
    apply ord_well_defined.
    rewrite finite_ord_eq_card... simpl.
    apply CardAx1 in Hqn.
    rewrite Hqn, <- (card_of_nat n)...
    symmetry. apply Î±_nat...
  }
  destruct Hiso as [f [Hf Hop]]. unfold TÊ· in Hf.
  rewrite seg_a_eq, seg_of_nat in Hf...
  assert (Hsub: n âŠ† Ï‰). apply trans_sub... apply Ï‰_trans.
  assert (Hlo: loset n (Lt â¥ n)). {
    eapply subRel_loset... apply Lt_wellOrder.
  }
  exists T. repeat split... exists f. split...
  apply bijection_is_func in Hf as [Hf _].
  intros x Hx y Hy. split; intros Hlt.
  - apply Hop in Hlt... apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran...
  - apply Hop... apply SepE1 in Hlt. apply seg_lt... apply SepI.
    + apply CProdI... apply (Ï‰_trans _ n)... eapply ap_ran...
    + zfc_simple. eapply ap_ran...
Qed.

Import LoStruct.
Import SimpleVer.

(* å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†æœ‰å¯æ•°æ— ç©·ç¨ å¯†æ— ç•Œå­é›† *)
Lemma countable_dense_loset_has_unbounded_subset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ dense (R S) â†’ âˆƒ T, T âŠ‘ S âˆ§
    Ï‰ â‰ˆ A T âˆ§ dense (R T) âˆ§ unbounded (A T) (R T).
Proof with neauto; try congruence.
  intros S [a Hba] Hdn.
  destruct (lo S) as [Hbr [Htr _]].
  assert (Hir: irrefl (R S)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  cut ((âˆƒ x y âˆˆ A S, (x <áµ£ y) (R S)) â†’ âˆƒ T, T âŠ‘ S âˆ§
    Ï‰ â‰ˆ A T âˆ§ dense (R T) âˆ§ unbounded (A T) (R T)). {
    destruct (classic (a[0] = a[1])) as [|Hnq]. {
      exfalso. apply injectiveE in H...
      rewrite Hda... rewrite Hda...
    }
    assert (Ha0: a[0] âˆˆ A S). eapply ap_ran...
    assert (Ha1: a[1] âˆˆ A S). eapply ap_ran...
    intros H. apply (lo_connected (R S) (A S) (lo S)) in Hnq as []...
    - apply H. exists (a[0]). split... exists (a[1]). split...
    - apply H. exists (a[1]). split... exists (a[0]). split...
  }
  intros [c [HcA [d [HdA Hcd]]]].
  apply Hdn in Hcd as [e [Hcd Hed]].
  apply Hbr in Hed as HeA. apply CProdE2 in HeA as [HeA _].
  set {x âˆŠ A S | Î» x, (c <áµ£ x) (R S) âˆ§ (x <áµ£ d) (R S)} as C.
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (c <áµ£ a[n]) (R S) âˆ§ (a[n] <áµ£ x) (R S)}) as Nâ‚—.
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (x <áµ£ a[n]) (R S) âˆ§ (a[n] <áµ£ d) (R S)}) as Náµ£.
  set (Î» x, (Min Lt)[Nâ‚— x]) as mâ‚—.
  set (Î» x, (Min Lt)[Náµ£ x]) as máµ£.
  set (Func C C (Î» x, a[mâ‚— x])) as fâ‚—.
  set (Func C C (Î» x, a[máµ£ x])) as fáµ£.
  assert (HeC: e âˆˆ C). apply SepI...
  assert (Hmâ‚—: âˆ€x âˆˆ C, mâ‚— x âˆˆ Ï‰ âˆ§ (c <áµ£ a[mâ‚— x]) (R S) âˆ§ (a[mâ‚— x] <áµ£ x) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (Ï‰_min (Nâ‚— x)) as [H _]. {
      apply Hdn in Hcx as [y [Hcy Hyx]].
      apply Hbr in Hyx as Hy. apply CProdE2 in Hy as [Hy _].
      exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (mâ‚— x) in H. apply SepE in H as [Hm [Hcm Hmx]]. split...
  }
  assert (Hmáµ£: âˆ€x âˆˆ C, máµ£ x âˆˆ Ï‰ âˆ§ (x <áµ£ a[máµ£ x]) (R S) âˆ§ (a[máµ£ x] <áµ£ d) (R S)). {
    intros x Hx.
    apply SepE in Hx as [Hx [Hcx Hxd]].
    pose proof (Ï‰_min (Náµ£ x)) as [H _]. {
      apply Hdn in Hxd as [y [Hxy Hyd]].
      apply Hbr in Hyd as Hy. apply CProdE2 in Hy as [Hy _].
      exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A S))...
      apply bijection_is_func. apply inv_bijection...
      rewrite inv_ran_reduction...
    } {
      apply SepE1.
    }
    fold (máµ£ x) in H. apply SepE in H as [Hm [Hxm Hmd]]. split...
  }
  assert (Hfâ‚—: fâ‚—: C â‡’ C). {
    apply meta_function. intros x Hx.
    apply Hmâ‚— in Hx as H. destruct H as [Hm [Hcm Hmx]].
    apply SepE2 in Hx as [_ Hxd].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  assert (Hfáµ£: fáµ£: C â‡’ C). {
    apply meta_function. intros x Hx.
    apply Hmáµ£ in Hx as H. destruct H as [Hm [Hxm Hmd]].
    apply SepE2 in Hx as [Hcx _].
    apply SepI. eapply ap_ran... split... eapply relLt_tranr...
  }
  pose proof (Ï‰_recursion fâ‚— C e Hfâ‚— HeC) as [hâ‚— [Hhâ‚— [Hhâ‚—0 Hhâ‚—n]]].
  pose proof (Ï‰_recursion fáµ£ C e Hfáµ£ HeC) as [háµ£ [Hháµ£ [Hháµ£0 Hháµ£n]]].
  set {x âˆŠ A S | Î» x, âˆƒn âˆˆ Ï‰, (hâ‚—[n] â‰¤áµ£ x) (R S) âˆ§ (x â‰¤áµ£ háµ£[n]) (R S)} as B.
  assert (HBA: B âŠ† A S). apply SepE1.
  assert (HCA: C âŠ† A S). apply SepE1.
  assert (Hdesc: âˆ€x âˆˆ C, (fâ‚—[x] <áµ£ x) (R S)). {
    intros x Hx. unfold fâ‚—. rewrite meta_func_ap... apply Hmâ‚—...
  }
  assert (Hasc: âˆ€x âˆˆ C, (x <áµ£ fáµ£[x]) (R S)). {
    intros x Hx. unfold fáµ£. rewrite meta_func_ap... apply Hmáµ£...
  }
  assert (Hmonoâ‚—: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (hâ‚—[m] <áµ£ hâ‚—[n]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (hâ‚—[k] <áµ£ hâ‚—[n]) (R S)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhâ‚—n... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hdesc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hdesc... eapply ap_ran...
  }
  assert (Hmonoáµ£: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (háµ£[n] <áµ£ háµ£[m]) (R S)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (háµ£[n] <áµ£ háµ£[k]) (R S)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hháµ£n... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m.
      apply Hasc... eapply ap_ran...
  }
  assert (Hihâ‚—: hâ‚— : Ï‰ â‡” B). {
    destruct Hhâ‚— as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoâ‚— in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: xâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists x. split... split; [right|]...
      Ï‰_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
      + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
  }
  assert (Hiháµ£: háµ£ : Ï‰ â‡” B). {
    destruct Hháµ£ as [Hf [Hd Hr]].
    split; split...
    - intros y Hy. split. apply ranE in Hy...
      intros x1 x2 H1 H2.
      apply domI in H1 as Hx1. rewrite Hd in Hx1.
      apply domI in H2 as Hx2. rewrite Hd in Hx2.
      apply func_ap in H1...
      apply func_ap in H2...
      destruct (classic (x1 = x2))... exfalso.
      apply nat_connected in H as []; auto;
      apply Hmonoáµ£ in H; auto; rewrite H1, H2 in H; eapply Hir...
    - intros y Hy. apply ranE in Hy as [x Hp].
      apply domI in Hp as Hx. rewrite Hd in Hx.
      apply func_ap in Hp... subst y. apply SepI.
      apply HCA. apply Hr. eapply ranI. apply func_correct...
      assert (Hxp: xâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists x. split... split; [|right]...
      Ï‰_destruct x; subst x; [right|left]...
      apply (relLt_tranr _ e)...
      + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
      + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
  }
  assert (Hlo: loset B (R S â¥ B)). eapply subRel_loset...
  set (constr B (R S â¥ B) Hlo) as T.
  exists T. split... split... split; [|split].
  - (* Ï‰ â‰ˆ A T *)
    apply SchrÃ¶eder_Bernstein.
    + exists hâ‚—...
    + assert (A S â‰ˆ Ï‰). symmetry. exists a...
      apply dominate_sub in HBA.
      eapply dominate_rewrite_r...
  - (* dense (R T) *)
    intros x y Hxy. apply SepE in Hxy as [Hxy H].
    apply CProdE2 in H as [Hx Hy].
    apply Hdn in Hxy as [z [Hxz Hzy]].
    cut (z âˆˆ B). {
      intros Hz. exists z; split;
      apply SepI; auto; apply CProdI...
    }
    apply Hbr in Hzy as H.
    apply CProdE2 in H as [Hz _]. apply SepI...
    apply SepE2 in Hx as [n [Hn [Hnx Hxn]]].
    apply SepE2 in Hy as [m [Hm [Hmy Hym]]].
    destruct (classic (n = m)). {
      subst m. exists n. split... split; left.
      eapply relLe_lt_tranr; revgoals...
      eapply relLt_le_tranr...
    }
    apply nat_connected in H as [Hnm|Hmn]...
    + apply Hmonoâ‚— in Hnm...
      exists m. split... split; left.
      * eapply relLe_lt_tranr; revgoals... left.
        eapply relLt_le_tranr...
      * eapply relLt_le_tranr...
    + apply Hmonoáµ£ in Hmn...
      exists n. split... split; left.
      * eapply relLe_lt_tranr...
      * eapply relLe_lt_tranr... left.
        eapply relLt_le_tranr...
  - (* unbounded (A T) (R T)) *)
    destruct (lo T) as [_ [Htr' _]].
    split; intros x Hx. {
      assert (H := Hx). apply SepE2 in H as [n [Hn [Hnx Hxn]]].
      destruct Hihâ‚— as [[Hf _] [Hd Hr]].
      assert (Hnp: nâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists (hâ‚—[nâº]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists nâº. split... split; [right|left]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
        + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
      - apply (relLt_le_tranr _ (hâ‚—[n]))...
        + apply SepI. apply Hmonoâ‚—...
          apply CProdI; eapply ap_ran; eauto; split...
        + destruct Hnx; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
    } {
      assert (H := Hx). apply SepE2 in H as [n [Hn [Hnx Hxn]]].
      destruct Hiháµ£ as [[Hf _] [Hd Hr]].
      assert (Hnp: nâº âˆˆ Ï‰). apply Ï‰_inductive...
      exists (háµ£[nâº]). split.
      - apply SepI. apply HBA. apply Hr.
        eapply ranI. apply func_correct... 
        exists nâº. split... split; [left|right]...
        apply (relLt_tranr _ e)...
        + rewrite <- Hhâ‚—0. apply Hmonoâ‚—... apply suc_has_0...
        + rewrite <- Hháµ£0. apply Hmonoáµ£... apply suc_has_0...
      - apply (relLe_lt_tranr _ (háµ£[n]))...
        + destruct Hxn; [left|right]... apply SepI...
          apply CProdI... eapply ap_ran... split...
        + apply SepI. apply Hmonoáµ£...
          apply CProdI; eapply ap_ran; eauto; split...
    }
Qed.

(* å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›†æœ‰å¯æ•°æ— ç©·è‰¯åºå­é›† *)
Lemma countable_dense_loset_has_wo_subset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ dense (R S) â†’ âˆƒ T, T âŠ‘ S âˆ§ ğ›š â‰… T.
Proof with neauto; try congruence.
  intros S Hqn Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset
    S Hqn Hdn) as [T [[Hsub Hrel] [[a Hba] [_ [Hul Hur]]]]].
  destruct (lo T) as [_ [Htr _]].
  assert (Hir: irrefl (R T)). eapply lo_irrefl... apply lo.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (Î» x, {n âˆŠ Ï‰ | Î» n, (x <áµ£ a[n]) (R S)}) as M.
  set (Î» x, (Min Lt)[M x]) as m.
  set (Func (A T) (A T) (Î» x, a[m x])) as f.
  assert (Hmx: âˆ€x âˆˆ A T, m x âˆˆ Ï‰ âˆ§ (x <áµ£ a[m x]) (R S)). {
    intros x Hx.
    cut (m x âˆˆ M x). intros H. apply SepE in H...
    apply Ï‰_min; [|apply SepE1].
    apply Hur in Hx as [y [Hy Hxy]].
    rewrite Hrel in Hxy. apply SepE1 in Hxy.
    exists (aâ»Â¹[y]). apply SepI. apply (ap_ran (A T))...
    apply bijection_is_func. apply inv_bijection...
    rewrite inv_ran_reduction...
  }
  assert (Hf: f: A T â‡’ A T). {
    apply meta_function. intros x Hx.
    eapply ap_ran... apply Hmx...
  }
  assert (Ha0: a[0] âˆˆ A T). eapply ap_ran...
  pose proof (Ï‰_recursion f (A T) (a[0]) Hf Ha0) as [h [Hh [Hh0 Hhn]]].
  assert (Hasc: âˆ€x âˆˆ A T, (x <áµ£ f[x]) (R T)). {
    intros x Hx. unfold f. rewrite meta_func_ap, Hrel...
    apply SepI. apply Hmx... apply CProdI...
    eapply ap_ran... apply Hmx...
  }
  assert (Hmono: âˆ€ n m âˆˆ Ï‰, n âˆˆ m â†’ (h[n] <áµ£ h[m]) (R T)). {
    intros n Hn k Hk Hnk.
    generalize dependent n.
    set {k âˆŠ Ï‰ | Î» k, âˆ€ n, n âˆˆ Ï‰ â†’ n âˆˆ k â†’ (h[n] <áµ£ h[k]) (R T)} as N.
    Ï‰_induction N Hk; intros n Hn Hnm. exfalso0.
    rewrite Hhn... apply BUnionE in Hnm as [].
    - apply IH in H... eapply relLt_tranr...
      apply Hasc... eapply ap_ran...
    - apply SingE in H; subst m0.
      apply Hasc... eapply ap_ran...
  }
  assert (Hop: âˆ€ n m âˆˆ Ï‰, (h[n] <áµ£ h[m]) (R T) â†’ n âˆˆ m). {
    intros n Hn k Hk Hnk.
    destruct (classic (n = k)).
    - subst k. exfalso. eapply relLt_irrefl...
    - apply nat_connected in H as []...
      apply Hmono in H... exfalso.
      eapply relLt_irrefl... eapply relLt_tranr...
  }
  assert (Hbh: h: Ï‰ âŸº ran h). {
    destruct Hh as [Hfh [Hd Hr]].
    split; split...
    intros y Hy. split. apply ranE in Hy...
    intros x1 x2 H1 H2.
    apply domI in H1 as Hx1. rewrite Hd in Hx1.
    apply domI in H2 as Hx2. rewrite Hd in Hx2.
    apply func_ap in H1...
    apply func_ap in H2...
    destruct (classic (x1 = x2))... exfalso.
    apply nat_connected in H as []; auto;
    apply Hmono in H; auto; rewrite H1, H2 in H; eapply Hir...
  }
  assert (Hsub': ran h âŠ† A S). {
    destruct Hh as [_ [_ Hr]]. eapply sub_tran...
  }
  assert (Hlo: loset (ran h) (R S â¥ ran h)). {
    eapply subRel_loset...
  }
  set (constr (ran h) (R S â¥ ran h) Hlo) as U.
  exists U. split. split... exists h. split... simpl.
  intros x Hx y Hy. split; intros Hlt.
  - apply binRelE3 in Hlt.
    apply Hmono in Hlt... rewrite Hrel in Hlt.
    apply SepE1 in Hlt. apply SepI...
    apply CProdI; eapply ap_ran; eauto; apply bijection_is_func...
  - apply SepE1 in Hlt. apply SepI. apply CProdI...
    zfc_simple. apply Hop... rewrite Hrel. apply SepI...
    apply CProdI; eapply ap_ran...
Qed.

(* æœ‰é™çº¿åºé›†å¯åµŒå…¥å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›† *)
Lemma finite_loset_embeddable_in_dense_infinite_loset :
  âˆ€ S, finite (A S) â†’ âˆ€ T, Ï‰ â‰ˆ A T â†’ dense (R T) â†’
  âˆƒ U, U âŠ‘ T âˆ§ S â‰… U.
Proof with eauto; try congruence.
  intros S Hfin T Hqn Hdn.
  pose proof (finite_loset_iso_nat S Hfin)
    as [S' [[HsubS HrS] [Hn [f [Hf Hopf]]]]].
  pose proof (countable_dense_loset_has_wo_subset T Hqn Hdn)
    as [T' [[HsubT HrT] [g [Hg Hopg]]]].
  simpl in *.
  set (A S') as n.
  set ((g â†¾ n) âˆ˜ f) as h.
  assert (Hg': g â†¾ n: n âŸº gâŸ¦nâŸ§). eapply restr_bijection...
  assert (Hh: h: A S âŸº gâŸ¦nâŸ§). eapply compo_bijection...
  assert (Hsub: gâŸ¦nâŸ§ âŠ† A T). {
    eapply sub_tran; revgoals...
    destruct Hg as [_ [_ Hr]]. rewrite <- Hr.
    apply img_included.
  }
  assert (Hlo: loset (gâŸ¦nâŸ§) (R T â¥ gâŸ¦nâŸ§)). eapply subRel_loset...
  set (constr (gâŸ¦nâŸ§) (R T â¥ gâŸ¦nâŸ§) Hlo) as U.
  exists U. repeat split... exists h. split...
  destruct Hf as [[Hff _] [Hdf Hdr]].
  destruct Hg as [[Hfg _] [Hdg Hrg]].
  destruct Hg' as [[Hfg' _] _].
  assert (Hfx: âˆ€x âˆˆ A S, f[x] âˆˆ n). {
    intros x Hx. unfold n. rewrite <- Hdr.
    eapply ranI. apply func_correct...
  }
  assert (Hd: âˆ€x âˆˆ A S, x âˆˆ dom ((g â†¾ n) âˆ˜ f)). {
    intros x Hx. rewrite compo_dom... apply SepI...
    assert (dom (g â†¾ n) = n). apply restr_dom... rewrite Hdg...
    rewrite H. apply Hfx...
  }
  intros x Hx y Hy.
  apply Hfx in Hx as Hfx0. apply Hfx in Hy as Hfy.
  apply Hd in Hx as Hdx. apply Hd in Hy as Hdy.
  assert (HfxÏ‰: f[x] âˆˆ Ï‰). eapply Ï‰_trans...
  assert (HfyÏ‰: f[y] âˆˆ Ï‰). eapply Ï‰_trans...
  unfold h. rewrite compo_correct, compo_correct...
  rewrite restr_ap, restr_ap...
  split; intros Hlt.
  - apply Hopf in Hlt...
    rewrite HrS in Hlt. apply SepE1 in Hlt.
    apply Hopg in Hlt; [|apply HsubS; apply Hfx..]...
    rewrite HrT in Hlt. apply SepE1 in Hlt.
    apply SepI... apply CProdI.
    + apply (imgI _ _ (f[x]))... apply func_correct...
    + apply (imgI _ _ (f[y]))... apply func_correct...
  - apply Hopf... rewrite HrS. apply SepI; [|apply CProdI..]...
    apply Hopg... rewrite HrT. apply SepI... apply SepE1 in Hlt...
    apply CProdI; rewrite <- Hrg; eapply ranI; apply func_correct...
Qed.

Import FullVer.

(* æœ‰é™çº¿åºçš„æœ€å€¼ *)
Definition FinLoMax := Î» R B, (Min B (R â¥ B)â»Â¹) [B].
Definition FinLoMin := Î» R B, (Min B (R â¥ B)) [B].

Lemma finite_loset_has_max : âˆ€ A R B, loset A R â†’
  B â‰  âˆ… â†’ B âŠ† A â†’ finite B â†’ maximum (FinLoMax R B) B (R â¥ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin. apply maximum_iff_minimum_inv.
  apply min_correct... apply finite_loset_is_woset...
  apply inv_lo... eapply subRel_loset... apply EmptyNE...
Qed.

Lemma finite_loset_has_min : âˆ€ A R B, loset A R â†’
  B â‰  âˆ… â†’ B âŠ† A â†’ finite B â†’ minimum (FinLoMin R B) B (R â¥ B).
Proof with eauto.
  intros A R B Hlo Hne Hsub Hfin.
  apply min_correct... apply finite_loset_is_woset...
  eapply subRel_loset... apply EmptyNE...
Qed.

Lemma card_of_img_of_enumeration :
  âˆ€ A f, f: Ï‰ âŸº A â†’ âˆ€n âˆˆ Ï‰, |fâŸ¦nâŸ§| = n.
Proof with eauto.
  intros A f Hbi n Hn. rewrite (card_of_nat n) at 2...
  apply CardAx1. symmetry. exists (f â†¾ n).
  eapply restr_bijection; revgoals...
  apply trans_sub... apply Ï‰_trans.
Qed.

Lemma img_0 : âˆ€ f, fâŸ¦âˆ…âŸ§ = âˆ….
Proof.
  intros f. apply ExtAx. split; intros Hx; [|exfalso0].
  apply imgE in Hx as [w [Hw _]]. exfalso0.
Qed.

Lemma img_suc : âˆ€ f, is_function f â†’ dom f = Ï‰ â†’
  âˆ€n âˆˆ Ï‰, fâŸ¦nâºâŸ§ = fâŸ¦nâŸ§ âˆª â¨f[n]â¬.
Proof with auto.
  intros f Hf Hd n Hn. replace â¨f[n]â¬ with (fâŸ¦â¨nâ¬âŸ§).
  apply img_bunion_distr.
  apply ExtAx. split; intros Hx.
  - apply imgE in Hx as [w [Hw Hp]]. apply SingE in Hw; subst.
    apply func_ap in Hp... subst x...
  - apply SingE in Hx; subst. apply (imgI _ _ n)...
    apply func_correct... congruence.
Qed.

Import SimpleVer.

(* å¯¹ä»»æ„å¯æ•°æ— ç©·çº¿åºé›†Aå’ŒBï¼Œå¦‚æœBæ— ç•Œç¨ å¯†ï¼Œ
  é‚£ä¹ˆå­˜åœ¨ä»¥Ï‰ä¸ºå®šä¹‰åŸŸçš„å‡½æ•°Fä½œä¸ºä»Aåˆ°Bçš„éƒ¨åˆ†åµŒå…¥çš„æšä¸¾ *)
(* For any countably infinite loset A and B, if B is unbounded and dense,
  then there exists a function F with domain Ï‰ as the enumeration of
  all partial embeddings from A to B *)
Lemma enumeration_of_partial_embeddings :
  âˆ€ A R a, a: Ï‰ âŸº A â†’ loset A R â†’
  âˆ€ B S, Ï‰ â‰ˆ B â†’ loset B S â†’ unbounded B S â†’ dense S â†’
  âˆƒ G, is_function G âˆ§ dom G = Ï‰ âˆ§ âˆ€n âˆˆ Ï‰, G[n]: aâŸ¦nâŸ§ â‡” B âˆ§
    (âˆ€ x y âˆˆ aâŸ¦nâŸ§, (x <áµ£ y) R â†” (G[n][x] <áµ£ G[n][y]) S) âˆ§
    (âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦mâŸ§, G[m][x] = G[n][x]) âˆ§
    (âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, G[n][x] âˆ‰ ran G[m]).
Proof with neauto; try congruence.
  intros A R a Hba HloR B S [b Hbb] HloS [Hul Hur] HdnS.
  assert (H := HloR). destruct H as [_ [HtrR _]].
  assert (HirR: irrefl R). eapply lo_irrefl...
  assert (H := HloS).  destruct H as [Hbr [HtrS _]].
  assert (HirS: irrefl S). eapply lo_irrefl...
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hbb). apply bijection_is_func in H as [Hmb [Hib Hrb]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  set (Î» f, âˆ€ x y âˆˆ dom f, (x <áµ£ y) R â†” (f[x] <áµ£ f[y]) S) as op.
  set (â‹ƒ{Î» X, X âŸ¶ B | X âˆŠ ğ’« A}) as fs0.
  set {f âˆŠ fs0 | Î» f, (âˆƒn âˆˆ Ï‰, f: aâŸ¦nâŸ§ â‡” B) âˆ§ op f} as fs.
  set (Î» f, {y âˆŠ dom f | Î» y, (y <áµ£ a[|dom f|]) R}) as ğ‹.
  set (Î» f, {y âˆŠ dom f | Î» y, (a[|dom f|] <áµ£ y) R}) as ğ‘.
  set (Î» f, FinLoMax R (ğ‹ f)) as aâ‚—.
  set (Î» f, FinLoMin R (ğ‘ f)) as aáµ£.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (b[k] <áµ£ f[aáµ£ f]) S}) as Náµ£.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (f[aâ‚— f] <áµ£ b[k]) S}) as Nâ‚—.
  set (Î» f, {k âˆŠ Ï‰ | Î» k, (f[aâ‚— f] <áµ£ b[k]) S âˆ§ (b[k] <áµ£ f[aáµ£ f]) S}) as Nâ‚˜.
  set (Î» f,
    match (ixm (ğ‹ f = âˆ…)) with
    | inl _ => match (ixm (ğ‘ f = âˆ…)) with
      | inl _ => b[0]
      | inr _ => b[(Min Lt)[Náµ£ f]]
      end
    | inr _ => match (ixm (ğ‘ f = âˆ…)) with
      | inl _ => b[(Min Lt)[Nâ‚— f]]
      | inr _ => b[(Min Lt)[Nâ‚˜ f]]
      end
    end
  ) as Pairing.
  set (Î» f, f âˆª â¨<a[|dom f|], Pairing f>â¬) as Add.
  set (Func fs fs Add) as g.
  pose proof (card_of_img_of_enumeration A a Hba) as Hcdn.
  assert (Haâ‚—: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ ğ‹ f â‰  âˆ… â†’
    aâ‚— f âˆˆ dom f âˆ§ (aâ‚— f <áµ£ a[n]) R âˆ§
    âˆ€l âˆˆ n, (a[l] <áµ£ a[n]) R â†’ (a[l] â‰¤áµ£ aâ‚— f) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_max A R (ğ‹ f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [Haâ‚—d Hlt]. 
      rewrite Hd, Hcdn in Hlt... repeat split...
      intros m Hm Hamk. assert (a[m] âˆˆ ğ‹ f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (Haáµ£: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ ğ‘ f â‰  âˆ… â†’
    aáµ£ f âˆˆ dom f âˆ§ (a[n] <áµ£ aáµ£ f) R âˆ§
    âˆ€l âˆˆ n, (a[n] <áµ£ a[l]) R â†’ (aáµ£ f â‰¤áµ£ a[l]) R). {
    intros n Hn f [Hf [Hd Hr]] Hne.
    pose proof (finite_loset_has_min A R (ğ‘ f)) as [H Hle]...
    - intros x Hx. apply SepE1 in Hx. rewrite Hd in Hx.
      apply img_included in Hx...
    - apply (subset_of_finite_is_finite _ (dom f)). apply SepE1.
      rewrite Hd. exists n. split...
      rewrite <- (Hcdn n) at 2... apply CardAx0.
    - apply SepE in H as [Haáµ£d Hlt].
      rewrite Hd, Hcdn in Hlt... repeat split...
      intros m Hm Hamk. assert (a[m] âˆˆ ğ‘ f). {
        apply SepI; rewrite Hd; [|rewrite Hcdn]...
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      apply Hle in H as []; [left|right]... apply SepE1 in H...
  }
  assert (HNâ‚—: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ ğ‹ f â‰  âˆ… â†’
    (Min Lt)[Nâ‚— f] âˆˆ Nâ‚— f). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (Ï‰_min (Nâ‚— f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aâ‚— f] âˆˆ B). {
        apply Hr. eapply ranI. apply func_correct... eapply Haâ‚—...
      }
      pose proof (Hur (f[aâ‚— f]) H) as [w [Hw Hlt]].
      exists (bâ»Â¹[w]). apply SepI.
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNáµ£: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ ğ‘ f â‰  âˆ… â†’
    (Min Lt)[Náµ£ f] âˆˆ Náµ£ f). {
    intros n Hn f Hmf Hne.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    apply (Ï‰_min (Náµ£ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - assert (f[aáµ£ f] âˆˆ B). {
        apply Hr. eapply ranI. apply func_correct... eapply Haáµ£...
      }
      pose proof (Hul (f[aáµ£ f]) H) as [w [Hw Hlt]].
      exists (bâ»Â¹[w]). apply SepI.
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (HNâ‚˜: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ op f â†’ ğ‹ f â‰  âˆ… â†’ ğ‘ f â‰  âˆ… â†’
    (Min Lt)[Nâ‚˜ f] âˆˆ Nâ‚˜ f). {
    intros n Hn f Hmf Hop HneL HneR.
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    apply (Ï‰_min (Nâ‚˜ f)); revgoals.
    - intros x Hx. apply SepE1 in Hx...
    - pose proof (HdnS (f[aâ‚— f]) (f[aáµ£ f])) as [qâ‚˜ [H1 H2]]. {
        pose proof Haâ‚— as [Haâ‚—d [Hlt1 _]]...
        pose proof Haáµ£ as [Haáµ£d [Hlt2 _]]...
        eapply Hop... eapply relLt_tranr...
      }
      assert (Hqâ‚˜: qâ‚˜ âˆˆ B). {
        apply Hbr in H1. apply CProdE2 in H1 as [_ H]...
      }
      exists (bâ»Â¹[qâ‚˜]). apply SepI...
      + apply (ap_ran B)... apply bijection_is_func.
        apply inv_bijection...
      + rewrite inv_ran_reduction...
  }
  assert (Hpair: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ op f â†’ Pairing f âˆˆ B). {
    intros n Hn f Hmf Hop. unfold Pairing.
    assert (H := Hmf). destruct H as [Hf [Hd Hr]].
    destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
    destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR]; eapply ap_ran...
    - eapply SepE1 in HNáµ£...
    - eapply SepE1 in HNâ‚—...
    - eapply SepE1 in HNâ‚˜...
  }
  assert (Hout1: âˆ€n âˆˆ Ï‰, a[n] âˆ‰ aâŸ¦nâŸ§). {
    intros n Hn H.
    apply imgE in H as [k [Hk Hp]].
    apply func_ap in Hp... apply injectiveE in Hp...
    eapply nat_not_lt_self... rewrite Hda. eapply Ï‰_trans...
  }
  assert (H00: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡’ B â†’ ğ‹ f = âˆ… â†’ ğ‘ f = âˆ… â†’ n = âˆ…). {
    intros n Hn f [Hf [Hd _]] HL0 HR0.
    destruct (classic (n = âˆ…))...
    exfalso. apply pred_exists in H as [k [Hk Heq]]... subst n.
    destruct (classic (a[k] = a[kâº])). {
      apply injectiveE in H... assert (k âˆˆ kâº)...
      rewrite <- H in H0 at 1. eapply nat_irrefl...
    }
    apply (lo_connected R A) in H as []; revgoals.
    eapply ap_ran... eapply ap_ran... apply HloR.
    - eapply EmptyNI in HR0... exists (a[k]).
      apply SepI; rewrite Hd; [|rewrite Hcdn]...
      eapply imgI... apply func_correct...
    - eapply EmptyNI in HL0... exists (a[k]).
      apply SepI; rewrite Hd; [|rewrite Hcdn]...
      eapply imgI... apply func_correct...
  }
  assert (Hout2: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” B â†’ op f â†’ Pairing f âˆ‰ ran f). {
    intros n Hn f Hif Hop Hin.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: aâŸ¦nâŸ§ âŸº ran f). split...
    apply ranE in Hin as [x Hfx]. apply domI in Hfx as Hx.
    rewrite Hdf in Hx. apply imgE in Hx as [k [Hk Hak]].
    apply func_ap in Hak... apply func_ap in Hfx...
    subst x. unfold Pairing in Hfx.
    assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
    destruct (classic (a[k] = a[n])) as [|Hnq]. {
      apply injectiveE in H... eapply nat_not_lt_self...
    }
    assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
      apply (imgI _ _ k)... apply func_correct...
    }
    destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
    destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR].
    + assert (n = âˆ…). eapply H00... subst n. exfalso0.
    + pose proof (HNáµ£ n Hn f Hmf HR) as Hfkr.
      apply SepE2 in Hfkr. rewrite <- Hfx in Hfkr.
      pose proof Haáµ£ as [Haáµ£d [Hnr Hle]]; revgoals...
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
      * eapply EmptyNI in HL... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
    + pose proof (HNâ‚— n Hn f Hmf HL) as Hflk.
      apply SepE2 in Hflk. rewrite <- Hfx in Hflk.
      pose proof Haâ‚— as [Haâ‚—d [Hln Hle]]; revgoals...
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * eapply EmptyNI in HR... exists (a[k]).
        apply SepI; rewrite Hdf; [|rewrite Hcdn]...
      * apply Hle in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
    + pose proof (HNâ‚˜ n Hn f Hmf Hop HL HR) as Hflr.
      apply SepE2 in Hflr. rewrite <- Hfx in Hflr.
      pose proof Haâ‚— as [Haâ‚—d [Hln Hleâ‚—]]; revgoals...
      pose proof Haáµ£ as [Haáµ£d [Hnr Hleáµ£]]; revgoals...
      destruct Hflr as [Hflk Hfkr].
      apply (lo_connected R A) in Hnq as []; revgoals...
      eapply ap_ran... eapply ap_ran...
      * apply Hleáµ£ in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
      * apply Hleâ‚— in H... eapply (relLt_irrefl _ R)...
        eapply relLt_le_tranr; revgoals... eapply Hop...
  }
  assert (Hind: âˆ€n âˆˆ Ï‰, âˆ€ f, f: aâŸ¦nâŸ§ â‡” B â†’ op f â†’ Add f : aâŸ¦nâºâŸ§ â‡” B âˆ§ op (Add f)). {
    intros n Hn f Hif Hop.
    apply injection_is_func in Hif as H. destruct H as [Hmf Hif'].
    assert (H := Hmf). destruct H as [Hff [Hdf Hrf]].
    assert (Hbf: f: aâŸ¦nâŸ§ âŸº ran f). split...
    cut (Add f: aâŸ¦nâºâŸ§ âŸº ran f âˆª â¨Pairing fâ¬ âˆ§ op (Add f)). {
      intros [[HiFf [HdFf HrFf]] HopFf].
      split... split... split...
      intros x Hx. rewrite HrFf in Hx.
      apply BUnionE in Hx as []... apply Hrf...
      apply SingE in H. subst x. eapply Hpair...
    }
    assert (Hadd: Add f : aâŸ¦nâºâŸ§ âŸº ran f âˆª â¨Pairing fâ¬). {
      unfold Add. rewrite Hdf, Hcdn, img_suc...
      apply bijection_add_point...
      apply Hout1... eapply Hout2...
    }
    split...
    destruct Hadd as [[Hf _] [Hd Hr]].
    pose proof (add_point_func_ap) as [H1 H2]...
    apply Hout1... eapply Hout2...
    intros u Hu v Hv.
    rewrite Hd, img_suc in Hu, Hv...
    apply BUnionE in Hu as [Hu|Hu];
    apply BUnionE in Hv as [Hv|Hv];
    unfold Add; rewrite Hdf, Hcdn; auto; [
      rewrite H1, H1|rewrite H1, H2|
      rewrite H2, H1|rewrite H2, H2
    ]...
    - apply Hop...
    - apply SingE in Hv; subst v. unfold Pairing.
      apply imgE in Hu as [k [Hk Hak]].
      apply func_ap in Hak... subst u. 
      assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
      destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR];
      split; intros Hlt.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNáµ£ n Hn f Hmf HR). apply SepE2 in H.
        pose proof Haáµ£ as [Haáµ£d [_ Hle]]...
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop...
        eapply relLt_tranr...
      + pose proof (HNâ‚— n Hn f Hmf HL). apply SepE2 in H.
        pose proof Haâ‚— as [Haâ‚—d [_ Hle]]...
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNâ‚˜ n Hn f Hmf Hop HL HR).
        pose proof Haâ‚— as [Haâ‚—d [_ Hle]]...
        apply SepE2 in H as [H _].
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + pose proof (HNâ‚˜ n Hn f Hmf Hop HL HR).
        pose proof Haáµ£ as [Haáµ£d [_ Hle]]...
        apply SepE2 in H as [_ H].
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hank... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLt_le_tranr... apply Hop...
        eapply relLt_tranr...
    - apply SingE in Hu; subst u. unfold Pairing.
      apply imgE in Hv as [k [Hk Hak]].
      apply func_ap in Hak... subst v. 
      assert (Hak: a[k] âˆˆ aâŸ¦nâŸ§). {
        eapply imgI... apply func_correct...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (classic (a[n] = a[k])) as [|Hnq]. {
        rewrite <- H in Hak.
        apply imgE in Hak as [x [Hx Hp]].
        apply func_ap in Hp... apply injectiveE in Hp...
        exfalso. eapply nat_not_lt_self...
        rewrite Hda. eapply Ï‰_trans...
      }
      destruct (ixm (ğ‹ f = âˆ…)) as [HL|HL];
      destruct (ixm (ğ‘ f = âˆ…)) as [HR|HR];
      split; intros Hlt.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + assert (n = âˆ…). eapply H00... subst n. exfalso0.
      + pose proof (HNáµ£ n Hn f Hmf HR). apply SepE2 in H.
        pose proof Haáµ£ as [Haáµ£d [_ Hle]]...
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        exfalso. eapply EmptyNI in HL... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + exfalso. eapply EmptyNI in HR... exists (a[k]).
        apply SepI... rewrite Hdf, Hcdn...
      + pose proof (HNâ‚— n Hn f Hmf HL). apply SepE2 in H.
        pose proof Haâ‚— as [Haâ‚—d [_ Hle]]...
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop...
        eapply relLt_tranr...
      + pose proof (HNâ‚˜ n Hn f Hmf Hop HL HR).
        pose proof Haáµ£ as [Haáµ£d [_ Hle]]...
        apply SepE2 in H as [_ H].
        apply Hle in Hlt as []...
        eapply relLt_tranr... apply Hop...
      + pose proof (HNâ‚˜ n Hn f Hmf Hop HL HR).
        pose proof Haâ‚— as [Haâ‚—d [_ Hle]]...
        apply SepE2 in H as [H _].
        assert (HkÏ‰: k âˆˆ Ï‰). eapply Ï‰_trans...
        apply (lo_connected R A) in Hnq as [Hank|Hakn]; revgoals...
        eapply ap_ran... eapply ap_ran...
        apply Hle in Hakn... exfalso.
        eapply (relLt_irrefl (a[k]) R)...
        eapply relLe_lt_tranr... apply Hop...
        eapply relLt_tranr...
    - apply SingE in Hu; apply SingE in Hv; subst.
      split; intros Hlt; exfalso; eapply relLt_irrefl; revgoals...
  }
  assert (Hg: g: fs â‡’ fs). {
    apply meta_function. intros f Hf.
    apply SepE2 in Hf as [[n [Hn Hf]] Hop]. apply SepI.
    - apply UnionAx. exists (aâŸ¦nâºâŸ§ âŸ¶ B). split.
      + apply ReplAx. exists (aâŸ¦nâºâŸ§). split...
        apply PowerAx. rewrite <- Hra. apply img_included.
      + apply arrowI. apply Hind in Hf as [Hf _]...
        apply injection_is_func...
    - split; [|eapply Hind]...
      exists nâº. split. apply Ï‰_inductive... apply Hind...
  }
  assert (Hi0: âˆ…: aâŸ¦âˆ…âŸ§ â‡” B). {
    rewrite img_0. apply empty_injection.
  }
  assert (Hop0: op âˆ…). {
    intros x Hx. rewrite dom_of_empty in Hx. exfalso0.
  }
  pose proof (Ï‰_recursion g fs âˆ… Hg) as [G [HG [HG0 HGnp]]]. {
    apply SepI.
    - apply UnionAx. exists (âˆ… âŸ¶ B). split.
      + apply ReplAx. exists âˆ…. split... apply empty_in_all_power.
      + apply arrowI. apply injection_is_func. apply empty_injection.
    - split... exists âˆ…. split...
  }
  assert (HiGn: âˆ€n âˆˆ Ï‰, G[n] : aâŸ¦nâŸ§ â‡” B âˆ§ op G[n]). {
    intros n Hn.
    destruct HG as [HfG [HdG HrG]].
    set {n âˆŠ Ï‰ | Î» n, G[n] : aâŸ¦nâŸ§ â‡” B âˆ§ op G[n]} as N.
    Ï‰_induction N Hn. rewrite HG0...
    rewrite HGnp... unfold g.
    rewrite meta_func_ap... apply Hind; auto; apply IH.
    apply HrG. eapply ranI. apply func_correct...
  }
  assert (Hin0: âˆ€n âˆˆ Ï‰, âˆ€x âˆˆ aâŸ¦nâŸ§, G[n][x] = G[nâº][x]). {
    intros n Hn x Hx. rewrite HGnp... unfold g.
    rewrite meta_func_ap; [|auto|eapply ap_ran]...
    pose proof (HiGn n Hn) as [Hi Hop].
    assert (H := Hi). destruct H as [Hf [Hd Hr]].
    assert (G[n]: aâŸ¦nâŸ§ âŸº ran G[n]). split...
    symmetry. eapply add_point_func_ap...
    rewrite Hd, Hcdn... apply Hout1... eapply Hout2...
  }
  assert (Hout0: âˆ€n âˆˆ Ï‰, G[nâº][a[n]] âˆ‰ ran G[n]). {
    intros n Hn Hr.
    pose proof (HiGn n Hn) as [HGn Hop].
    apply injection_is_func in HGn as [HGn Hin].
    assert (H := HGn). destruct H as [Hfn [Hdn Hrn]].
    apply ranE in Hr as [x Hp]. apply domI in Hp as Hx.
    apply func_ap in Hp... rewrite HGnp in Hp...
    unfold g in Hp. rewrite meta_func_ap in Hp; [|auto|eapply ap_ran]...
    unfold Add in Hp. rewrite Hdn, Hcdn in Hp...
    assert (âˆ€x âˆˆ â¨a[n]â¬, (G[n] âˆª â¨<a[n], Pairing G[n]>â¬)[x] = Pairing G[n]). {
      assert (G[n]: aâŸ¦nâŸ§ âŸº ran G[n]). split...
      eapply add_point_func_ap...
      apply Hout1... eapply Hout2... split...
    }
    rewrite H in Hp... eapply Hout2... split...
    rewrite <- Hp. eapply ranI. apply func_correct...
  }
  assert (Hin: âˆ€n âˆˆ Ï‰, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦mâŸ§, (G[m])[x] = (G[n])[x]). {
    intros n Hn.
    set {n âˆŠ Ï‰ | Î» n, âˆ€k âˆˆ n, âˆ€x âˆˆ aâŸ¦kâŸ§, G[k][x] = G[n][x]} as N.
    Ï‰_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [].
    - rewrite IH... apply Hin0...
      apply imgE in Hx as [l [Hl Hp]].
      apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in H; subst k. apply Hin0...
  }
  assert (Hout: âˆ€n âˆˆ Ï‰, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, (G[n])[x] âˆ‰ ran G[m]). {
    intros n Hn.
    set {n âˆŠ Ï‰ | Î» n, âˆ€m âˆˆ n, âˆ€x âˆˆ aâŸ¦nâŸ§ - aâŸ¦mâŸ§, G[n][x] âˆ‰ ran G[m]} as N.
    Ï‰_induction N Hn; intros k Hkn x Hx. exfalso0.
    apply BUnionE in Hkn as [Hkm|Hkm].
    - assert (Hk: k âˆˆ Ï‰). eapply Ï‰_trans...
      pose proof (HiGn k Hk) as [[[Hfk _] [Hdk _]] _].
      pose proof (HiGn m Hm) as [[[Hfm _] [Hdm _]] _].
      apply SepE in Hx as [Hx Hx']. rewrite img_suc in Hx...
      apply BUnionE in Hx as [Hx|Hx].
      + assert (x âˆˆ aâŸ¦mâŸ§ - aâŸ¦kâŸ§). apply SepI...
        apply IH in H... intros H1. apply H.
        apply ranE in H1 as [w Hp]. apply domI in Hp as Hw.
        apply func_ap in Hp... rewrite Hin0...
        apply (ranI _ w). rewrite <- Hp. apply func_correct...
      + apply SingE in Hx; subst x. intros H. apply (Hout0 m)...
        apply ranE in H as [x Hp]. apply domI in Hp as Hx.
        apply func_ap in Hp... rewrite <- Hp.
        apply (ranI _ x). rewrite (Hin m)...
        apply func_correct... rewrite Hdk in Hx. rewrite Hdm.
        apply imgE in Hx as [l [Hl Ha]].
        apply (imgI _ _ l)... eapply nat_trans...
    - apply SingE in Hkm; subst k.
      rewrite img_comp_distr in Hx; [|apply Hia].
      rewrite suc_comp, img_single in Hx...
      apply SingE in Hx; subst. apply Hout0...
  }
  exists G. split; [|split]; [apply HG..|intros n Hn].
  pose proof (HiGn n Hn) as [[Hi [Hd Hr]] Hop].
  unfold op in Hop. rewrite Hd in Hop.
  split. split... split...
  split. apply Hin... apply Hout...
Qed.

(* æ‰€æœ‰éƒ¨åˆ†åµŒå…¥çš„å¹¶æ˜¯å®Œæ•´åµŒå…¥ *)
Lemma union_of_partial_embeddings :
  âˆ€ A R, Ï‰ â‰ˆ A â†’ loset A R â†’ 
  âˆ€ B S, Ï‰ â‰ˆ B â†’ loset B S â†’ dense S â†’ unbounded B S â†’
  âˆƒ f, f: A â‡” B âˆ§ âˆ€ x y âˆˆ A, (x <áµ£ y) R â†” (f[x] <áµ£ f[y]) S.
Proof with neauto; try congruence.
  intros A R [a Hba] HloR B S HqnB HloS HdnS Hubd.
  assert (H := Hba). apply bijection_is_func in H as [Hma [Hia Hra]].
  assert (H := Hma). destruct H as [Hfa [Hda _]].
  pose proof (enumeration_of_partial_embeddings)
    as [G [HfG [HdG Hstar]]]...
  set (â‹ƒáµ¢ (ap G)) as f.
  assert (Hf: f: A â‡” B). {
    split; split.
    - (* is_function f *)
      split. intros p Hp.
      apply IFUnionE in Hp as [n [Hn Hp]]. apply (Hstar n Hn)...
      intros x Hx. split. apply domE in Hx...
      intros y1 y2 H1 H2.
      apply IFUnionE in H1 as [n [Hn H1]].
      apply IFUnionE in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 _]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 _]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y1 y2.
      destruct (classic (m = n))...
      apply nat_connected in H as []...
      symmetry. apply Hin1... apply Hin2...
    - (* single_rooted f *)
      intros y Hy. split. apply ranE in Hy...
      intros y1 y2 H1 H2.
      apply IFUnionE in H1 as [n [Hn H1]].
      apply IFUnionE in H2 as [m [Hm H2]].
      pose proof (Hstar n Hn) as [[Hi1 [Hd1 _]] [_ [Hin1 Hout1]]].
      pose proof (Hstar m Hm) as [[Hi2 [Hd2 _]] [_ [Hin2 Hout2]]].
      apply domI in H1 as Hx1.
      apply domI in H2 as Hx2.
      apply func_ap in H1; [|apply Hi1].
      apply func_ap in H2; [|apply Hi2]. subst y.
      destruct (classic (m = n)). eapply injectiveE...
      apply nat_connected in H as []...
      + destruct (classic (y1 âˆˆ aâŸ¦mâŸ§)).
        * rewrite <- Hin1 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout1 m H y1).
          apply SepI... rewrite <- H2. eapply ranI.
          apply func_correct... apply Hi2.
      + destruct (classic (y2 âˆˆ aâŸ¦nâŸ§)).
        * rewrite <- Hin2 in H2... apply injectiveE in H2...
        * exfalso. apply (Hout2 n H y2).
          apply SepI... rewrite H2. eapply ranI.
          apply func_correct... apply Hi1.
    - (* dom f = A *)
      apply ExtAx. split; intros Hx.
      + apply domE in Hx as [y Hp].
        apply IFUnionE in Hp as [n [Hn Hp]]. apply domI in Hp.
        pose proof (Hstar n Hn) as [[_ [Hd _]] _].
        rewrite Hd in Hp. apply imgE in Hp as [k [Hk Hak]].
        apply func_ap in Hak... subst x.
        eapply ap_ran... eapply Ï‰_trans...
      + set (aâ»Â¹[x]) as n.
        assert (Hnp: nâº âˆˆ Ï‰). {
          apply Ï‰_inductive. eapply ap_ran...
          apply bijection_is_func. apply inv_bijection...
        }
        pose proof (Hstar nâº Hnp) as [[[Hf _] [Hd _]] _].
        apply (domI _ _ G[nâº][x]).
        apply UnionAx. exists (G[nâº]). split. eapply ReplI...
        apply func_correct... rewrite Hd.
        apply (imgI _ _ n)... rewrite inv_op.
        apply func_correct. apply inv_func_iff_sr.
        apply Hia. rewrite inv_dom...
    - (* ran f âŠ† B *)
      intros y Hy. apply ranE in Hy as [x Hp].
      apply IFUnionE in Hp as [n [Hn Hp]]. apply domI in Hp as Hx.
      pose proof (Hstar n Hn) as [[[Hf _] [Hd Hr]] _].
      apply func_ap in Hp... subst y.
      eapply ap_ran... split...
  }
  assert (Hap: âˆ€x âˆˆ A, âˆƒn âˆˆ Ï‰, <x, f[x]> âˆˆ G[n]). {
    intros x Hx. destruct Hf as [[Hf _] [Hd _]].
    apply IFUnionE. fold f. apply func_correct...
  }
  exists f. split...
  intros x Hx y Hy.
  apply Hap in Hx as [n [Hn H1]]. apply domI in H1 as Hx.
  apply Hap in Hy as [m [Hm H2]]. apply domI in H2 as Hy.
  pose proof (Hstar n Hn) as [[[Hf1 _] [Hd1 _]] [Hop1 [Hin1 Hout1]]].
  pose proof (Hstar m Hm) as [[[Hf2 _] [Hd2 _]] [Hop2 [Hin2 _]]].
  apply func_ap in H1... rewrite <- H1.
  apply func_ap in H2... rewrite <- H2.
  destruct (classic (n = m)). {
    subst m. split; intros Hlt; apply Hop1...
  }
  apply nat_connected in H as []...
  - assert (Hxm: x âˆˆ aâŸ¦mâŸ§). {
      rewrite Hd1 in Hx. apply imgE in Hx as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite Hin2... split; intros Hlt; apply Hop2...
  - assert (Hyn: y âˆˆ aâŸ¦nâŸ§). {
      rewrite Hd2 in Hy. apply imgE in Hy as [k [Hk Hak]].
      eapply imgI; revgoals... eapply nat_trans...
    }
    rewrite (Hin1 m H)... split; intros Hlt; apply Hop1...
Qed.

(* å¯æ•°æ— ç©·çº¿åºé›†å¯åµŒå…¥å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›† *)
Lemma infinite_loset_embeddable_in_dense_infinite_loset :
  âˆ€ S, Ï‰ â‰ˆ A S â†’ âˆ€ T, Ï‰ â‰ˆ A T â†’ dense (R T) â†’
  âˆƒ T', T' âŠ‘ T âˆ§ S â‰… T'.
Proof with eauto.
  intros S HqnS T HqnT Hdn.
  pose proof (countable_dense_loset_has_unbounded_subset T HqnT Hdn)
    as [U [[Hsub HrT] [HqnC [HdnT Hubd]]]].
  assert (Hf: âˆƒ f, f: A S â‡” A U âˆ§ âˆ€ x y âˆˆ A S,
    (x <áµ£ y) (R S) â†” (f[x] <áµ£ f[y]) (R U)). {
    eapply union_of_partial_embeddings...
  }
  destruct Hf as [f [Hf Hop]].
  assert (H := Hf). destruct H as [Hif [Hd Hr]].
  set (ran f) as B.
  assert (Hlo: loset B (R U â¥ B)). {
    apply (subRel_loset (A U))...
  }
  set (constr B (R U â¥ B) Hlo) as T'.
  exists T'. repeat split. eapply sub_tran...
  simpl. rewrite HrT, subRel_absorption...
  exists f. split... split...
  intros x Hx y Hy. split; intros Hlt.
  - apply SepI. apply Hop...
    apply CProdI; eapply ap_ran; eauto; split; auto; apply Hif.
  - apply SepE1 in Hlt. apply Hop...
Qed.

(* å¯æ•°çº¿åºé›†å¯åµŒå…¥å¯æ•°æ— ç©·ç¨ å¯†çº¿åºé›† *)
Theorem countable_loset_embeddable_in_infinite_dense_loset :
  âˆ€ S T, countable (A S) â†’ Ï‰ â‰ˆ (A T) â†’ dense (R T) â†’
  âˆƒ T', T' âŠ‘ T âˆ§ S â‰… T'.
Proof with auto.
  intros S T Hcnt Hqn Hdn.
  apply countable_iff in Hcnt as [Hfin|Hinf].
  - apply finite_loset_embeddable_in_dense_infinite_loset...
  - apply infinite_loset_embeddable_in_dense_infinite_loset... symmetry... 
Qed.

(* ex8_17 å¯æ•°æ— ç©·çº¿åºé›†å¯åµŒå…¥æœ‰ç†æ•°é›† *)
(* The assumption in the textbook about being dense seems to be redundant *)
Corollary countable_loset_embeddable_in_rat :
  âˆ€ S, countable (A S) â†’
  âˆƒ T, A T âŠ† â„š âˆ§ R T = RatLt â¥ A T âˆ§ S â‰… T.
Proof with auto.
  intros S Hcnt.
  set (constr â„š RatLt ratLt_linearOrder) as Q.
  pose proof (countable_loset_embeddable_in_infinite_dense_loset S Q)
    as [Q' [[Hsub Hrel] Hiso]]...
  - apply CardAx1. symmetry. apply card_rat_eq_aleph0.
  - apply ratLt_dense.
  - exists Q'. repeat split...
Qed.
