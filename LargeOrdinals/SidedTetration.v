(** Coq coding by choukh, Aug 2021 **)

Require Export ZFC.Elements.EST8_7.
Import OrdinalClass 𝐎𝐍Operation.

Local Hint Resolve
  add_ran mul_ran exp_ran
  ordAdd_ran ordMul_ran preOrdExp_ran ordExp_ran : core.

(** 左迭代幂次 **)
(* see also LargeOrdinals/NormalTetration.v *)
Definition OrdTetL := λ α, Operation α (OrdExp α).
Notation "α ^^ᴸ β" := (OrdTetL α β) (at level 25) : OrdArith_scope.

Theorem ordTetL_0 : ∀α ⋵ 𝐎𝐍, α ^^ᴸ 0 = α.
Proof. intros α H. apply operation_0; auto. Qed.

Theorem ordTetL_suc : ∀ α β ⋵ 𝐎𝐍, α ^^ᴸ β⁺ = α ^ (α ^^ᴸ β).
Proof. intros α Hα β Hβ. apply operation_suc; auto. Qed.

Theorem ordTetL_limit : ∀α ⋵ 𝐎𝐍, continuous (OrdTetL α).
Proof. intros α Hα. apply operation_limit; auto. Qed.

Theorem ordTetL_ran : ∀ α β ⋵ 𝐎𝐍, α ^^ᴸ β ⋵ 𝐎𝐍.
Proof. intros α Hα β Hβ. apply operation_operative; auto. Qed.
Local Hint Resolve ordTetL_ran : core.

Theorem ordTetL_1_r : ∀α ⋵ 𝐎𝐍, α ^^ᴸ 1 = α ^ α.
Proof.
  intros α H. rewrite pred, ordTetL_suc, ordTetL_0; auto.
Qed.

Theorem ordTetL_1_l : ∀α ⋵ 𝐎𝐍, 1 ^^ᴸ α = 1.
Proof with neauto.
  ord_induction. intros α Hα IH.
  ord_destruct α.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [β [Hβ Heq]]. subst.
    rewrite ordTetL_suc, ordExp_1_l...
  - rewrite ordTetL_limit... ext.
    + apply FUnionE in H as [β [Hβ H]]. rewrite IH in H...
    + rewrite one in H. apply SingE in H. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordTetL_0, pred...
Qed.

Lemma ordTetL_eq_0 : ∀ α β ⋵ 𝐎𝐍, α ^^ᴸ β = 0 → α = 0.
Proof with eauto.
  intros α Hα. ord_induction. intros β Hβ IH H.
  ord_destruct β.
  - subst. rewrite ordTetL_0 in H...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite ordTetL_suc in H...
    apply ordExp_eq_0 in H...
  - rewrite ordTetL_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [γ Hγ].
      assert (Hoγ: γ ⋵ 𝐎𝐍). eapply ord_is_ords...
      apply sucord_in_limord in Hγ...
      eapply repl_eq_1 in Hγ as H0...
Qed.

Lemma ordAdd_eq_1 : ∀ α β ⋵ 𝐎𝐍, α + β = 1 →
  α = 0 ∧ β = 1 ∨ α = 1 ∧ β = 0.
Proof with neauto.
  intros α Hα β Hβ H.
  ord_destruct α; subst.
  - rewrite ordAdd_0_l in H...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    ord_destruct β.
    + subst. rewrite ordAdd_0_r in H...
    + exfalso. destruct Hsuc as [δ [Hδ Heq]]. subst.
      rewrite <- (ordAdd_1_r δ), <- ordAdd_assoc in H...
      rewrite (ordAdd_1_r), pred in H...
      apply ord_suc_injective in H...
      apply ordAdd_eq_0 in H as []... eapply suc_neq_0...
    + exfalso. apply limord_ge_ω in Hlim...
      apply (ord_irrefl 1)... rewrite <- H at 2.
      eapply ord_trans_lt_le. auto. apply embed_ran.
      eapply ord_trans_le... apply ordAdd_enlarge_l...
  - exfalso.
    destruct (classic (β = 0)). {
      subst. rewrite ordAdd_0_r in H...
      apply (limord_iff_not_sucord α)... exists 0...
    }
    apply limord_ge_ω in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans. auto. apply embed_ran.
    eapply ord_trans_le_lt... apply ordAdd_enlarge_r...
Qed.

Lemma ordMul_eq_1 : ∀ α β ⋵ 𝐎𝐍, α ⋅ β = 1 → α = 1 ∧ β = 1.
Proof with neauto.
  intros α Hα β Hβ H. ord_destruct β.
  - subst. rewrite ordMul_0_r in H... exfalso...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite ordMul_suc in H...
    apply ordAdd_eq_1 in H as [[H0 H1]|[H1 H0]]...
    + apply ordMul_eq_0 in H0 as []...
      * exfalso. subst...
      * split... subst...
    + rewrite H0 in H1. rewrite ordMul_0_l in H1... exfalso...
  - exfalso.
    destruct (classic (α = 0)). subst. rewrite ordMul_0_l in H...
    destruct (classic (α = 1)). {
      subst. rewrite ordMul_1_l in H...
      apply (limord_iff_not_sucord β)... exists 0...
    }
    apply limord_ge_ω in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply ordMul_enlarge_l...
Qed.

Lemma preOrdExp_eq_1 : ∀ α β ⋵ 𝐎𝐍, α ^ᵖ β = 1 →
  α = 1 ∨ β = 0 ∨ β ≠ 0 ∧ β ⋵ 𝐎𝐍ˡⁱᵐ ∧ α = 0.
Proof with neauto.
  intros α Hα β Hβ H. ord_destruct β...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite preOrdExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (α = 0))...
    destruct (classic (α = 1))...
    exfalso. apply limord_ge_ω in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply preOrdExp_enlarge_l...
Qed.

Lemma ordExp_eq_1 : ∀ α β ⋵ 𝐎𝐍, α ^ β = 1 → α = 1 ∨ β = 0.
Proof with neauto.
  intros α Hα β Hβ H. ord_destruct β.
  - subst. rewrite ordExp_0_r in H...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite ordExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (α = 1))...
    exfalso. unfold OrdExp in H.
    destruct (ixm (α = 0)); destruct (ixm (β = 0))...
    apply limord_ge_ω in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto.
    apply embed_ran. eapply ord_trans_le...
    apply preOrdExp_enlarge_l...
Qed.

Lemma ordTetL_gt_1 : ∀ α β ⋵ 𝐎𝐍, 1 ∈ α → 1 ∈ α ^^ᴸ β.
Proof with neauto.
  intros α Hα. ord_induction. intros β Hβ IH Hα1.
  ord_destruct β.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite ordTetL_suc... eapply ord_trans...
    apply ordExp_enlarge_r...
  - rewrite ordTetL_limit...
    apply EmptyNE in H0 as [γ Hγ].
    assert (Hoγ: γ ⋵ 𝐎𝐍). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTetL_suc... apply ordExp_enlarge_l...
Qed.

Theorem ordTetL_eq_1 : ∀ α β ⋵ 𝐎𝐍, α ^^ᴸ β = 1 → α = 0 ∨ α = 1.
Proof with neauto.
  intros α Hα β Hβ H.
  destruct (classic (α = 0))...
  destruct (classic (α = 1))... exfalso.
  apply (ord_irrefl 1)... rewrite <- H at 2.
  apply ordTetL_gt_1...
Qed.

Fact ordTetL_is_limord_l : ∀α ⋵ 𝐎𝐍, ∀𝜆 ⋵ 𝐎𝐍ˡⁱᵐ, 𝜆 ≠ 0 → 𝜆 ^^ᴸ α ⋵ 𝐎𝐍ˡⁱᵐ.
Proof with nauto.
  ord_induction. intros α Hα IH 𝜆 H𝜆 H0.
  ord_destruct α.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [β [Hβ Heq]]. subst.
    rewrite ordTetL_suc... apply ordExp_is_limord_l...
    apply ordTetL_gt_1... eapply ord_trans_lt_le. auto.
    apply embed_ran. apply limord_ge_ω...
  - rewrite ordTetL_limit...
    apply union_of_limords_is_limord. intros x Hx.
    apply ReplAx in Hx as [β [Hβ Hx]]. subst x. apply IH...
Qed.

Lemma tetL_ran : ∀ m n ∈ ω, m ^^ᴸ n ∈ ω.
Proof with auto.
  intros k Hk n Hn. ω_induction n.
  - rewrite ordTetL_0...
  - rewrite ordTetL_suc, fin_ordExp_eq_exp...
Qed.
Local Hint Resolve tetL_ran : core.

Lemma tetL_preserve_base_lt : ∀ m n p ∈ ω, m ≠ 0 → n ≠ 0 →
  m ∈ n ↔ m ^^ᴸ p ∈ n ^^ᴸ p.
Proof with eauto.
  assert (Hright: ∀ m n p ∈ ω, m ≠ 0 → n ≠ 0 → m ∈ n → m ^^ᴸ p ∈ n ^^ᴸ p). {
    intros m Hm n Hn p Hp Hm0 Hn0 H.
    generalize dependent n. generalize dependent m.
    ω_induction p; intros k Hk Hk0 n Hn Hn0 H.
    - rewrite ordTetL_0, ordTetL_0...
    - assert (Hmp: m⁺ ∈ ω). apply ω_inductive...
      assert (H0: k ^^ᴸ m ≠ 0). intros H0. apply ordTetL_eq_0 in H0...
      rewrite ordTetL_suc, ordTetL_suc...
      repeat rewrite fin_ordExp_eq_exp...
      eapply lt_le_trans. auto.
      apply exp_preserve_base_lt; revgoals...
      apply exp_preserve_exponent_le...
  }
  intros m Hm n Hn p Hp Hm0 Hn0. split. apply Hright...
  intros H. destruct (classic (m = n)).
  - subst. exfalso. eapply nat_irrefl; revgoals...
  - apply nat_connected in H0 as []...
    pose proof (Hright n Hn m Hm p Hp Hn0 Hm0 H0).
    exfalso. eapply nat_not_lt_gt; revgoals...
Qed.

Lemma tetL_enlarge_l : ∀ m n ∈ ω, 1 ∈ n → m ∈ n ^^ᴸ m.
Proof with neauto.
  intros k Hk. ω_induction k; intros n Hn Hn0.
  - rewrite ordTetL_0... apply ord_neq_0_gt_0...
    apply ord_gt_1_neq_0_1...
  - rewrite ordTetL_suc... pose proof (IH n Hn Hn0).
    apply lt_iff_suc_le in H...
    eapply ord_trans_le_lt. auto. apply H.
    rewrite fin_ordExp_eq_exp... apply exp_enlarge_l...
Qed.

Fact ordTetL_2_ω : 2 ^^ᴸ ω = ω.
Proof with neauto.
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply ω_trans...
  - rewrite ordTetL_limit... eapply FUnionI...
    apply tetL_enlarge_l... rewrite (pred 2)...
Qed.

Theorem ordTetL_n_ascending : ∀α ⋵ 𝐎𝐍, 1 ∈ α → ∀n ∈ ω, α ^^ᴸ n ∈ α ^^ᴸ n⁺.
Proof with neauto.
  intros α Hα Hα1 n Hn. ω_induction n.
  - rewrite ordTetL_suc, <- zero, ordTetL_0... apply ordExp_enlarge_r...
  - rewrite ordTetL_suc, ordTetL_suc... apply ordExp_preserve_lt...
Qed.

Theorem ordTetL_n_monotone : ∀α ⋵ 𝐎𝐍, 1 ∈ α → ∀n ∈ ω, ∀m ∈ n, α ^^ᴸ m ∈ α ^^ᴸ n.
Proof with eauto.
  intros α Hα Hα1 n Hn. ω_induction n; intros k Hlt.
  - exfalso0.
  - assert (Hk: k ∈ ω). eapply ω_trans... apply ω_inductive...
    apply le_iff_lt_suc in Hlt as []...
    + eapply ord_trans. auto. apply IH...
      apply ordTetL_n_ascending...
    + subst. apply ordTetL_n_ascending...
Qed.

Theorem ordTetL_weakly_increasing : ∀ α β γ ⋵ 𝐎𝐍, α ≠ 0 → β ∈ γ → α ^^ᴸ β ⋸ α ^^ᴸ γ.
Proof with eauto.
  intros α Hα β Hβ. ord_induction. intros γ Hγ IH Hα0 Hlt.
  destruct (classic (α = 1)) as [|Hα1]. {
    subst. rewrite ordTetL_1_l, ordTetL_1_l...
  }
  ord_destruct γ.
  - subst. exfalso0.
  - destruct Hsuc as [δ [Hδ H]]. subst.
    apply ord_le_iff_lt_suc in Hlt as []...
    + rewrite ordTetL_suc... eapply ord_trans_le; revgoals. 3: auto.
      apply ordExp_preserve_le_r; revgoals. apply IH... 1-4: auto.
      apply ordExp_enlarge_l...
    + subst. rewrite ordTetL_suc... apply ordExp_enlarge_l...
  - apply ord_le_iff_sub... intros x Hx.
    rewrite ordTetL_limit... eapply FUnionI...
Qed.

Corollary ordTetL_enlarge_r : ∀ α β ⋵ 𝐎𝐍, 1 ∈ α → β ≠ 0 → α ∈ α ^^ᴸ β.
Proof with neauto.
  intros α Hα β Hβ Hα1 Hβ0.
  destruct (classic (β = 1)). {
    subst. rewrite ordTetL_1_r... apply ordExp_enlarge_r...
  }
  eapply (ord_trans_lt_le _ (α ^ α))... apply ordExp_enlarge_r...
  rewrite <- ordTetL_1_r... apply ordTetL_weakly_increasing...
  apply ord_gt_1_neq_0_1...
Qed.

Lemma ordTetL_exp_r_le_l : ∀α ⋵ 𝐎𝐍, 1 ∈ α →
  ∀n ∈ ω, n ≠ 0 → α ^^ᴸ n ^ α ⋸ α ^ α ^^ᴸ n.
Proof with nauto.
  intros α Hα Hα1 n Hn.
  ω_induction n; intros Hn0. exfalso...
  rewrite ordTetL_suc, ordExp_mul...
  apply ordExp_preserve_le_r...
  assert (Hα2: Embed 2 ⋸ α). apply ord_suc_correct...
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_0, <- ordExp_2_r...
    apply ordExp_preserve_le_r...
  }
  assert (Ht0: α ^^ᴸ m ≠ 0). {
    intros H. apply ordTetL_eq_0 in H... subst. exfalso0.
  }
  assert (Ht1: α ^^ᴸ m ≠ 1). {
    intros H. apply ord_gt_1_neq_0_1 in Hα1 as []...
    apply ordTetL_eq_1 in H as []...
  }
  eapply ord_trans_le; revgoals. apply IH... 2: auto.
  eapply ord_trans_le. auto. left. apply ordMul_preserve_lt; revgoals.
  apply (ordTetL_enlarge_r α Hα m)... 1-4: auto.
  rewrite <- ordExp_2_r... apply ordExp_preserve_le_r...
Qed.

Lemma ordTetL_exp_r_lt_l : ∀α ⋵ 𝐎𝐍, 2 ∈ α →
  ∀n ∈ ω, n ≠ 0 → α ^^ᴸ n ^ α ∈ α ^ α ^^ᴸ n.
Proof with nauto.
  intros α Hα Hα2 n Hn.
  assert (Hα1: 1 ∈ α). {
    eapply ord_trans. auto. apply suc_has_n. apply Hα2.
  }
  ω_induction n; intros Hn0. exfalso...
  rewrite ordTetL_suc, ordExp_mul...
  apply ordExp_preserve_lt...
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_0, <- ordExp_2_r...
    apply ordExp_preserve_lt...
  }
  assert (Ht0: α ^^ᴸ m ≠ 0). {
    intros H. apply ordTetL_eq_0 in H... subst. exfalso0.
  }
  assert (Ht1: α ^^ᴸ m ≠ 1). {
    intros H. apply ord_gt_1_neq_0_1 in Hα1 as []...
    apply ordTetL_eq_1 in H as []...
  }
  eapply ord_trans; revgoals. apply IH... 2: auto.
  eapply ord_trans. auto. apply ordMul_preserve_lt; revgoals.
  apply (ordTetL_enlarge_r α Hα m)... 1-4: auto.
  rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
Qed.

(** 右迭代幂次 **)
Definition OrdTetR := λ α, Operation α (λ ξ, ξ ^ α).
Notation "α ^^ᴿ β" := (OrdTetR α β) (at level 25) : OrdArith_scope.

Theorem ordTetR_0 : ∀α ⋵ 𝐎𝐍, α ^^ᴿ 0 = α.
Proof. intros α H. apply operation_0; auto. Qed.

Theorem ordTetR_suc : ∀ α β ⋵ 𝐎𝐍, α ^^ᴿ β⁺ = (α ^^ᴿ β) ^ α.
Proof. intros α Hα β Hβ. apply operation_suc; auto. Qed.

Theorem ordTetR_limit : ∀α ⋵ 𝐎𝐍, continuous (OrdTetR α).
Proof. intros α Hα. apply operation_limit; auto. Qed.

Theorem ordTetR_ran : ∀ α β ⋵ 𝐎𝐍, α ^^ᴿ β ⋵ 𝐎𝐍.
Proof. intros α Hα β Hβ. apply operation_operative; auto. Qed.
Local Hint Resolve ordTetR_ran : core.

Theorem ordTetR_1_r : ∀α ⋵ 𝐎𝐍, α ^^ᴿ 1 = α ^ α.
Proof.
  intros α H. rewrite pred, ordTetR_suc, ordTetR_0; auto.
Qed.

Theorem ordTetR_1_l : ∀α ⋵ 𝐎𝐍, 1 ^^ᴿ α = 1.
Proof with neauto.
  ord_induction. intros α Hα IH.
  ord_destruct α.
  - subst. rewrite ordTetR_0...
  - destruct Hsuc as [β [Hβ Heq]]. subst.
    rewrite ordTetR_suc, ordExp_1_r...
  - rewrite ordTetR_limit... ext.
    + apply FUnionE in H as [β [Hβ H]]. rewrite IH in H...
    + rewrite one in H. apply SingE in H. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordTetR_0, pred...
Qed.

Fact ordTetR_n_le_L : ∀α ⋵ 𝐎𝐍, α ≠ 0 → ∀n ∈ ω, n ≠ 0 → α ^^ᴿ n ⋸ α ^^ᴸ n.
Proof with nauto.
  intros α Hα Hα0 n Hn.
  ω_induction n; intros Hn0. exfalso...
  destruct (classic (α = 1)) as [|Hα1]. {
    subst. rewrite ordTetL_1_l, ordTetR_1_l...
  }
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_1_r, ordTetR_1_r...
  }
  rewrite ordTetL_suc, ordTetR_suc...
  eapply ord_trans_le. auto.
  apply ordExp_preserve_le_l; revgoals.
  apply IH... 1-3: auto. apply ordTetL_exp_r_le_l...
Qed.

Fact ordTetR_n_lt_L : ∀α ⋵ 𝐎𝐍, 2 ∈ α → ∀n ∈ ω, 1 ∈ n → α ^^ᴿ n ∈ α ^^ᴸ n.
Proof with nauto.
  intros α Hα Hα2 n Hn.
  assert (Hα1: 1 ∈ α). {
    eapply ord_trans. auto. apply suc_has_n. apply Hα2.
  }
  ω_induction n; intros Hn1. exfalso0.
  apply ord_le_iff_lt_suc in Hn1 as []...
  - rewrite ordTetL_suc, ordTetR_suc...
    eapply ord_trans_le_lt. auto.
    apply ordExp_preserve_le_l; revgoals.
    left. apply IH... 1-3: auto.
    apply ordTetL_exp_r_lt_l... apply ord_gt_1_neq_0_1...
  - subst. rewrite ordTetL_suc, ordTetR_suc...
    rewrite ordTetL_1_r, ordTetR_1_r, ordExp_mul...
    apply ordExp_preserve_lt...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
Qed.

Fact ordTetR_normal_form : ∀ α β ⋵ 𝐎𝐍, α ≠ 0 → α ^^ᴿ β = α ^ α ^ β.
Proof with eauto.
  intros α Hα. ord_induction. intros β Hβ IH Hα0.
  destruct (classic (α = 1)) as [|Hα1]. {
    subst. rewrite ordTetR_1_l, ordExp_1_l...
  }
  ord_destruct β.
  - subst. rewrite ordTetR_0, ordExp_0_r, ordExp_1_r...
  - destruct Hsuc as [γ [Hγ H]]. subst.
    rewrite ordTetR_suc, IH, ordExp_mul, ordExp_suc...
  - rewrite ordTetR_limit, ordExp_limit...
    2: apply ordExp_is_limord_r...
    2: intros H; apply ordExp_eq_0 in H...
    ext.
    + apply FUnionE in H as [γ [Hγ H]].
      assert (Hoγ: γ ⋵ 𝐎𝐍). apply (ord_is_ords β)...
      rewrite IH in H... eapply FUnionI...
      apply ordExp_preserve_lt...
    + apply FUnionE in H as [γ [Hγ Hx]].
      assert (Hoγ: γ ⋵ 𝐎𝐍). apply (ord_is_ords (α ^ β))...
      rewrite ordExp_limit in Hγ...
      apply FUnionE in Hγ as [δ [Hδ Hγ]].
      assert (Hoδ: δ ⋵ 𝐎𝐍). apply (ord_is_ords β)...
      eapply FUnionI... rewrite IH...
      eapply ord_trans... apply ordExp_preserve_lt...
Qed.

(** 指定首项迭代幂次 **)
(* α ^ α ^ ... ^ α ^ ι *)
Definition OrdTet0 := λ α β ι, Operation ι (OrdExp α) β.
Notation "α ^^⁰ β" := (OrdTet0 α β) (at level 25) : OrdArith_scope.

Theorem ordTet0_0 : ∀ ι α ⋵ 𝐎𝐍, (α ^^⁰ 0) ι = ι.
Proof. intros ι Hι α Hα. apply operation_0; auto. Qed.

Theorem ordTet0_suc : ∀ ι α β ⋵ 𝐎𝐍, (α ^^⁰ β⁺) ι = α ^ (α ^^⁰ β) ι.
Proof. intros ι Hι α Hα β Hβ. apply operation_suc; auto. Qed.

Theorem ordTet0_limit : ∀ ι α ⋵ 𝐎𝐍, continuous (λ β, (α ^^⁰ β) ι).
Proof. intros ι Hι α Hα. apply operation_limit; auto. Qed.

Theorem ordTet0_ran : ∀ ι α β ⋵ 𝐎𝐍, (α ^^⁰ β) ι ⋵ 𝐎𝐍.
Proof. intros ι Hι α Hα β Hβ. apply operation_operative; auto. Qed.
Local Hint Resolve ordTet0_ran : core.

Theorem ordTet0_1 : ∀ ι α ⋵ 𝐎𝐍, (α ^^⁰ 1) ι = α ^ ι.
Proof.
  intros ι Hι α Hα. rewrite pred, ordTet0_suc, ordTet0_0; auto.
Qed.

Lemma ordTet0_lt_ordTetL_n : ∀ ξ ι ⋵ 𝐎𝐍, 1 ∈ ξ → ι ∈ ξ → ∀n ∈ ω, (ξ ^^⁰ n) ι ∈ ξ ^^ᴸ n.
Proof with nauto.
  intros ξ Hξ ι Hι Hξ1 Hιξ n Hn.
  ω_induction n.
  - rewrite ordTet0_0, ordTetL_0...
  - rewrite ordTet0_suc, ordTetL_suc...
    apply ordExp_preserve_lt...
Qed.

Lemma ordTet0_gt_ordTetL_n : ∀ ξ ι ⋵ 𝐎𝐍, 1 ∈ ι → ι ∈ ξ → ∀n ∈ ω, ξ ^^ᴸ n ∈ (ξ ^^⁰ n⁺) ι.
Proof with neauto.
  intros ξ Hξ ι Hι Hι1 Hιξ n Hn.
  ω_induction n.
  - rewrite ordTet0_1, ordTetL_0...
    apply ordExp_enlarge_r... eapply ord_trans...
  - rewrite ordTet0_suc, ordTetL_suc...
    apply ordExp_preserve_lt... eapply ord_trans...
Qed.

Lemma ordTet0_eq_ordTetL_ω : ∀ ξ ι ⋵ 𝐎𝐍, 1 ∈ ι → ι ∈ ξ → (ξ ^^⁰ ω) ι = ξ ^^ᴸ ω.
Proof with neauto.
  intros ξ Hξ ι Hι Hι1 Hιξ.
  rewrite ordTet0_limit, ordTetL_limit...
  ext; apply FUnionE in H as [n [Hn H]].
  - eapply FUnionI... eapply ord_trans...
    apply ordTet0_lt_ordTetL_n... eapply ord_trans...
  - apply (FUnionI _ _ n⁺). apply ω_inductive...
    eapply ord_trans... apply ordTet0_gt_ordTetL_n...
Qed.

(** 无限结合律，左侧严格放大 **)

Lemma ordAdd_arbitrary_assoc : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, α + α ⋅ n = α ⋅ n + α.
Proof with auto.
  intros α Hα n Hn. ω_induction n.
  - rewrite ordMul_0_r, ordAdd_0_r, ordAdd_0_l...
  - rewrite ordMul_suc... rewrite <- IH at 2... rewrite ordAdd_assoc...
Qed.

Lemma ordAdd_enlarge_l_strictly : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ∀β ∈ α ⋅ n, β ∈ α + β.
Proof with neauto; try congruence.
  intros α Hα n Hn. ω_induction n; intros β Hβ.
  - rewrite <- zero, ordMul_0_r in Hβ... exfalso0.
  - destruct (classic (β ∈ α ⋅ m)). apply IH...
    assert (Hoβ: β ⋵ 𝐎𝐍). apply (ord_is_ords (α ⋅ m⁺))...
    rewrite ordMul_suc, <- ordAdd_arbitrary_assoc in Hβ...
    apply ord_le_iff_not_gt in H as []...
    apply (ordAdd_preserve_lt α) in H... eapply ord_trans...
Qed.

Lemma ordMul_arbitrary_assoc : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, α ⋅ α ^ n = α ^ n ⋅ α.
Proof with auto.
  intros α Hα n Hn. ω_induction n.
  - rewrite ordExp_0_r, ordMul_1_r, ordMul_1_l...
  - rewrite ordExp_suc... rewrite <- IH at 2... rewrite ordMul_assoc...
Qed.

Lemma ordMul_enlarge_l_strictly : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ∀β ∈ α ^ n, β ≠ 0 → β ∈ α ⋅ β.
Proof with neauto; try congruence.
  intros α Hα n Hn β Hβ Hβ0.
  destruct (classic (α = 0)) as [|Hα0]. {
    subst. destruct (classic (n = 0)). {
      subst. rewrite ordExp_0_r in Hβ...
      rewrite one in Hβ. apply SingE in Hβ. exfalso...
    }
    rewrite ordExp_0_l in Hβ... exfalso0.
  }
  generalize dependent β.
  ω_induction n; intros β Hβ Hβ0.
  - rewrite <- zero, ordExp_0_r in Hβ...
    rewrite one in Hβ. apply SingE in Hβ. exfalso...
  - destruct (classic (β ∈ α ^ m)). apply IH...
    assert (Hoβ: β ⋵ 𝐎𝐍). apply (ord_is_ords (α ^ m⁺))...
    rewrite ordExp_suc, <- ordMul_arbitrary_assoc in Hβ...
    apply ord_le_iff_not_gt in H as []...
    apply (ordMul_preserve_lt α) in H... eapply ord_trans...
Qed.

Lemma ordExp_enlarge_l_strictly : ∀α ⋵ 𝐎𝐍, 1 ∈ α → ∀n ∈ ω, ∀β ∈ α ^^ᴸ n, β ∈ α ^ β.
Proof with neauto; try congruence.
  intros α Hα Hα1 n Hn. ω_induction n; intros x Hx.
  - destruct (classic (x = 0)). {
      subst. rewrite ordExp_0_r, pred, pred...
    }
    rewrite <- zero, ordTetL_0 in Hx...
    apply ordExp_enlarge_lt... 1-2: eapply ord_is_ords...
  - destruct (classic (x ∈ α ^^ᴸ m)). apply IH...
    assert (Hox: x ⋵ 𝐎𝐍). apply (ord_is_ords (α ^^ᴸ m⁺))...
    rewrite ordTetL_suc in Hx...
    apply ord_le_iff_not_gt in H as []...
    apply (ordExp_preserve_lt α) in H... eapply ord_trans...
Qed.

(** 吸收律 **)

(* Those α that ω ⋸ α are all fixed points for n_addition.
  Please see also LargeOrdinal/LowerFixedPoint.v *)
Theorem ordAdd_1_absorption : ∀α ⋵ 𝐎𝐍, ω ⋸ α → 1 + α = α.
Proof with neauto.
  ord_induction. intros α Hα IH Hle.
  destruct Hle; revgoals. {
    subst. apply ordAdd_1_ω.
  }
  ord_destruct α.
  - subst. exfalso0.
  - destruct Hsuc as [β [Hβ Heq]]. subst.
    rewrite ordAdd_suc, IH... apply ord_le_iff_lt_suc...
  - rewrite ordAdd_limit... ext ξ Hξ.
    + apply FUnionE in Hξ as [β [Hβ Hξ]].
      destruct (classic (β ∈ ω)).
      * eapply ord_trans... rewrite ordAdd_1_l...
        apply sucord_in_limord...
      * rewrite IH in Hξ... eapply ord_trans...
        apply ord_le_iff_not_gt... eapply ord_is_ords...
    + assert (Hξo: ξ ⋵ 𝐎𝐍). eapply ord_is_ords...
      destruct (classic (ξ ∈ ω)) as [|Hle].
      * eapply FUnionI... rewrite ordAdd_1_l...
      * apply ord_le_iff_not_gt in Hle...
        eapply FUnionI. apply sucord_in_limord...
        rewrite ordAdd_suc, IH...
Qed.

Corollary ordAdd_n_absorption : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ω ⋸ α → n + α = α.
Proof with neauto.
  intros α Hα n Hn Hle.
  ω_induction n. rewrite ordAdd_0_l...
  rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_absorption...
Qed.

(* ω幂对加法的吸收律 *)
Corollary ordAdd_ω_pow_absorption : ∀β ⋵ 𝐎𝐍, ∀α ∈ β, ω ^ α + ω ^ β = ω ^ β.
Proof with neauto.
  intros β Hβ α Hlt. assert (α ⋸ β)...
  assert (Hα: α ⋵ 𝐎𝐍). eapply ord_is_ords...
  apply ord_subtraction in H as [δ [[Hδ Hsum] _]]... subst.
  rewrite <- ordExp_add... rewrite <- (ordMul_1_r (ω ^ α)) at 1...
  rewrite <- ordMul_distr... f_equal. apply ordAdd_1_absorption...
  rewrite <- ordExp_1_r at 1 3... apply ordExp_preserve_le_r...
  apply ord_le_iff_not_gt... intros H.
  rewrite one in H. apply SingE in H. subst.
  rewrite ordAdd_0_r in Hlt... eapply ord_irrefl...
Qed.

Theorem ordMul_n_ω : ∀n ∈ ω, n ≠ 0 → n ⋅ ω = ω.
Proof with neauto.
  intros n Hn. ω_induction n; intros H0. exfalso...
  assert (Hmp: m⁺ ∈ ω). apply ω_inductive...
  ext.
  - rewrite ordMul_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply ω_trans... rewrite fin_ordMul_eq_mul...
  - destruct (classic (m = 0)).
    + subst. rewrite ordMul_1_l...
    + rewrite <- IH, ordMul_limit in H... rewrite ordMul_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      rewrite fin_ordMul_eq_mul, fin_ordMul_eq_mul...
      apply mul_preserve_lt... intros H. subst.
      rewrite ordMul_0_r in Hx... exfalso0.
Qed.

Theorem ordExp_n_ω : ∀n ∈ ω, 1 ∈ n → n ^ ω = ω.
Proof with neauto.
  intros n Hn. ω_induction n; intros H1. exfalso0.
  assert (Hmp: m⁺ ∈ ω). apply ω_inductive...
  ext.
  - rewrite ordExp_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply ω_trans... rewrite fin_ordExp_eq_exp...
  - destruct (classic (x = 0)) as [|Hx0]. {
      subst. apply ord_neq_0_gt_0... intros H0.
      apply ordExp_eq_0 in H0... eapply suc_neq_0...
    }
    destruct (classic (m = 0)) as [|Hm0]. {
      rewrite H0 in H1. exfalso. apply (nat_irrefl 1)...
    }
    destruct (classic (m = 1)) as [|Hm1]. {
      rewrite H0. rewrite <- ordExp_2_ω in H...
    }
    rewrite <- IH, ordExp_limit in H... rewrite ordExp_limit...
    apply FUnionE in H as [k [Hk Hx]].
    eapply FUnionI... eapply ord_trans...
    rewrite fin_ordExp_eq_exp, fin_ordExp_eq_exp...
    apply exp_preserve_base_lt... intros H. subst.
    rewrite ordExp_0_r in Hx...
    rewrite one in Hx. apply SingE in Hx...
Qed.

Theorem ordTetL_n_ω : ∀n ∈ ω, 1 ∈ n → n ^^ᴸ ω = ω.
Proof with neauto.
  intros n Hn. ω_induction n; intros H1. exfalso0.
  assert (Hmp: m⁺ ∈ ω). apply ω_inductive...
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply ω_trans...
  - apply le_iff_lt_suc in H1 as []...
    + rewrite <- IH, ordTetL_limit in H...
      rewrite ordTetL_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      apply tetL_preserve_base_lt... apply ord_gt_1_neq_0_1...
    + subst. rewrite <- ordTetL_2_ω in H...
Qed.

Theorem ordTetR_n_ω : ∀n ∈ ω, 1 ∈ n → n ^^ᴿ ω = ω.
Proof with auto.
  intros n Hn Hn1. rewrite ordTetR_normal_form...
  2: apply ord_gt_1_neq_0_1 in Hn1 as []...
  rewrite ordExp_n_ω, ordExp_n_ω...
Qed.

Fact ordTetR_n_ω_eq_L : ∀n ∈ ω, n ≠ 0 → n ^^ᴿ ω = n ^^ᴸ ω.
Proof with auto.
  intros n Hn Hn0.
  destruct (classic (n = 1)) as [|Hn1]. {
    subst. rewrite ordTetL_1_l, ordTetR_1_l...
  }
  rewrite ordTetR_n_ω, ordTetL_n_ω...
Qed.

Fact ordTetR_ω_ω_eq_L : ω ^^ᴿ ω = ω ^^ᴸ 2.
Proof with nauto.
  rewrite ordTetR_normal_form...
  repeat rewrite pred, ordTetL_suc... rewrite ordTetL_0...
Qed.

Fact ordTetR_ω_ω_lt_L : ω ^^ᴿ ω ∈ ω ^^ᴸ ω.
Proof with nauto.
  rewrite ordTetL_limit, ordTetR_ω_ω_eq_L...
  apply (FUnionI _ _ 3)...
  apply ordTetL_n_ascending...
Qed.
