(** Coq coding by choukh, Aug 2021 **)

Require Export ZFC.Elements.EST8_7.
Import OrdinalClass ğğOperation.

Local Hint Resolve
  add_ran mul_ran exp_ran
  ordAdd_ran ordMul_ran preOrdExp_ran ordExp_ran : core.

(** å·¦è¿­ä»£å¹‚æ¬¡ **)
(* see also LargeOrdinals/NormalTetration.v *)
Definition OrdTetL := Î» Î±, Operation Î± (OrdExp Î±).
Notation "Î± ^^á´¸ Î²" := (OrdTetL Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTetL_0 : âˆ€Î± â‹µ ğğ, Î± ^^á´¸ 0 = Î±.
Proof. intros Î± H. apply operation_0; auto. Qed.

Theorem ordTetL_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î²âº = Î± ^ (Î± ^^á´¸ Î²).
Proof. intros Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTetL_limit : âˆ€Î± â‹µ ğğ, continuous (OrdTetL Î±).
Proof. intros Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTetL_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² â‹µ ğğ.
Proof. intros Î± HÎ± Î² HÎ². apply operation_operative; auto. Qed.
Local Hint Resolve ordTetL_ran : core.

Theorem ordTetL_1_r : âˆ€Î± â‹µ ğğ, Î± ^^á´¸ 1 = Î± ^ Î±.
Proof.
  intros Î± H. rewrite pred, ordTetL_suc, ordTetL_0; auto.
Qed.

Theorem ordTetL_1_l : âˆ€Î± â‹µ ğğ, 1 ^^á´¸ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordTetL_suc, ordExp_1_l...
  - rewrite ordTetL_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + rewrite one in H. apply SingE in H. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordTetL_0, pred...
Qed.

Lemma ordTetL_eq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² = 0 â†’ Î± = 0.
Proof with eauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTetL_0 in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTetL_suc in H...
    apply ordExp_eq_0 in H...
  - rewrite ordTetL_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [Î³ HÎ³].
      assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in HÎ³...
      eapply repl_eq_1 in HÎ³ as H0...
Qed.

Lemma ordAdd_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± + Î² = 1 â†’
  Î± = 0 âˆ§ Î² = 1 âˆ¨ Î± = 1 âˆ§ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H.
  ord_destruct Î±; subst.
  - rewrite ordAdd_0_l in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    ord_destruct Î².
    + subst. rewrite ordAdd_0_r in H...
    + exfalso. destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
      rewrite <- (ordAdd_1_r Î´), <- ordAdd_assoc in H...
      rewrite (ordAdd_1_r), pred in H...
      apply ord_suc_injective in H...
      apply ordAdd_eq_0 in H as []... eapply suc_neq_0...
    + exfalso. apply limord_ge_Ï‰ in Hlim...
      apply (ord_irrefl 1)... rewrite <- H at 2.
      eapply ord_trans_lt_le. auto. apply embed_ran.
      eapply ord_trans_le... apply ordAdd_enlarge_l...
  - exfalso.
    destruct (classic (Î² = 0)). {
      subst. rewrite ordAdd_0_r in H...
      apply (limord_iff_not_sucord Î±)... exists 0...
    }
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans. auto. apply embed_ran.
    eapply ord_trans_le_lt... apply ordAdd_enlarge_r...
Qed.

Lemma ordMul_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± â‹… Î² = 1 â†’ Î± = 1 âˆ§ Î² = 1.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î².
  - subst. rewrite ordMul_0_r in H... exfalso...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordMul_suc in H...
    apply ordAdd_eq_1 in H as [[H0 H1]|[H1 H0]]...
    + apply ordMul_eq_0 in H0 as []...
      * exfalso. subst...
      * split... subst...
    + rewrite H0 in H1. rewrite ordMul_0_l in H1... exfalso...
  - exfalso.
    destruct (classic (Î± = 0)). subst. rewrite ordMul_0_l in H...
    destruct (classic (Î± = 1)). {
      subst. rewrite ordMul_1_l in H...
      apply (limord_iff_not_sucord Î²)... exists 0...
    }
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply ordMul_enlarge_l...
Qed.

Lemma preOrdExp_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^áµ– Î² = 1 â†’
  Î± = 1 âˆ¨ Î² = 0 âˆ¨ Î² â‰  0 âˆ§ Î² â‹µ ğğË¡â±áµ âˆ§ Î± = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î²...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite preOrdExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (Î± = 0))...
    destruct (classic (Î± = 1))...
    exfalso. apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto. apply embed_ran.
    eapply ord_trans_le... apply preOrdExp_enlarge_l...
Qed.

Lemma ordExp_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^ Î² = 1 â†’ Î± = 1 âˆ¨ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H. ord_destruct Î².
  - subst. rewrite ordExp_0_r in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordExp_suc in H...
    apply ordMul_eq_1 in H as []...
  - destruct (classic (Î± = 1))...
    exfalso. unfold OrdExp in H.
    destruct (ixm (Î± = 0)); destruct (ixm (Î² = 0))...
    apply limord_ge_Ï‰ in Hlim...
    apply (ord_irrefl 1)... rewrite <- H at 2.
    eapply ord_trans_lt_le. auto.
    apply embed_ran. eapply ord_trans_le...
    apply preOrdExp_enlarge_l...
Qed.

Lemma ordTetL_gt_1 : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ 1 âˆˆ Î± ^^á´¸ Î².
Proof with neauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH HÎ±1.
  ord_destruct Î².
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTetL_suc... eapply ord_trans...
    apply ordExp_enlarge_r...
  - rewrite ordTetL_limit...
    apply EmptyNE in H0 as [Î³ HÎ³].
    assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTetL_suc... apply ordExp_enlarge_l...
Qed.

Theorem ordTetL_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¸ Î² = 1 â†’ Î± = 0 âˆ¨ Î± = 1.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H.
  destruct (classic (Î± = 0))...
  destruct (classic (Î± = 1))... exfalso.
  apply (ord_irrefl 1)... rewrite <- H at 2.
  apply ordTetL_gt_1...
Qed.

Fact ordTetL_is_limord_l : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  0 â†’ ğœ† ^^á´¸ Î± â‹µ ğğË¡â±áµ.
Proof with nauto.
  ord_induction. intros Î± HÎ± IH ğœ† Hğœ† H0.
  ord_destruct Î±.
  - subst. rewrite ordTetL_0...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordTetL_suc... apply ordExp_is_limord_l...
    apply ordTetL_gt_1... eapply ord_trans_lt_le. auto.
    apply embed_ran. apply limord_ge_Ï‰...
  - rewrite ordTetL_limit...
    apply union_of_limords_is_limord. intros x Hx.
    apply ReplAx in Hx as [Î² [HÎ² Hx]]. subst x. apply IH...
Qed.

Lemma tetL_ran : âˆ€ m n âˆˆ Ï‰, m ^^á´¸ n âˆˆ Ï‰.
Proof with auto.
  intros k Hk n Hn. Ï‰_induction n.
  - rewrite ordTetL_0...
  - rewrite ordTetL_suc, fin_ordExp_eq_exp...
Qed.
Local Hint Resolve tetL_ran : core.

Lemma tetL_preserve_base_lt : âˆ€ m n p âˆˆ Ï‰, m â‰  0 â†’ n â‰  0 â†’
  m âˆˆ n â†” m ^^á´¸ p âˆˆ n ^^á´¸ p.
Proof with eauto.
  assert (Hright: âˆ€ m n p âˆˆ Ï‰, m â‰  0 â†’ n â‰  0 â†’ m âˆˆ n â†’ m ^^á´¸ p âˆˆ n ^^á´¸ p). {
    intros m Hm n Hn p Hp Hm0 Hn0 H.
    generalize dependent n. generalize dependent m.
    Ï‰_induction p; intros k Hk Hk0 n Hn Hn0 H.
    - rewrite ordTetL_0, ordTetL_0...
    - assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
      assert (H0: k ^^á´¸ m â‰  0). intros H0. apply ordTetL_eq_0 in H0...
      rewrite ordTetL_suc, ordTetL_suc...
      repeat rewrite fin_ordExp_eq_exp...
      eapply lt_le_trans. auto.
      apply exp_preserve_base_lt; revgoals...
      apply exp_preserve_exponent_le...
  }
  intros m Hm n Hn p Hp Hm0 Hn0. split. apply Hright...
  intros H. destruct (classic (m = n)).
  - subst. exfalso. eapply nat_irrefl; revgoals...
  - apply nat_connected in H0 as []...
    pose proof (Hright n Hn m Hm p Hp Hn0 Hm0 H0).
    exfalso. eapply nat_not_lt_gt; revgoals...
Qed.

Lemma tetL_enlarge_l : âˆ€ m n âˆˆ Ï‰, 1 âˆˆ n â†’ m âˆˆ n ^^á´¸ m.
Proof with neauto.
  intros k Hk. Ï‰_induction k; intros n Hn Hn0.
  - rewrite ordTetL_0... apply ord_neq_0_gt_0...
    apply ord_gt_1_neq_0_1...
  - rewrite ordTetL_suc... pose proof (IH n Hn Hn0).
    apply lt_iff_suc_le in H...
    eapply ord_trans_le_lt. auto. apply H.
    rewrite fin_ordExp_eq_exp... apply exp_enlarge_l...
Qed.

Fact ordTetL_2_Ï‰ : 2 ^^á´¸ Ï‰ = Ï‰.
Proof with neauto.
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply Ï‰_trans...
  - rewrite ordTetL_limit... eapply FUnionI...
    apply tetL_enlarge_l... rewrite (pred 2)...
Qed.

Theorem ordTetL_n_ascending : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ âˆ€n âˆˆ Ï‰, Î± ^^á´¸ n âˆˆ Î± ^^á´¸ nâº.
Proof with neauto.
  intros Î± HÎ± HÎ±1 n Hn. Ï‰_induction n.
  - rewrite ordTetL_suc, <- zero, ordTetL_0... apply ordExp_enlarge_r...
  - rewrite ordTetL_suc, ordTetL_suc... apply ordExp_preserve_lt...
Qed.

Theorem ordTetL_n_monotone : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ âˆ€n âˆˆ Ï‰, âˆ€m âˆˆ n, Î± ^^á´¸ m âˆˆ Î± ^^á´¸ n.
Proof with eauto.
  intros Î± HÎ± HÎ±1 n Hn. Ï‰_induction n; intros k Hlt.
  - exfalso0.
  - assert (Hk: k âˆˆ Ï‰). eapply Ï‰_trans... apply Ï‰_inductive...
    apply le_iff_lt_suc in Hlt as []...
    + eapply ord_trans. auto. apply IH...
      apply ordTetL_n_ascending...
    + subst. apply ordTetL_n_ascending...
Qed.

Theorem ordTetL_weakly_increasing : âˆ€ Î± Î² Î³ â‹µ ğğ, Î± â‰  0 â†’ Î² âˆˆ Î³ â†’ Î± ^^á´¸ Î² â‹¸ Î± ^^á´¸ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ². ord_induction. intros Î³ HÎ³ IH HÎ±0 Hlt.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTetL_1_l, ordTetL_1_l...
  }
  ord_destruct Î³.
  - subst. exfalso0.
  - destruct Hsuc as [Î´ [HÎ´ H]]. subst.
    apply ord_le_iff_lt_suc in Hlt as []...
    + rewrite ordTetL_suc... eapply ord_trans_le; revgoals. 3: auto.
      apply ordExp_preserve_le_r; revgoals. apply IH... 1-4: auto.
      apply ordExp_enlarge_l...
    + subst. rewrite ordTetL_suc... apply ordExp_enlarge_l...
  - apply ord_le_iff_sub... intros x Hx.
    rewrite ordTetL_limit... eapply FUnionI...
Qed.

Corollary ordTetL_enlarge_r : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ Î² â‰  0 â†’ Î± âˆˆ Î± ^^á´¸ Î².
Proof with neauto.
  intros Î± HÎ± Î² HÎ² HÎ±1 HÎ²0.
  destruct (classic (Î² = 1)). {
    subst. rewrite ordTetL_1_r... apply ordExp_enlarge_r...
  }
  eapply (ord_trans_lt_le _ (Î± ^ Î±))... apply ordExp_enlarge_r...
  rewrite <- ordTetL_1_r... apply ordTetL_weakly_increasing...
  apply ord_gt_1_neq_0_1...
Qed.

Lemma ordTetL_exp_r_le_l : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’
  âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Î± ^^á´¸ n ^ Î± â‹¸ Î± ^ Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±1 n Hn.
  Ï‰_induction n; intros Hn0. exfalso...
  rewrite ordTetL_suc, ordExp_mul...
  apply ordExp_preserve_le_r...
  assert (HÎ±2: Embed 2 â‹¸ Î±). apply ord_suc_correct...
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_0, <- ordExp_2_r...
    apply ordExp_preserve_le_r...
  }
  assert (Ht0: Î± ^^á´¸ m â‰  0). {
    intros H. apply ordTetL_eq_0 in H... subst. exfalso0.
  }
  assert (Ht1: Î± ^^á´¸ m â‰  1). {
    intros H. apply ord_gt_1_neq_0_1 in HÎ±1 as []...
    apply ordTetL_eq_1 in H as []...
  }
  eapply ord_trans_le; revgoals. apply IH... 2: auto.
  eapply ord_trans_le. auto. left. apply ordMul_preserve_lt; revgoals.
  apply (ordTetL_enlarge_r Î± HÎ± m)... 1-4: auto.
  rewrite <- ordExp_2_r... apply ordExp_preserve_le_r...
Qed.

Lemma ordTetL_exp_r_lt_l : âˆ€Î± â‹µ ğğ, 2 âˆˆ Î± â†’
  âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Î± ^^á´¸ n ^ Î± âˆˆ Î± ^ Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±2 n Hn.
  assert (HÎ±1: 1 âˆˆ Î±). {
    eapply ord_trans. auto. apply suc_has_n. apply HÎ±2.
  }
  Ï‰_induction n; intros Hn0. exfalso...
  rewrite ordTetL_suc, ordExp_mul...
  apply ordExp_preserve_lt...
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_0, <- ordExp_2_r...
    apply ordExp_preserve_lt...
  }
  assert (Ht0: Î± ^^á´¸ m â‰  0). {
    intros H. apply ordTetL_eq_0 in H... subst. exfalso0.
  }
  assert (Ht1: Î± ^^á´¸ m â‰  1). {
    intros H. apply ord_gt_1_neq_0_1 in HÎ±1 as []...
    apply ordTetL_eq_1 in H as []...
  }
  eapply ord_trans; revgoals. apply IH... 2: auto.
  eapply ord_trans. auto. apply ordMul_preserve_lt; revgoals.
  apply (ordTetL_enlarge_r Î± HÎ± m)... 1-4: auto.
  rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
Qed.

(** å³è¿­ä»£å¹‚æ¬¡ **)
Definition OrdTetR := Î» Î±, Operation Î± (Î» Î¾, Î¾ ^ Î±).
Notation "Î± ^^á´¿ Î²" := (OrdTetR Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTetR_0 : âˆ€Î± â‹µ ğğ, Î± ^^á´¿ 0 = Î±.
Proof. intros Î± H. apply operation_0; auto. Qed.

Theorem ordTetR_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¿ Î²âº = (Î± ^^á´¿ Î²) ^ Î±.
Proof. intros Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTetR_limit : âˆ€Î± â‹µ ğğ, continuous (OrdTetR Î±).
Proof. intros Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTetR_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^^á´¿ Î² â‹µ ğğ.
Proof. intros Î± HÎ± Î² HÎ². apply operation_operative; auto. Qed.
Local Hint Resolve ordTetR_ran : core.

Theorem ordTetR_1_r : âˆ€Î± â‹µ ğğ, Î± ^^á´¿ 1 = Î± ^ Î±.
Proof.
  intros Î± H. rewrite pred, ordTetR_suc, ordTetR_0; auto.
Qed.

Theorem ordTetR_1_l : âˆ€Î± â‹µ ğğ, 1 ^^á´¿ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite ordTetR_0...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordTetR_suc, ordExp_1_r...
  - rewrite ordTetR_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + rewrite one in H. apply SingE in H. subst.
      eapply FUnionI. apply ord_neq_0_gt_0...
      rewrite ordTetR_0, pred...
Qed.

Fact ordTetR_n_le_L : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Î± ^^á´¿ n â‹¸ Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±0 n Hn.
  Ï‰_induction n; intros Hn0. exfalso...
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTetL_1_l, ordTetR_1_l...
  }
  destruct (classic (m = 0)) as [|Hm0]. {
    subst. rewrite ordTetL_1_r, ordTetR_1_r...
  }
  rewrite ordTetL_suc, ordTetR_suc...
  eapply ord_trans_le. auto.
  apply ordExp_preserve_le_l; revgoals.
  apply IH... 1-3: auto. apply ordTetL_exp_r_le_l...
Qed.

Fact ordTetR_n_lt_L : âˆ€Î± â‹µ ğğ, 2 âˆˆ Î± â†’ âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ Î± ^^á´¿ n âˆˆ Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±2 n Hn.
  assert (HÎ±1: 1 âˆˆ Î±). {
    eapply ord_trans. auto. apply suc_has_n. apply HÎ±2.
  }
  Ï‰_induction n; intros Hn1. exfalso0.
  apply ord_le_iff_lt_suc in Hn1 as []...
  - rewrite ordTetL_suc, ordTetR_suc...
    eapply ord_trans_le_lt. auto.
    apply ordExp_preserve_le_l; revgoals.
    left. apply IH... 1-3: auto.
    apply ordTetL_exp_r_lt_l... apply ord_gt_1_neq_0_1...
  - subst. rewrite ordTetL_suc, ordTetR_suc...
    rewrite ordTetL_1_r, ordTetR_1_r, ordExp_mul...
    apply ordExp_preserve_lt...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
Qed.

Fact ordTetR_normal_form : âˆ€ Î± Î² â‹µ ğğ, Î± â‰  0 â†’ Î± ^^á´¿ Î² = Î± ^ Î± ^ Î².
Proof with eauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH HÎ±0.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTetR_1_l, ordExp_1_l...
  }
  ord_destruct Î².
  - subst. rewrite ordTetR_0, ordExp_0_r, ordExp_1_r...
  - destruct Hsuc as [Î³ [HÎ³ H]]. subst.
    rewrite ordTetR_suc, IH, ordExp_mul, ordExp_suc...
  - rewrite ordTetR_limit, ordExp_limit...
    2: apply ordExp_is_limord_r...
    2: intros H; apply ordExp_eq_0 in H...
    ext.
    + apply FUnionE in H as [Î³ [HÎ³ H]].
      assert (HoÎ³: Î³ â‹µ ğğ). apply (ord_is_ords Î²)...
      rewrite IH in H... eapply FUnionI...
      apply ordExp_preserve_lt...
    + apply FUnionE in H as [Î³ [HÎ³ Hx]].
      assert (HoÎ³: Î³ â‹µ ğğ). apply (ord_is_ords (Î± ^ Î²))...
      rewrite ordExp_limit in HÎ³...
      apply FUnionE in HÎ³ as [Î´ [HÎ´ HÎ³]].
      assert (HoÎ´: Î´ â‹µ ğğ). apply (ord_is_ords Î²)...
      eapply FUnionI... rewrite IH...
      eapply ord_trans... apply ordExp_preserve_lt...
Qed.

(** æŒ‡å®šé¦–é¡¹è¿­ä»£å¹‚æ¬¡ **)
(* Î± ^ Î± ^ ... ^ Î± ^ Î¹ *)
Definition OrdTet0 := Î» Î± Î² Î¹, Operation Î¹ (OrdExp Î±) Î².
Notation "Î± ^^â° Î²" := (OrdTet0 Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTet0_0 : âˆ€ Î¹ Î± â‹µ ğğ, (Î± ^^â° 0) Î¹ = Î¹.
Proof. intros Î¹ HÎ¹ Î± HÎ±. apply operation_0; auto. Qed.

Theorem ordTet0_suc : âˆ€ Î¹ Î± Î² â‹µ ğğ, (Î± ^^â° Î²âº) Î¹ = Î± ^ (Î± ^^â° Î²) Î¹.
Proof. intros Î¹ HÎ¹ Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTet0_limit : âˆ€ Î¹ Î± â‹µ ğğ, continuous (Î» Î², (Î± ^^â° Î²) Î¹).
Proof. intros Î¹ HÎ¹ Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTet0_ran : âˆ€ Î¹ Î± Î² â‹µ ğğ, (Î± ^^â° Î²) Î¹ â‹µ ğğ.
Proof. intros Î¹ HÎ¹ Î± HÎ± Î² HÎ². apply operation_operative; auto. Qed.
Local Hint Resolve ordTet0_ran : core.

Theorem ordTet0_1 : âˆ€ Î¹ Î± â‹µ ğğ, (Î± ^^â° 1) Î¹ = Î± ^ Î¹.
Proof.
  intros Î¹ HÎ¹ Î± HÎ±. rewrite pred, ordTet0_suc, ordTet0_0; auto.
Qed.

Lemma ordTet0_lt_ordTetL_n : âˆ€ Î¾ Î¹ â‹µ ğğ, 1 âˆˆ Î¾ â†’ Î¹ âˆˆ Î¾ â†’ âˆ€n âˆˆ Ï‰, (Î¾ ^^â° n) Î¹ âˆˆ Î¾ ^^á´¸ n.
Proof with nauto.
  intros Î¾ HÎ¾ Î¹ HÎ¹ HÎ¾1 HÎ¹Î¾ n Hn.
  Ï‰_induction n.
  - rewrite ordTet0_0, ordTetL_0...
  - rewrite ordTet0_suc, ordTetL_suc...
    apply ordExp_preserve_lt...
Qed.

Lemma ordTet0_gt_ordTetL_n : âˆ€ Î¾ Î¹ â‹µ ğğ, 1 âˆˆ Î¹ â†’ Î¹ âˆˆ Î¾ â†’ âˆ€n âˆˆ Ï‰, Î¾ ^^á´¸ n âˆˆ (Î¾ ^^â° nâº) Î¹.
Proof with neauto.
  intros Î¾ HÎ¾ Î¹ HÎ¹ HÎ¹1 HÎ¹Î¾ n Hn.
  Ï‰_induction n.
  - rewrite ordTet0_1, ordTetL_0...
    apply ordExp_enlarge_r... eapply ord_trans...
  - rewrite ordTet0_suc, ordTetL_suc...
    apply ordExp_preserve_lt... eapply ord_trans...
Qed.

Lemma ordTet0_eq_ordTetL_Ï‰ : âˆ€ Î¾ Î¹ â‹µ ğğ, 1 âˆˆ Î¹ â†’ Î¹ âˆˆ Î¾ â†’ (Î¾ ^^â° Ï‰) Î¹ = Î¾ ^^á´¸ Ï‰.
Proof with neauto.
  intros Î¾ HÎ¾ Î¹ HÎ¹ HÎ¹1 HÎ¹Î¾.
  rewrite ordTet0_limit, ordTetL_limit...
  ext; apply FUnionE in H as [n [Hn H]].
  - eapply FUnionI... eapply ord_trans...
    apply ordTet0_lt_ordTetL_n... eapply ord_trans...
  - apply (FUnionI _ _ nâº). apply Ï‰_inductive...
    eapply ord_trans... apply ordTet0_gt_ordTetL_n...
Qed.

(** æ— é™ç»“åˆå¾‹ï¼Œå·¦ä¾§ä¸¥æ ¼æ”¾å¤§ **)

Lemma ordAdd_arbitrary_assoc : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Î± + Î± â‹… n = Î± â‹… n + Î±.
Proof with auto.
  intros Î± HÎ± n Hn. Ï‰_induction n.
  - rewrite ordMul_0_r, ordAdd_0_r, ordAdd_0_l...
  - rewrite ordMul_suc... rewrite <- IH at 2... rewrite ordAdd_assoc...
Qed.

Lemma ordAdd_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± â‹… n, Î² âˆˆ Î± + Î².
Proof with neauto; try congruence.
  intros Î± HÎ± n Hn. Ï‰_induction n; intros Î² HÎ².
  - rewrite <- zero, ordMul_0_r in HÎ²... exfalso0.
  - destruct (classic (Î² âˆˆ Î± â‹… m)). apply IH...
    assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords (Î± â‹… mâº))...
    rewrite ordMul_suc, <- ordAdd_arbitrary_assoc in HÎ²...
    apply ord_le_iff_not_gt in H as []...
    apply (ordAdd_preserve_lt Î±) in H... eapply ord_trans...
Qed.

Lemma ordMul_arbitrary_assoc : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Î± â‹… Î± ^ n = Î± ^ n â‹… Î±.
Proof with auto.
  intros Î± HÎ± n Hn. Ï‰_induction n.
  - rewrite ordExp_0_r, ordMul_1_r, ordMul_1_l...
  - rewrite ordExp_suc... rewrite <- IH at 2... rewrite ordMul_assoc...
Qed.

Lemma ordMul_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± ^ n, Î² â‰  0 â†’ Î² âˆˆ Î± â‹… Î².
Proof with neauto; try congruence.
  intros Î± HÎ± n Hn Î² HÎ² HÎ²0.
  destruct (classic (Î± = 0)) as [|HÎ±0]. {
    subst. destruct (classic (n = 0)). {
      subst. rewrite ordExp_0_r in HÎ²...
      rewrite one in HÎ². apply SingE in HÎ². exfalso...
    }
    rewrite ordExp_0_l in HÎ²... exfalso0.
  }
  generalize dependent Î².
  Ï‰_induction n; intros Î² HÎ² HÎ²0.
  - rewrite <- zero, ordExp_0_r in HÎ²...
    rewrite one in HÎ². apply SingE in HÎ². exfalso...
  - destruct (classic (Î² âˆˆ Î± ^ m)). apply IH...
    assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords (Î± ^ mâº))...
    rewrite ordExp_suc, <- ordMul_arbitrary_assoc in HÎ²...
    apply ord_le_iff_not_gt in H as []...
    apply (ordMul_preserve_lt Î±) in H... eapply ord_trans...
Qed.

Lemma ordExp_enlarge_l_strictly : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ âˆ€n âˆˆ Ï‰, âˆ€Î² âˆˆ Î± ^^á´¸ n, Î² âˆˆ Î± ^ Î².
Proof with neauto; try congruence.
  intros Î± HÎ± HÎ±1 n Hn. Ï‰_induction n; intros x Hx.
  - destruct (classic (x = 0)). {
      subst. rewrite ordExp_0_r, pred, pred...
    }
    rewrite <- zero, ordTetL_0 in Hx...
    apply ordExp_enlarge_lt... 1-2: eapply ord_is_ords...
  - destruct (classic (x âˆˆ Î± ^^á´¸ m)). apply IH...
    assert (Hox: x â‹µ ğğ). apply (ord_is_ords (Î± ^^á´¸ mâº))...
    rewrite ordTetL_suc in Hx...
    apply ord_le_iff_not_gt in H as []...
    apply (ordExp_preserve_lt Î±) in H... eapply ord_trans...
Qed.

(** å¸æ”¶å¾‹ **)

(* Those Î± that Ï‰ â‹¸ Î± are all fixed points for n_addition.
  Please see also LargeOrdinal/LowerFixedPoint.v *)
Theorem ordAdd_1_absorption : âˆ€Î± â‹µ ğğ, Ï‰ â‹¸ Î± â†’ 1 + Î± = Î±.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH Hle.
  destruct Hle; revgoals. {
    subst. apply ordAdd_1_Ï‰.
  }
  ord_destruct Î±.
  - subst. exfalso0.
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    rewrite ordAdd_suc, IH... apply ord_le_iff_lt_suc...
  - rewrite ordAdd_limit... ext Î¾ HÎ¾.
    + apply FUnionE in HÎ¾ as [Î² [HÎ² HÎ¾]].
      destruct (classic (Î² âˆˆ Ï‰)).
      * eapply ord_trans... rewrite ordAdd_1_l...
        apply sucord_in_limord...
      * rewrite IH in HÎ¾... eapply ord_trans...
        apply ord_le_iff_not_gt... eapply ord_is_ords...
    + assert (HÎ¾o: Î¾ â‹µ ğğ). eapply ord_is_ords...
      destruct (classic (Î¾ âˆˆ Ï‰)) as [|Hle].
      * eapply FUnionI... rewrite ordAdd_1_l...
      * apply ord_le_iff_not_gt in Hle...
        eapply FUnionI. apply sucord_in_limord...
        rewrite ordAdd_suc, IH...
Qed.

Corollary ordAdd_n_absorption : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, Ï‰ â‹¸ Î± â†’ n + Î± = Î±.
Proof with neauto.
  intros Î± HÎ± n Hn Hle.
  Ï‰_induction n. rewrite ordAdd_0_l...
  rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_absorption...
Qed.

(* Ï‰å¹‚å¯¹åŠ æ³•çš„å¸æ”¶å¾‹ *)
Corollary ordAdd_Ï‰_pow_absorption : âˆ€Î² â‹µ ğğ, âˆ€Î± âˆˆ Î², Ï‰ ^ Î± + Ï‰ ^ Î² = Ï‰ ^ Î².
Proof with neauto.
  intros Î² HÎ² Î± Hlt. assert (Î± â‹¸ Î²)...
  assert (HÎ±: Î± â‹µ ğğ). eapply ord_is_ords...
  apply ord_subtraction in H as [Î´ [[HÎ´ Hsum] _]]... subst.
  rewrite <- ordExp_add... rewrite <- (ordMul_1_r (Ï‰ ^ Î±)) at 1...
  rewrite <- ordMul_distr... f_equal. apply ordAdd_1_absorption...
  rewrite <- ordExp_1_r at 1 3... apply ordExp_preserve_le_r...
  apply ord_le_iff_not_gt... intros H.
  rewrite one in H. apply SingE in H. subst.
  rewrite ordAdd_0_r in Hlt... eapply ord_irrefl...
Qed.

Theorem ordMul_n_Ï‰ : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ n â‹… Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H0. exfalso...
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordMul_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply Ï‰_trans... rewrite fin_ordMul_eq_mul...
  - destruct (classic (m = 0)).
    + subst. rewrite ordMul_1_l...
    + rewrite <- IH, ordMul_limit in H... rewrite ordMul_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      rewrite fin_ordMul_eq_mul, fin_ordMul_eq_mul...
      apply mul_preserve_lt... intros H. subst.
      rewrite ordMul_0_r in Hx... exfalso0.
Qed.

Theorem ordExp_n_Ï‰ : âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ n ^ Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H1. exfalso0.
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordExp_limit in H...
    apply FUnionE in H as [k [Hk Hx]].
    eapply Ï‰_trans... rewrite fin_ordExp_eq_exp...
  - destruct (classic (x = 0)) as [|Hx0]. {
      subst. apply ord_neq_0_gt_0... intros H0.
      apply ordExp_eq_0 in H0... eapply suc_neq_0...
    }
    destruct (classic (m = 0)) as [|Hm0]. {
      rewrite H0 in H1. exfalso. apply (nat_irrefl 1)...
    }
    destruct (classic (m = 1)) as [|Hm1]. {
      rewrite H0. rewrite <- ordExp_2_Ï‰ in H...
    }
    rewrite <- IH, ordExp_limit in H... rewrite ordExp_limit...
    apply FUnionE in H as [k [Hk Hx]].
    eapply FUnionI... eapply ord_trans...
    rewrite fin_ordExp_eq_exp, fin_ordExp_eq_exp...
    apply exp_preserve_base_lt... intros H. subst.
    rewrite ordExp_0_r in Hx...
    rewrite one in Hx. apply SingE in Hx...
Qed.

Theorem ordTetL_n_Ï‰ : âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ n ^^á´¸ Ï‰ = Ï‰.
Proof with neauto.
  intros n Hn. Ï‰_induction n; intros H1. exfalso0.
  assert (Hmp: mâº âˆˆ Ï‰). apply Ï‰_inductive...
  ext.
  - rewrite ordTetL_limit in H...
    apply FUnionE in H as [k [Hk Hx]]. eapply Ï‰_trans...
  - apply le_iff_lt_suc in H1 as []...
    + rewrite <- IH, ordTetL_limit in H...
      rewrite ordTetL_limit...
      apply FUnionE in H as [k [Hk Hx]].
      eapply FUnionI... eapply ord_trans...
      apply tetL_preserve_base_lt... apply ord_gt_1_neq_0_1...
    + subst. rewrite <- ordTetL_2_Ï‰ in H...
Qed.

Theorem ordTetR_n_Ï‰ : âˆ€n âˆˆ Ï‰, 1 âˆˆ n â†’ n ^^á´¿ Ï‰ = Ï‰.
Proof with auto.
  intros n Hn Hn1. rewrite ordTetR_normal_form...
  2: apply ord_gt_1_neq_0_1 in Hn1 as []...
  rewrite ordExp_n_Ï‰, ordExp_n_Ï‰...
Qed.

Fact ordTetR_n_Ï‰_eq_L : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ n ^^á´¿ Ï‰ = n ^^á´¸ Ï‰.
Proof with auto.
  intros n Hn Hn0.
  destruct (classic (n = 1)) as [|Hn1]. {
    subst. rewrite ordTetL_1_l, ordTetR_1_l...
  }
  rewrite ordTetR_n_Ï‰, ordTetL_n_Ï‰...
Qed.

Fact ordTetR_Ï‰_Ï‰_eq_L : Ï‰ ^^á´¿ Ï‰ = Ï‰ ^^á´¸ 2.
Proof with nauto.
  rewrite ordTetR_normal_form...
  repeat rewrite pred, ordTetL_suc... rewrite ordTetL_0...
Qed.

Fact ordTetR_Ï‰_Ï‰_lt_L : Ï‰ ^^á´¿ Ï‰ âˆˆ Ï‰ ^^á´¸ Ï‰.
Proof with nauto.
  rewrite ordTetL_limit, ordTetR_Ï‰_Ï‰_eq_L...
  apply (FUnionI _ _ 3)...
  apply ordTetL_n_ascending...
Qed.
