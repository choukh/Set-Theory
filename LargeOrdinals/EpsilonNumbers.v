(** Coq coding by choukh, Sep 2021 **)

Require ZFC.Lib.OrdinalCountability.
Require Import ZFC.Elements.EST8_8.
Export OrdinalClass VeblenFixedPoint EpsilonNumber.

Local Hint Resolve
  ordAdd_ran ordMul_ran ordExp_ran ordTet_ran ε_operative : core.

(* continue from EST8_8 *)

(* ε运算的值满足ε不动点性质 *)
Lemma epsilon : ∀α ⋵ 𝐎𝐍, ω ^ ε α = ε α.
Proof. apply fixedPoint, ordExp_normal; nauto. Qed.

(* ε数大于ω *)
Lemma ε_has_ω : ∀α ⋵ 𝐎𝐍, ω ∈ ε α.
Proof with auto.
  ord_induction. intros α Hα IH.
  ord_destruct α.
  - subst. rewrite ε_0. apply ε₀_has_tower_0.
  - destruct Hsuc as [β [Hβ H]]. subst.
    eapply (ord_trans _ _ _ (ε β))...
    apply monotone_operation_ascending... apply ε_normal.
  - apply EmptyNE in H0 as [β Hβ].
    eapply (ord_trans _ _ _ (ε β))... apply ε_normal...
  Unshelve. 1-2:auto.
Qed.

(** 高阶运算的不动点同时也是低阶运算的不动点 **)

(* ε数也是ω乘法的不动点 *)
Fact epsilon_mul : ∀α ⋵ 𝐎𝐍, ω ⋅ ε α = ε α.
Proof with nauto.
  intros α Hα. rewrite <- epsilon at 1...
  rewrite <- (ordExp_1_r ω) at 1...
  rewrite <- ordExp_add, ordAdd_1_absorption...
  apply epsilon... left. apply ε_has_ω...
Qed.

(* ε数也是ω加法的不动点 *)
Fact epsilon_add : ∀α ⋵ 𝐎𝐍, ω + ε α = ε α.
Proof with nauto.
  intros α Hα. rewrite <- epsilon_mul at 1...
  rewrite <- (ordMul_1_r ω) at 1...
  rewrite <- ordMul_distr, ordAdd_1_absorption...
  apply epsilon_mul... left. apply ε_has_ω...
Qed.

(* ε数大于自然数 *)
Lemma ε_has_n : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, n ∈ ε α.
Proof.
  intros α Hα n Hn.
  eapply ord_trans; eauto. now apply ε_has_ω.
Qed.
Local Hint Resolve ε_has_n : core.

(* ε数不等于0 *)
Lemma ε_neq_0 : ∀α ⋵ 𝐎𝐍, ε α ≠ 0.
Proof.
  intros α Hα. eapply EmptyNI. exists ω. now apply ε_has_ω.
Qed.
Local Hint Resolve ε_neq_0 : core.

(* ε数是极限序数 *)
Lemma ε_is_limord : ε :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍ˡⁱᵐ.
Proof with neauto.
  intros α Hα. apply fixed_point_is_limord...
  apply ordExp_normal... intros β Hβ Heq.
  replace (FixedPoint (OrdExp ω)) with ε in Heq...
  pose proof (epsilon β⁺ (ord_suc_is_ord β Hβ)).
  rewrite Heq, ordExp_suc, epsilon in H...
  eapply (ord_irrefl (ε β ⋅ ω))...
  rewrite H at 1. rewrite <- ordAdd_1_r...
  eapply ord_trans. auto. apply ordAdd_preserve_lt; revgoals.
  apply ε_has_n... 1-3:nauto. rewrite <- ordMul_2_r...
  apply ordMul_preserve_lt...
Qed.
Local Hint Resolve ε_is_limord : core.

(** ε指数塔 **)

(* 0层ε塔 *)
Lemma ε_tower_0 : ∀α ⋵ 𝐎𝐍, ε α ^^ 0 = ε α.
Proof. intros α Hα. apply ordTet_0; auto. Qed.

(* 后继层ε塔 *)
Lemma ε_tower_suc : ∀ α β ⋵ 𝐎𝐍, ε α ^^ β⁺ = ε α ^ (ε α ^^ β).
Proof. intros α Hα. apply ordTet_suc; auto. Qed.

(* 极限层ε塔 *)
Lemma ε_tower_limit : ∀α ⋵ 𝐎𝐍, continuous (Tetration (ε α)).
Proof. intros α Hα. apply ordTet_limit; auto. Qed.

(* ε塔是序数 *)
Lemma ε_tower_ran : ∀ α β ⋵ 𝐎𝐍, ε α ^^ β ⋵ 𝐎𝐍.
Proof. auto. Qed.
Local Hint Resolve ε_tower_ran : core.

(* 有限层ε塔递增 *)
Lemma ε_tower_n_ascending : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ε α ^^ n ∈ ε α ^^ n⁺.
Proof with neauto.
  intros α Hα n Hn. ω_induction n.
  - rewrite ε_tower_suc, <- zero, ε_tower_0... apply ordExp_enlarge...
  - rewrite ε_tower_suc, ε_tower_suc... apply ordExp_preserve_lt...
Qed.

(* 有限层ε塔单调 *)
Lemma ε_tower_n_monotone : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ∀m ∈ n, ε α ^^ m ∈ ε α ^^ n.
Proof with neauto.
  intros α Hα n Hn. ω_induction n; intros k Hlt.
  - exfalso0.
  - assert (Hk: k ∈ ω). eapply ω_trans... apply ω_inductive...
    apply ord_le_iff_lt_suc in Hlt as []...
    + eapply ord_trans. auto. apply IH...
    apply ε_tower_n_ascending...
    + subst. apply ε_tower_n_ascending...
Qed.

(* 有限层ε塔大于ω *)
Lemma ε_tower_n_has_ω : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ω ∈ ε α ^^ n.
Proof with auto.
  intros α Hα n Hn. ω_induction n.
  - rewrite ε_tower_0... apply ε_has_ω...
  - eapply ord_trans. auto. apply IH. apply ε_tower_n_ascending...
Qed.
Local Hint Resolve ε_tower_n_has_ω : core.

(* 有限层ε塔大于自然数 *)
Lemma ε_tower_n_has_n : ∀α ⋵ 𝐎𝐍, ∀ m n ∈ ω, m ∈ ε α ^^ n.
Proof. intros α Hα m Hm n Hn. eapply ord_trans; eauto. Qed.
Local Hint Resolve ε_tower_n_has_n : core.

(* 有限层ε塔单射 *)
Lemma ε_tower_n_injective : ∀α ⋵ 𝐎𝐍, ∀ m n ∈ ω, ε α ^^ m = ε α ^^ n → m = n.
Proof with neauto.
  intros α Hα n Hn. ω_induction n; intros k Hk H.
  - ω_destruct k...
    rewrite ε_tower_0, ε_tower_suc in H...
    rewrite <- ordExp_1_r in H at 1...
    apply ordExp_cancel in H...
    exfalso. apply (ord_irrefl 1)... rewrite H at 2...
  - ω_destruct k.
    + rewrite ε_tower_suc, ε_tower_0 in H...
      rewrite <- ordExp_1_r in H...
      apply ordExp_cancel in H...
      exfalso. apply (ord_irrefl 1)... rewrite <- H at 2...
    + rewrite ε_tower_suc, ε_tower_suc in H...
      apply ordExp_cancel in H...
      apply IH in H... subst...
Qed.

(* εtω定义为有限层ε塔上界 *)
Definition εtω := λ α, sup {ε α ^^ n | n ∊ ω}.

(* εtω是ω层ε塔 *)
Remark εtω_is_tower : ∀α ⋵ 𝐎𝐍, εtω α = ε α ^^ ω.
Proof. intros α Hα. symmetry. apply ε_tower_limit; nauto. Qed.

(* 有限层ε塔上界是极限序数 *)
Lemma εtω_is_limord : εtω :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍ˡⁱᵐ.
Proof with auto.
  intros α Hα. apply union_of_limords_is_limord.
  intros x Hx. apply ReplAx in Hx as [n [Hn Hx]]. subst.
  apply ord_tower_is_limord...
Qed.
Local Hint Resolve εtω_is_limord : core.

(* 有限层ε塔上界是序数 *)
Corollary εtω_ran : εtω :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍.
Proof. apply εtω_is_limord. Qed.
Local Hint Resolve εtω_ran : core.

(* 有限层ε塔上界不等于0 *)
Lemma εtω_neq_0 : ∀α ⋵ 𝐎𝐍, εtω α ≠ 0.
Proof.
  intros α Hα. eapply EmptyNI. exists ω.
  apply (FUnionI _ _ 0); nauto.
Qed.
Local Hint Resolve εtω_neq_0 : core.

(* ε幂相乘的吸收律 *)
Lemma ε_pow_mul_absorption :
  ∀ α β ⋵ 𝐎𝐍, ∀n ∈ ω, ω ⋸ β → ε α ^ n ⋅ ε α ^ β = ε α ^ β.
Proof with auto.
  intros α Hα β Hβ n Hn Hωβ.
  rewrite <- epsilon, ordExp_exp, ordExp_exp, <- ordExp_add...
  f_equal. rewrite <- ordMul_distr... f_equal.
  apply ordAdd_n_absorption...
Qed.

(* 有限层ε塔上界是ε数 *)
Theorem εtω_is_ε_number : ∀α ⋵ 𝐎𝐍, εtω α ⋵ ε_number.
Proof with neauto.
  intros α Hα. split... ext.
  - rewrite ordExp_limit in H...
    apply FUnionE in H as [β [Hβ Hx]].
    apply FUnionE in Hβ as [n [Hn Hβ]].
    apply (FUnionI _ _ n⁺)... apply ω_inductive...
    rewrite ε_tower_suc... eapply ord_trans... auto.
    assert (Hoβ: β ⋵ 𝐎𝐍). eapply ord_is_ords; revgoals...
    eapply ord_trans_le_lt. auto.
    apply ordExp_preserve_le_l; revgoals.
    left. apply ε_has_ω. apply Hα. 1-3:auto.
    apply ordExp_preserve_lt...
  - apply FUnionE in H as [n [Hn Hx]].
    rewrite ordExp_limit... eapply FUnionI.
    eapply FUnionI. apply ω_inductive, Hn. apply ε_tower_n_ascending...
    generalize dependent Hx. generalize dependent x.
    apply ord_le_iff_sub...
    ω_induction n.
    + rewrite ε_tower_0 in *... rewrite epsilon...
    + rewrite ε_tower_suc in *...
      rewrite <- (epsilon α) at 1 5... rewrite ordExp_exp...
      apply ordExp_preserve_le_r...
      rewrite <- (epsilon α) at 3 7... rewrite ordExp_exp...
      eapply ordMul_preserve_le_r in IH.
      4: apply (ε_is_limord α)... 2-3:auto.
      rewrite <- (epsilon α) in IH at 3 7...
      rewrite <- ordExp_add in IH...
      ω_destruct m.
      * rewrite ε_tower_0 in *...
        eapply ord_trans_le. auto. apply IH.
        apply ordExp_preserve_le_r... left.
        rewrite <- ordMul_2_r... apply ordMul_preserve_lt...
      * cut (ε α + ε α ^^ m⁺ = ε α ⋅ ε α ^^ m⁺). congruence.
        rewrite ε_tower_suc...
        rewrite <- (epsilon α) at 1 2...
        rewrite ordExp_exp, ω_pow_add_absorption...
        rewrite <- (ordExp_1_r (ε α)) at 3...
        rewrite ε_pow_mul_absorption, <- ordExp_exp, epsilon...
        apply ordMul_enlarge...
Qed.

(* ε数的后继不是ε数 *)
Lemma suc_ε_is_not_ε_number : ∀α ⋵ 𝐎𝐍, ¬ (ε α)⁺ ⋵ ε_number.
Proof with nauto.
  intros α Hα [Hε H].
  rewrite ordExp_suc, epsilon, <- ordAdd_1_r in H...
  eapply ord_not_lt_self. 3: symmetry in H; apply H. 1-2: nauto.
  eapply ord_trans. auto. apply ordAdd_preserve_lt; revgoals.
  apply ε_has_n. apply Hα. 1-4: nauto.
  rewrite <- ordMul_2_r... apply ordMul_preserve_lt...
Qed.

(* ε数的后继小于后继ε数 *)
Lemma suc_ε_lt_ε_suc : ∀α ⋵ 𝐎𝐍, (ε α)⁺ ∈ ε α⁺.
Proof with eauto.
  intros α Hα. contra.
  apply ord_le_iff_not_gt in H as []...
  - apply ord_le_iff_lt_suc, ord_le_iff_not_gt in H...
    apply H, ε_normal...
  - eapply suc_ε_is_not_ε_number...
    rewrite <- H. apply ε_is_ε_number...
Qed.

(* ε数的两倍小于后继ε数 *)
Lemma ε_double_lt_ε_suc : ∀α ⋵ 𝐎𝐍, ε α + ε α ∈ ε α⁺.
Proof with neauto.
  intros α Hα.
  rewrite <- epsilon, <- (epsilon α⁺)...
  eapply ord_trans. auto.
  apply ordAdd_preserve_lt; revgoals.
  apply ordExp_preserve_lt; revgoals. apply suc_has_n. 1-7: nauto.
  rewrite ω_pow_add_absorption...
  apply ordExp_preserve_lt, suc_ε_lt_ε_suc...
Qed.

(* ε数的平方小于后继ε数 *)
Lemma ε_square_lt_ε_suc : ∀α ⋵ 𝐎𝐍, ε α ⋅ ε α ∈ ε α⁺.
Proof with neauto.
  intros α Hα.
  rewrite <- epsilon, <- ordExp_add, <- (epsilon α⁺)...
  apply ordExp_preserve_lt, ε_double_lt_ε_suc...
Qed.

(* ε运算在后继序数处的值 *)
Theorem ε_suc : ∀α ⋵ 𝐎𝐍, ε α⁺ = εtω α.
Proof with neauto.
  intros α Hα. ord_ext...
  - apply ε_spec... apply εtω_is_ε_number...
    intros H. apply ReplAx in H as [x [Hx H]].
    assert (Hox: x ⋵ 𝐎𝐍). apply (ord_is_ords α⁺)...
    cut (ε x ∈ εtω α). intros C. eapply ord_not_lt_self; revgoals...
    apply (FUnionI _ _ 1)... rewrite (pred 1), ε_tower_suc, ε_tower_0...
    eapply ord_trans_le_lt. auto. 2: apply ordExp_enlarge...
    apply ord_le_iff_lt_suc in Hx as []...
    left. apply ε_normal... right. congruence.
  - apply ord_le_iff_sub... intros x Hx.
    apply FUnionE in Hx as [n [Hn Hx]].
    eapply ord_trans... clear Hx.
    ω_destruct n. {
      rewrite ε_tower_0... apply ε_normal...
    }
    rewrite ε_tower_suc... rewrite <- epsilon at 1...
    rewrite <- (epsilon α⁺), ordExp_exp...
    apply ordExp_preserve_lt...
    ω_destruct n. {
      rewrite ε_tower_0... apply ε_square_lt_ε_suc...
    }
    rewrite ε_tower_suc... rewrite <- epsilon at 1 2...
    rewrite <- (epsilon α⁺), ordExp_exp, <- ordExp_add...
    apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran...
    ω_induction n.
    + rewrite ε_tower_0, <- epsilon, <- ordExp_add, <- (epsilon α⁺)...
      rewrite ω_pow_add_absorption...
      apply ordExp_preserve_lt, ε_double_lt_ε_suc...
      apply ordAdd_enlarge...
    + rewrite ε_tower_suc... rewrite <- epsilon at 1 2 3...
      rewrite <- (epsilon α⁺), ordExp_exp, <- ordExp_add...
      rewrite ω_pow_add_absorption.
      2: apply ordAdd_ran, ordMul_ran...
      * apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran...
      * apply ordAdd_enlarge, ord_neq_0_gt_0...
        eapply ord_trans. auto. apply ε_has_n... apply ordMul_enlarge...
Qed.

Module Countability.
Import Choice OrdinalCountability EST8_8.Countability.

(* 有限层可数ε塔是可数无穷 *)
Lemma ε_tower_n_cntinf : AC_II → ∀α ⋵ 𝐎𝐍, |ε α| = ℵ₀ → ∀n ∈ ω, |ε α ^^ n| = ℵ₀.
Proof with neauto.
  intros AC2 α Hα Hcinf n Hn.
  ω_induction n.
  - rewrite ε_tower_0...
  - rewrite ε_tower_suc, ordExp_limit...
    2: apply ord_tower_is_limord...
    2: apply ord_neq_0_gt_0...
    apply (add_one_member_to_funion 0). rewrite ordExp_0_r...
    apply countableI1, nat_finite...
    apply countable_union_of_cntinf...
    + exists (ε α). apply ReplAx. exists 1. split...
      apply SepI... apply SingNI... apply ordExp_1_r...
    + apply countableI2, eqnum_repl.
      apply CardAx1, remove_one_member_from_cntinf...
      intros x1 H1 x2 H2 H. apply SepE1 in H1, H2.
      apply ordExp_cancel in H...
      1-2: eapply ord_is_ords; revgoals...
    + intros A H. apply ReplAx in H as [β [Hβ H]]. subst.
      apply SepE in Hβ as [Hβ Hne]. apply SingNE in Hne.
      assert (Hoβ: β ⋵ 𝐎𝐍). eapply ord_is_ords; revgoals...
      apply ord_pow_cntinf... eapply dominate_rewrite_r.
      apply CardAx1, IH. apply dominate_sub. apply ord_lt_iff_psub...
Qed.

(* 可数下标的ε数是可数无穷 *)
Theorem ε_number_cntinf : AC_II → ∀α ⋵ 𝐎𝐍, countable α → |ε α| = ℵ₀.
Proof with neauto.
  intros AC2. ord_induction. intros α Hα IH Hcnt.
  ord_destruct α.
  - subst. rewrite ε_0. apply ε₀_cntinf...
  - destruct Hsuc as [β [Hβ H]]. subst.
    rewrite ε_suc... apply countable_union_of_cntinf...
    + exists (ε β ^^ 0). eapply ReplI...
    + apply countableI2, eqnum_repl. reflexivity.
      apply ε_tower_n_injective...
    + intros A HA. apply ReplAx in HA as [n [Hn H]]. subst.
      apply ε_tower_n_cntinf... apply IH, ord_cnt_if_suc_cnt...
  - rewrite ε_limit... apply countable_union_of_cntinf...
    + apply EmptyNE in H0 as [β Hβ]. exists (ε β). eapply ReplI...
    + apply countableI2, eqnum_repl.
      * apply countable_limit_ordinal_cntinf...
      * intros x1 H1 x2 H2. apply ε_injective.
        1-2: eapply ord_is_ords; revgoals...
    + intros A HA. apply ReplAx in HA as [β [Hβ H]]. subst.
      apply IH... eapply dominate_rewrite_r.
      apply countable_limit_ordinal_cntinf...
      apply dominate_sub. apply ord_le_iff_sub... eapply ord_is_ords...
Qed.

End Countability.
