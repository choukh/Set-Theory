(** Coq coding by choukh, Sep 2021 **)

Require Import ZFC.Elements.EST8_8.
Import OrdinalClass VeblenFixedPoint EpsilonNumber.

Local Hint Resolve
  ordAdd_ran ordMul_ran ordExp_ran ordTet_ran Îµ_operative : core.

(* continue from EST8_8 *)

(* Îµè¿ç®—çš„å€¼æ»¡è¶³Îµä¸åŠ¨ç‚¹æ€§è´¨ *)
Lemma epsilon : âˆ€Î± â‹µ ğğ, Ï‰ ^ Îµ Î± = Îµ Î±.
Proof. apply fixedPoint, ordExp_normal; nauto. Qed.

(* Îµæ•°å¤§äºÏ‰ *)
Lemma Îµ_has_Ï‰ : âˆ€Î± â‹µ ğğ, Ï‰ âˆˆ Îµ Î±.
Proof with auto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. rewrite Îµ_0. apply Îµâ‚€_has_tower_0.
  - destruct Hsuc as [Î² [HÎ² H]]. subst.
    eapply (ord_trans _ _ _ (Îµ Î²))...
    apply monotone_operation_ascending... apply Îµ_normal.
  - apply EmptyNE in H0 as [Î² HÎ²].
    eapply (ord_trans _ _ _ (Îµ Î²))... apply Îµ_normal...
  Unshelve. 1-2:auto.
Qed.

(** é«˜é˜¶è¿ç®—çš„ä¸åŠ¨ç‚¹åŒæ—¶ä¹Ÿæ˜¯ä½é˜¶è¿ç®—çš„ä¸åŠ¨ç‚¹ **)

(* Îµæ•°ä¹Ÿæ˜¯Ï‰ä¹˜æ³•çš„ä¸åŠ¨ç‚¹ *)
Fact epsilon_mul : âˆ€Î± â‹µ ğğ, Ï‰ â‹… Îµ Î± = Îµ Î±.
Proof with nauto.
  intros Î± HÎ±. rewrite <- epsilon at 1...
  rewrite <- (ordExp_1_r Ï‰) at 1...
  rewrite <- ordExp_add, ordAdd_1_absorption...
  apply epsilon... left. apply Îµ_has_Ï‰...
Qed.

(* Îµæ•°ä¹Ÿæ˜¯Ï‰åŠ æ³•çš„ä¸åŠ¨ç‚¹ *)
Fact epsilon_add : âˆ€Î± â‹µ ğğ, Ï‰ + Îµ Î± = Îµ Î±.
Proof with nauto.
  intros Î± HÎ±. rewrite <- epsilon_mul at 1...
  rewrite <- (ordMul_1_r Ï‰) at 1...
  rewrite <- ordMul_distr, ordAdd_1_absorption...
  apply epsilon_mul... left. apply Îµ_has_Ï‰...
Qed.

(* Îµæ•°å¤§äºè‡ªç„¶æ•° *)
Lemma Îµ_has_n : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, n âˆˆ Îµ Î±.
Proof.
  intros Î± HÎ± n Hn.
  eapply ord_trans; eauto. now apply Îµ_has_Ï‰.
Qed.
Local Hint Resolve Îµ_has_n : core.

(* Îµæ•°ä¸ç­‰äº0 *)
Lemma Îµ_neq_0 : âˆ€Î± â‹µ ğğ, Îµ Î± â‰  0.
Proof.
  intros Î± HÎ±. eapply EmptyNI. exists Ï‰. now apply Îµ_has_Ï‰.
Qed.
Local Hint Resolve Îµ_neq_0 : core.

(* Îµæ•°æ˜¯æé™åºæ•° *)
Lemma Îµ_is_limord : Îµ :á¶œ ğğ â‡’ ğğË¡â±áµ.
Proof with neauto.
  intros Î± HÎ±. apply fixed_point_is_limord...
  apply ordExp_normal... intros Î² HÎ² Heq.
  replace (FixedPoint (OrdExp Ï‰)) with Îµ in Heq...
  pose proof (epsilon Î²âº (ord_suc_is_ord Î² HÎ²)).
  rewrite Heq, ordExp_suc, epsilon in H...
  eapply (ord_irrefl (Îµ Î² â‹… Ï‰))...
  rewrite H at 1. rewrite <- ordAdd_1_r...
  eapply ord_trans. auto. apply ordAdd_preserve_lt; revgoals.
  apply Îµ_has_n... 1-3:nauto. rewrite <- ordMul_2_r...
  apply ordMul_preserve_lt...
Qed.
Local Hint Resolve Îµ_is_limord : core.

(** ÎµæŒ‡æ•°å¡” **)
(* Îµtn := Îµ-tower of n stairs *)
(* æœ‰é™å±‚Îµå¡” := ä»¥ä»»æ„Îµæ•°ä¸ºåº•çš„æœ‰é™å±‚æŒ‡æ•°å¡” *)

(* æœ‰é™å±‚Îµå¡”æ˜¯åºæ•° *)
Lemma Îµtn_is_ord : âˆ€n âˆˆ Ï‰, âˆ€Î± â‹µ ğğ, Îµ Î± ^^ n â‹µ ğğ.
Proof. auto. Qed.
Local Hint Resolve Îµtn_is_ord : core.

(* æœ‰é™å±‚Îµå¡”éšå±‚æ•°é€’å¢ *)
Lemma Îµtn_ascending : âˆ€n âˆˆ Ï‰, âˆ€Î± â‹µ ğğ, Îµ Î± ^^ n âˆˆ Îµ Î± ^^ nâº.
Proof with neauto; try congruence.
  intros n Hn. Ï‰_induction n; intros Î± HÎ±.
  - rewrite ordTet_suc, <- zero, ordTet_0... apply ordExp_enlarge...
  - rewrite ordTet_suc, ordTet_suc... apply ordExp_preserve_lt...
Qed.

(* æœ‰é™å±‚Îµå¡”å¤§äºÏ‰ *)
Lemma Îµtn_has_Ï‰ : âˆ€n âˆˆ Ï‰, âˆ€Î± â‹µ ğğ, Ï‰ âˆˆ Îµ Î± ^^ n.
Proof with auto.
  intros n Hn Î± HÎ±. Ï‰_induction n.
  - rewrite ordTet_0... apply Îµ_has_Ï‰...
  - eapply ord_trans. auto. apply IH. apply Îµtn_ascending...
Qed.
Local Hint Resolve Îµtn_has_Ï‰ : core.

(* æœ‰é™å±‚Îµå¡”å¤§äºè‡ªç„¶æ•° *)
Lemma Îµtn_has_n : âˆ€Î± â‹µ ğğ, âˆ€ m n âˆˆ Ï‰, m âˆˆ Îµ Î± ^^ n.
Proof. intros Î± HÎ± m Hm n Hn. eapply ord_trans; eauto. Qed.
Local Hint Resolve Îµtn_has_n : core.

(* supÎµtn := supremum of Îµ-tower of n stairs *)
(* æœ‰é™å±‚Îµå¡”ä¸Šç•Œ := ä»¥ä»»æ„Îµæ•°ä¸ºåº•çš„æœ‰é™å±‚æŒ‡æ•°å¡”åºåˆ—çš„ä¸Šç•Œ *)
Definition supÎµtn := Î» Î±, sup {Îµ Î± ^^ n | n âˆŠ Ï‰}.

(* æœ‰é™å±‚Îµå¡”ä¸Šç•Œæ˜¯æé™åºæ•° *)
Lemma soÎµtn_is_limord : supÎµtn :á¶œ ğğ â‡’ ğğË¡â±áµ.
Proof.
  intros Î± HÎ±. apply union_of_limords_is_limord.
  intros x Hx. apply ReplAx in Hx as [n [Hn Hx]]. subst.
  apply ord_tower_is_limord; auto.
Qed.
Local Hint Resolve soÎµtn_is_limord : core.

(* æœ‰é™å±‚Îµå¡”ä¸Šç•Œæ˜¯åºæ•° *)
Corollary supÎµtn_is_ord : supÎµtn :á¶œ ğğ â‡’ ğğ.
Proof. apply soÎµtn_is_limord. Qed.
Local Hint Resolve supÎµtn_is_ord : core.

(* æœ‰é™å±‚Îµå¡”ä¸Šç•Œä¸ç­‰äº0 *)
Lemma soÎµtn_neq_0 : âˆ€Î± â‹µ ğğ, supÎµtn Î± â‰  0.
Proof with nauto.
  intros Î± HÎ±. eapply EmptyNI. exists Ï‰.
  apply (FUnionI _ _ 0)...
Qed.
Local Hint Resolve soÎµtn_neq_0 : core.

(* Îµå¹‚ç›¸ä¹˜çš„å¸æ”¶å¾‹ *)
Lemma Îµ_pow_mul_absorption :
  âˆ€ Î± Î² â‹µ ğğ, âˆ€n âˆˆ Ï‰, Ï‰ â‹¸ Î² â†’ Îµ Î± ^ n â‹… Îµ Î± ^ Î² = Îµ Î± ^ Î².
Proof with auto.
  intros Î± HÎ± Î² HÎ² n Hn HÏ‰Î².
  rewrite <- epsilon, ordExp_exp, ordExp_exp, <- ordExp_add...
  f_equal. rewrite <- ordMul_distr... f_equal.
  apply ordAdd_n_absorption...
Qed.

(* æœ‰é™å±‚Îµå¡”ä¸Šç•Œæ˜¯Îµæ•° *)
Theorem supÎµtn_is_Îµ_number : âˆ€Î± â‹µ ğğ, supÎµtn Î± â‹µ Îµ_number.
Proof with neauto.
  intros Î± HÎ±. split... ext.
  - rewrite ordExp_limit in H...
    apply FUnionE in H as [Î² [HÎ² Hx]].
    apply FUnionE in HÎ² as [n [Hn HÎ²]].
    apply (FUnionI _ _ nâº)... apply Ï‰_inductive...
    rewrite ordTet_suc... eapply ord_trans... auto.
    assert (HoÎ²: Î² â‹µ ğğ). eapply ord_is_ords; revgoals...
    eapply ord_trans_le_lt. auto.
    apply ordExp_preserve_le_l; revgoals.
    left. apply Îµ_has_Ï‰. apply HÎ±. 1-3:auto.
    apply ordExp_preserve_lt...
  - apply FUnionE in H as [n [Hn Hx]].
    rewrite ordExp_limit... eapply FUnionI.
    eapply FUnionI. apply Ï‰_inductive, Hn. apply Îµtn_ascending...
    generalize dependent Hx. generalize dependent x.
    apply ord_le_iff_sub...
    Ï‰_induction n.
    + rewrite ordTet_0 in *... rewrite epsilon...
    + rewrite ordTet_suc in *...
      rewrite <- (epsilon Î±) at 1 5... rewrite ordExp_exp...
      apply ordExp_preserve_le_r...
      rewrite <- (epsilon Î±) at 3 7... rewrite ordExp_exp...
      eapply ordMul_preserve_le_r in IH.
      4: apply (Îµ_is_limord Î±)... 2-3:auto.
      rewrite <- (epsilon Î±) in IH at 3 7...
      rewrite <- ordExp_add in IH...
      Ï‰_destruct m.
      * rewrite ordTet_0 in *...
        eapply ord_trans_le. auto. apply IH.
        apply ordExp_preserve_le_r... left.
        rewrite <- ordMul_2_r... apply ordMul_preserve_lt...
      * cut (Îµ Î± + Îµ Î± ^^ mâº = Îµ Î± â‹… Îµ Î± ^^ mâº). congruence.
        rewrite ordTet_suc...
        rewrite <- (epsilon Î±) at 1 2...
        rewrite ordExp_exp, Ï‰_pow_add_absorption...
        rewrite <- (ordExp_1_r (Îµ Î±)) at 3...
        rewrite Îµ_pow_mul_absorption, <- ordExp_exp, epsilon...
        apply ordMul_enlarge...
Qed.

(* Îµæ•°çš„åç»§ä¸æ˜¯Îµæ•° *)
Lemma suc_Îµ_is_not_Îµ_number : âˆ€Î± â‹µ ğğ, Â¬ (Îµ Î±)âº â‹µ Îµ_number.
Proof with nauto.
  intros Î± HÎ± [HÎµ H].
  rewrite ordExp_suc, epsilon, <- ordAdd_1_r in H...
  eapply ord_not_lt_self. 3: symmetry in H; apply H. 1-2: nauto.
  eapply ord_trans. auto. apply ordAdd_preserve_lt; revgoals.
  apply Îµ_has_n. apply HÎ±. 1-4: nauto.
  rewrite <- ordMul_2_r... apply ordMul_preserve_lt...
Qed.

(* Îµæ•°çš„åç»§å°äºåç»§Îµæ•° *)
Lemma suc_Îµ_lt_Îµ_suc : âˆ€Î± â‹µ ğğ, (Îµ Î±)âº âˆˆ Îµ Î±âº.
Proof with eauto.
  intros Î± HÎ±. contra.
  apply ord_le_iff_not_gt in H as []...
  - apply ord_le_iff_lt_suc, ord_le_iff_not_gt in H...
    apply H, Îµ_normal...
  - eapply suc_Îµ_is_not_Îµ_number...
    rewrite <- H. apply Îµ_is_Îµ_number...
Qed.

(* Îµæ•°çš„ä¸¤å€å°äºåç»§Îµæ•° *)
Lemma Îµ_double_lt_Îµ_suc : âˆ€Î± â‹µ ğğ, Îµ Î± + Îµ Î± âˆˆ Îµ Î±âº.
Proof with neauto.
  intros Î± HÎ±.
  rewrite <- epsilon, <- (epsilon Î±âº)...
  eapply ord_trans. auto.
  apply ordAdd_preserve_lt; revgoals.
  apply ordExp_preserve_lt; revgoals. apply suc_has_n. 1-7: nauto.
  rewrite Ï‰_pow_add_absorption...
  apply ordExp_preserve_lt, suc_Îµ_lt_Îµ_suc...
Qed.

(* Îµæ•°çš„å¹³æ–¹å°äºåç»§Îµæ•° *)
Lemma Îµ_square_lt_Îµ_suc : âˆ€Î± â‹µ ğğ, Îµ Î± â‹… Îµ Î± âˆˆ Îµ Î±âº.
Proof with neauto.
  intros Î± HÎ±.
  rewrite <- epsilon, <- ordExp_add, <- (epsilon Î±âº)...
  apply ordExp_preserve_lt, Îµ_double_lt_Îµ_suc...
Qed.

(* Îµè¿ç®—åœ¨åç»§åºæ•°å¤„çš„å€¼ *)
Theorem Îµ_suc : âˆ€Î± â‹µ ğğ, Îµ Î±âº = supÎµtn Î±.
Proof with neauto.
  intros Î± HÎ±. ord_ext...
  - apply Îµ_spec... apply supÎµtn_is_Îµ_number...
    intros H. apply ReplAx in H as [x [Hx H]].
    assert (Hox: x â‹µ ğğ). apply (ord_is_ords Î±âº)...
    cut (Îµ x âˆˆ supÎµtn Î±). intros C. eapply ord_not_lt_self; revgoals...
    apply (FUnionI _ _ 1)... rewrite (pred 1), ordTet_suc, ordTet_0...
    eapply ord_trans_le_lt. auto. 2: apply ordExp_enlarge...
    apply ord_le_iff_lt_suc in Hx as []...
    left. apply Îµ_normal... right. congruence.
  - apply ord_le_iff_sub... intros x Hx.
    apply FUnionE in Hx as [n [Hn Hx]].
    eapply ord_trans... clear Hx.
    Ï‰_destruct n. {
      rewrite ordTet_0... apply Îµ_normal...
    }
    rewrite ordTet_suc... rewrite <- epsilon at 1...
    rewrite <- (epsilon Î±âº), ordExp_exp...
    apply ordExp_preserve_lt...
    Ï‰_destruct n. {
      rewrite ordTet_0... apply Îµ_square_lt_Îµ_suc...
    }
    rewrite ordTet_suc... rewrite <- epsilon at 1 2...
    rewrite <- (epsilon Î±âº), ordExp_exp, <- ordExp_add...
    apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran...
    Ï‰_induction n.
    + rewrite ordTet_0, <- epsilon, <- ordExp_add, <- (epsilon Î±âº)...
      rewrite Ï‰_pow_add_absorption...
      apply ordExp_preserve_lt, Îµ_double_lt_Îµ_suc...
      apply ordAdd_enlarge...
    + rewrite ordTet_suc... rewrite <- epsilon at 1 2 3...
      rewrite <- (epsilon Î±âº), ordExp_exp, <- ordExp_add...
      rewrite Ï‰_pow_add_absorption.
      2: apply ordAdd_ran, ordMul_ran...
      * apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran...
      * apply ordAdd_enlarge, ord_neq_0_gt_0...
        eapply ord_trans. auto. apply Îµ_has_n... apply ordMul_enlarge...
Qed.
