(** Coq coding by choukh, Sep 2021 **)

Require Export ZFC.LargeOrdinals.SidedTetration.
Require Import ZFC.LargeOrdinals.GeneralEpsilon.
Import OrdinalClass ğğOperation.

Local Hint Resolve
  add_ran mul_ran exp_ran ordAdd_ran ordMul_ran
  preOrdExp_ran ordExp_ran ordTetL_ran ordTet0_ran
  Îµ_operative bunion_of_ords_is_ord : core.

(** è¿­ä»£å¹‚æ¬¡ **)
(** Tetration **)
(* adapted from https://math.stackexchange.com/a/3768438/815418 *)
Definition OrdTet := Î» Î±, Operation 1 (Î» Î¾, Î± ^ Î¾ âˆª Î¾ ^ Î±).
Notation "Î± ^^ Î²" := (OrdTet Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTet_0_r : âˆ€Î± â‹µ ğğ, Î± ^^ 0 = 1.
Proof. intros Î± H. apply operation_0; auto. Qed.

Theorem ordTet_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î²âº = Î± ^ (Î± ^^ Î²) âˆª (Î± ^^ Î²) ^ Î±.
Proof. intros Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTet_limit : âˆ€Î± â‹µ ğğ, continuous (OrdTet Î±).
Proof. intros Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTet_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² â‹µ ğğ.
Proof with nauto.
  intros Î± HÎ± Î² HÎ². apply operation_operative...
Qed.
Local Hint Resolve ordTet_ran : core.

Theorem ordTet_0_l : âˆ€Î± â‹µ ğğ, 0 ^^ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [Î³ [HÎ³ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_0_l, ordExp_0_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [Î² HÎ²]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_1_r : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ Î± ^^ 1 = Î±.
Proof with nauto.
  intros Î± H H0. rewrite pred, ordTet_suc...
  rewrite ordTet_0_r, ordExp_1_r, ordExp_1_l, ord_max_l...
  apply ord_suc_correct...
Qed.

Theorem ordTet_1_l : âˆ€Î± â‹µ ğğ, 1 ^^ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [Î³ [HÎ³ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_1_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [Î² HÎ²]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_2_r : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ Î± ^^ 2 = Î± ^ Î±.
Proof.
  intros Î± HÎ± HÎ±0.
  rewrite pred, ordTet_suc, ordTet_1_r, ord_max_r; nauto.
Qed.

Theorem ordTet_eq_L : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ âˆ€n âˆˆ Ï‰, Î± ^^ nâº = Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±0 n Hn.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTet_1_l, ordTetL_1_l...
  }
  destruct (classic (Î± = 2)) as [|HÎ±2]. {
    subst. Ï‰_induction n.
    - rewrite ordTet_1_r, ordTetL_0...
    - destruct (classic (m = 0)) as [|Hm0]. {
        subst. rewrite ordTet_suc, IH...
        rewrite ordTetL_suc, ordTetL_0, ord_max_l...
      }
      rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
      apply ordTetL_exp_r_le_l...
  }
  Ï‰_induction n.
  - rewrite ordTet_1_r, ordTetL_0...
  - destruct (classic (m = 0)) as [|Hm0]. {
      subst. rewrite ordTet_suc, IH...
      rewrite ordTetL_suc, ordTetL_0, ord_max_l...
    }
    rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
    left. apply ordTetL_exp_r_lt_l... contra.
    apply ord_le_iff_not_gt in H as []...
    rewrite two in H. apply TwoE in H as []... rewrite <- one in H...
Qed.

Theorem ordTet_suc_l : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ âˆ€n âˆˆ Ï‰, Î± ^^ nâº = Î± ^ (Î± ^^ n).
Proof with auto.
  intros Î± HÎ± HÎ±0 n Hn.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTet_1_l, ordTet_1_l, ordExp_1_r...
  }
  Ï‰_induction n.
  - rewrite ordTet_1_r, ordTet_0_r, ordExp_1_r...
  - rewrite ordTet_eq_L, ordTet_eq_L, ordTetL_suc...
    apply Ï‰_inductive...
Qed.

Theorem ordTet_Ï‰_eq_Îµ_0 : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ Î± ^^ Ï‰ = Îµ Î± 0.
Proof with neauto.
  intros Î± HÎ± HÎ±1.
  apply ord_gt_1_neq_0_1 in HÎ±1 as [HÎ±0 HÎ±1]...
  rewrite ordTet_limit... ext.
  - apply FUnionE in H as [n [Hn Hx]].
    Ï‰_destruct n.
    + rewrite ordTet_0_r, one in Hx...
      apply SingE in Hx. subst. apply Îµ_has_n...
    + rewrite Îµ_0... rewrite ordTet_eq_L in Hx... eapply FUnionI...
  - rewrite Îµ_0 in H... apply FUnionE in H as [n [Hn Hx]].
    rewrite <- ordTet_eq_L in Hx...
    apply (FUnionI _ _ nâº)... apply Ï‰_inductive...
Qed.

Lemma ordTet_neq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² â‰  0.
Proof with eauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTet_0_r in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTet_suc in H...
    apply union_eq_empty in H as [].
    + apply EmptyNI in H... exists (Î± ^ Î± ^^ Î³)... apply PairI1.
    + symmetry in H. apply single_eq_pair in H as [H Heq].
      symmetry in H. apply ordExp_eq_0 in H...
      subst. rewrite ordExp_0_l, ordExp_0_r in Heq...
  - rewrite ordTet_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [Î³ HÎ³].
      assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in HÎ³...
      eapply repl_eq_1 in HÎ³ as H0... eapply IH...
Qed.
Local Hint Resolve ordTet_neq_0 : core.

Lemma ordTet_gt_1 : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ Î² â‰  0 â†’ 1 âˆˆ Î± ^^ Î².
Proof with neauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH HÎ±1 HÎ²0.
  ord_destruct Î².
  - subst...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    rewrite ordTet_suc... eapply ord_trans... auto.
    apply BUnionI1. apply ordExp_enlarge_r...
  - rewrite ordTet_limit...
    apply EmptyNE in H0 as [Î³ HÎ³].
    assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTet_suc... left. apply BUnionI2. apply ordExp_enlarge_r...
Qed.
Local Hint Resolve ordTet_gt_1 : core.

Theorem ordTet_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² = 1 â†’ Î± = 0 âˆ¨ Î± = 1 âˆ¨ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H.
  destruct (classic (Î± = 0))...
  destruct (classic (Î± = 1))...
  destruct (classic (Î² = 0))... exfalso.
  apply (ord_irrefl 1)... rewrite <- H at 2.
  apply ordTet_gt_1...
Qed.

Theorem ordTet_normal : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ normal (OrdTet Î±).
Proof with nauto.
  intros Î± HÎ± HÎ±1. apply operation_normal...
  fold (OrdTet Î±). intros x Hx.
  destruct (classic (x = 0)) as [|Hx0]. {
    subst. rewrite ordTet_0_r, ordTet_1_r... apply ord_gt_1_neq_0_1...
  }
  rewrite ordTet_suc... apply BUnionI2.
  apply ordExp_enlarge_r...
Qed.

Fact ordTet_is_limord_r : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, 1 âˆˆ Î± â†’ ğœ† â‰  0 â†’ Î± ^^ ğœ† â‹µ ğğË¡â±áµ.
Proof with neauto.
  intros Î± HÎ± ğœ† Hğœ† H1 H2.
  apply normal_operation_limit_is_limit...
  apply ordTet_normal...
Qed.

Fact ordTet_is_limord_l : âˆ€Î± â‹µ ğğ, âˆ€ğœ† â‹µ ğğË¡â±áµ, Î± â‰  0 â†’ ğœ† â‰  0 â†’ ğœ† ^^ Î± â‹µ ğğË¡â±áµ.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH ğœ† Hğœ† HÎ±0 Hğœ†0.
  ord_destruct Î±.
  - subst...
  - destruct Hsuc as [Î² [HÎ² Heq]]. subst.
    destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. rewrite ordTet_1_r...
    }
    assert (H1: 1 âˆˆ ğœ† ^^ Î²). {
      apply ord_neq_0_1_gt_1...
      intros H. apply ordTet_eq_1 in H as [|[]]...
      apply (limord_iff_not_sucord ğœ†)... exists 0...
    }
    rewrite ordTet_suc... 
    epose proof (ord_comparability (ğœ† ^ ğœ† ^^ Î²) _ (ğœ† ^^ Î² ^ ğœ†)) as []...
    + rewrite ord_max_r... apply ordExp_is_limord_r...
    + rewrite ord_max_l... apply ordExp_is_limord_l...
  - rewrite ordTet_limit...
    replace (sup {ğœ† ^^ Î±0 | Î±0 âˆŠ Î±}) with (sup {ğœ† ^^ Î±0 | Î±0 âˆŠ Î± - {0,}}).
    + apply union_of_limords_is_limord. intros x Hx.
      apply ReplAx in Hx as [Î² [HÎ² Hx]]. subst x.
      apply SepE in HÎ² as [HÎ² HÎ²']. apply SingNE in HÎ²'. apply IH...
    + ext.
      * apply FUnionE in H as [Î² [HÎ² Hx]].
        apply SepE1 in HÎ². eapply FUnionI...
      * apply FUnionE in H as [Î² [HÎ² Hx]].
        assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords Î±)...
        apply (FUnionI _ _ Î²âº). apply SepI.
        apply sucord_in_limord... apply SingNI. apply suc_neq_0.
        eapply ord_trans... apply ordTet_normal...
        eapply ord_trans_lt_le. auto. apply embed_ran. apply limord_ge_Ï‰...
  Unshelve. auto.
Qed.

Corollary ordTet_preserve_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î± â†’
  Î² âˆˆ Î³ â†” Î± ^^ Î² âˆˆ Î± ^^ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ HÎ±1. split; intros H.
  apply ordTet_normal...
  destruct (classic (Î² = Î³)).
  - subst. exfalso. eapply ord_irrefl; revgoals...
  - apply ord_connected in H0 as []...
    apply (proj1 (ordTet_normal Î± HÎ± HÎ±1)) in H0...
    exfalso. eapply ord_not_lt_gt; revgoals...
Qed.

Corollary ordTet_cancel : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î± â†’ Î± ^^ Î² = Î± ^^ Î³ â†’ Î² = Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H1 Heq.
  contra. apply ord_connected in H as [Hlt|Hlt]...
  - assert (Î± ^^ Î² âˆˆ Î± ^^ Î³). apply ordTet_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
  - assert (Î± ^^ Î³ âˆˆ Î± ^^ Î²). apply ordTet_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
Qed.

Theorem ordTet_preserve_le_l : âˆ€ Î± Î² Î³ â‹µ ğğ,
  Î± â‹¸ Î² â†’ Î± ^^ Î³ â‹¸ Î² ^^ Î³.
Proof with eauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ Hle.
  generalize dependent Î³.
  ord_induction; intros Î³ HÎ³ IH.
  ord_destruct Î³.
  - subst. rewrite ordTet_0_r, ordTet_0_r...
  - destruct Hsuc as [Î´ [HÎ´ Heq]]. subst.
    destruct Hle; [|subst; right]...
    destruct (classic (Î² = 0)) as [|HÎ²0]. {
      subst. exfalso0.
    }
    destruct (classic (Î² = 1)) as [|HÎ²1]. {
      subst. rewrite one in H. apply SingE in H. subst.
      rewrite ordTet_0_l, ordTet_1_l...
    }
    destruct (classic (Î± = 0)) as [|HÎ±0]. {
      subst. rewrite ordTet_0_l...
    }
    destruct (classic (Î± = 1)) as [|HÎ±1]. {
      subst. rewrite ordTet_1_l...
    }
    destruct (classic (Î´ = 0)) as [|HÎ´0]. {
      subst. rewrite ordTet_1_r, ordTet_1_r...
    }
    apply ord_le_iff_sub... rewrite ordTet_suc, ordTet_suc...
    intros x Hx. apply BUnionE in Hx as [Hx|Hx].
    + apply BUnionI1. eapply ord_trans_lt_le... clear Hx.
      eapply ord_trans_le. auto.
      apply ordExp_preserve_le_r. 5: apply IH. 1-5: auto.
      apply ordExp_preserve_le_l...
    + apply BUnionI2. eapply ord_trans_lt_le... clear Hx.
      eapply ord_trans_le. auto.
      apply ordExp_preserve_le_l. 4: apply IH. 1-4: auto.
      apply ordExp_preserve_le_r...
  - apply ord_le_iff_sub...
    rewrite ordTet_limit, ordTet_limit...
    intros x Hx. apply FUnionE in Hx as [Î´ [HÎ´ Hx]].
    assert (HoÎ´: Î´ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI... apply IH in HÎ´ as []...
    eapply ord_trans... congruence.
Qed.

Fact ordTet_preserve_le_r : âˆ€ Î± Î² Î³ â‹µ ğğ, 1 âˆˆ Î³ â†’
  Î± â‹¸ Î² â†’ Î³ ^^ Î± â‹¸ Î³ ^^ Î².
Proof.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 [].
  left. apply ordTet_preserve_lt; auto.
  right. congruence.
Qed.

Lemma ordTet_enlarge_r : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ 1 âˆˆ Î² â†’ Î± âˆˆ Î± ^^ Î².
Proof with nauto.
  intros Î± HÎ± Î² HÎ² HÎ±1 HÎ²1. rewrite <- ordTet_1_r at 1...
  apply ordTet_preserve_lt... apply ord_gt_1_neq_0_1...
Qed.

Lemma ordTet_enlarge_l : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î² â†’ Î± â‹¸ Î² ^^ Î±.
Proof with auto.
  intros Î± HÎ± Î² HÎ² HÎ²1.
  apply monotone_operation_weakly_increasing...
  apply ordTet_normal...
Qed.

Lemma ordTet_enlarge_lt : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± âˆˆ Î² â†’ Î± âˆˆ Î² ^^ Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). subst. exfalso0.
  destruct (classic (Î² = 1)). {
    subst. rewrite one in Hle. apply SingE in Hle.
    subst. apply ord_neq_0_gt_0...
  }
  destruct (classic (Î³ = 1)). subst. rewrite ordTet_1_r...
  rewrite <- (ordTet_1_r Î²) in Hle...
  eapply (ord_trans (Î² ^^ Î³))...
  apply ordTet_preserve_lt...
Qed.

Lemma ordTet_enlarge_le : âˆ€ Î± Î² Î³ â‹µ ğğ, Î³ â‰  0 â†’ Î± â‹¸ Î² â†’ Î± â‹¸ Î² ^^ Î³.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² Î³ HÎ³ H0 Hle.
  destruct (classic (Î² = 0)). {
    subst. rewrite ordTet_0_l...
    destruct Hle. exfalso0. subst...
  }
  destruct (classic (Î² = 1)). subst. rewrite ordTet_1_l...
  rewrite <- (ordTet_1_r Î²) in Hle...
  eapply ord_trans_le. auto. apply Hle.
  apply ordTet_preserve_le_r...
  apply ord_le_iff_not_gt... intros HÎ³1.
  rewrite one in HÎ³1. apply SingE in HÎ³1...
Qed.

Section Epsilon.
Local Notation Îµ := (Îµ Ï‰).
Local Hint Resolve Îµ_has_n Îµ_neq_0 : core.

Theorem Ï‰_tet_Ï‰ : Ï‰ ^^ Ï‰ = Îµ 0.
Proof. apply ordTet_Ï‰_eq_Îµ_0; nauto. Qed.

Lemma Îµ_exp_Ï‰ : âˆ€Î± â‹µ ğğ, (Îµ Î±) ^ Ï‰ = (Ï‰ ^^â° 2) (Îµ Î±)âº.
Proof with nauto.
  intros Î± HÎ±.
  rewrite (pred 2), ordTet0_suc...
  rewrite (pred 1), ordTet0_suc...
  rewrite ordTet0_0, <- ordAdd_1_r, <- ordExp_add, ordExp_1_r...
  rewrite epsilon, <- ordExp_mul, epsilon...
Qed.

Fact Ï‰tÏ‰_1 : Ï‰ ^^ (Ï‰ + 1) = (Ï‰ ^^â° 2) (Îµ 0)âº.
Proof with nauto.
  rewrite (pred 1), ordAdd_suc, ordTet_suc, ordAdd_0_r...
  rewrite ordTet_Ï‰_eq_Îµ_0, <- Îµ_exp_Ï‰, ord_max_r...
  rewrite epsilon... left. apply ordExp_enlarge_r...
Qed.

Fact Ï‰tÏ‰_2 : Ï‰ ^^ (Ï‰ + 2) = (Ï‰ ^^â° 3) (Îµ 0)âº.
Proof with nauto.
  rewrite (pred 2), ordAdd_suc, ordTet_suc, ord_max_l...
  - rewrite (pred 3), ordTet0_suc, Ï‰tÏ‰_1...
  - rewrite Ï‰tÏ‰_1, <- Îµ_exp_Ï‰... left.
    rewrite <- (epsilon) at 1...
    rewrite ordExp_mul, ordExp_mul...
    apply ordExp_preserve_lt...
    apply (ord_trans_le_lt _ (Îµ 0 â‹… Îµ 0))...
    apply ordMul_preserve_le_r... rewrite <- epsilon_mul...
    apply ordMul_preserve_le_r... apply Îµ_ge_Ï‰...
    rewrite <- (ordExp_2_r)... apply ordExp_preserve_lt...
Qed.

Lemma Ï‰tÏ‰_n_gt_Ï‰ : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Ï‰ âˆˆ Ï‰ ^^ (Ï‰ + n).
Proof with nauto.
  intros n Hn Hn0. apply ordTet_enlarge_r...
  eapply ord_trans. auto. apply embed_ran. apply ordAdd_enlarge_r...
Qed.

Lemma Ï‰tÏ‰_exp_Ï‰_r_lt_l : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Ï‰ ^^ (Ï‰ + n) ^ Ï‰ â‹¸ Ï‰ ^ Ï‰ ^^ (Ï‰ + n).
Proof with nauto.
  intros n Hn. Ï‰_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. rewrite suc, add_0_l, Ï‰tÏ‰_1...
    rewrite (pred 2), ordTet0_suc, ordTet0_1...
    assert (HÎµ: Îµ 0 â‹µ ğğ)... left.
    rewrite ordExp_mul... apply ordExp_preserve_lt...
    rewrite <- (ordExp_1_r Ï‰) at 3...
    rewrite ordExp_add... apply ordExp_preserve_lt...
    rewrite ordExp_suc, epsilon...
    rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_1...
    eapply (ord_trans _ _ _ (Îµ 0 + Îµ 0)).
    apply ordAdd_preserve_lt... rewrite <- ordMul_2_r...
    apply ordMul_preserve_lt...
  - rewrite ordAdd_suc, ordTet_suc, ord_max_l...
    rewrite ordExp_mul... apply ordExp_preserve_le_r...
    eapply ord_trans_le; revgoals... left.
    eapply (ord_trans _ _ _ (Ï‰ ^^ (Ï‰ + m) â‹… Ï‰ ^^ (Ï‰ + m))).
    apply ordMul_preserve_lt... apply Ï‰tÏ‰_n_gt_Ï‰...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
    eapply ord_trans. auto. apply embed_ran. apply Ï‰tÏ‰_n_gt_Ï‰...
  Unshelve. 1-2: auto.
Qed.

Theorem Ï‰tÏ‰_n : âˆ€n âˆˆ Ï‰, n â‰  0 â†’ Ï‰ ^^ (Ï‰ + n) = (Ï‰ ^^â° nâº) (Îµ 0)âº.
Proof with nauto.
  intros n Hn. Ï‰_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0]. subst. apply Ï‰tÏ‰_1.
  rewrite ordAdd_suc, ordTet0_suc, <- IH...
  rewrite ordTet_suc, ord_max_l, IH...
  apply Ï‰tÏ‰_exp_Ï‰_r_lt_l...
Qed.

Lemma Îµ_tet0_n : âˆ€Î± â‹µ ğğ, âˆ€n âˆˆ Ï‰, n â‰  0 â†’ (Îµ Î± ^^â° n) Ï‰ = (Ï‰ ^^â° nâº) (Îµ Î±)âº.
Proof with nauto.
  intros Î± HÎ± n Hn. Ï‰_induction n; intros H0. exfalso...
  destruct (classic (m = 0)) as [Hm0|Hm0].
  - subst. rewrite ordTet0_1, Îµ_exp_Ï‰...
  - rewrite ordTet0_suc, ordTet0_suc, IH, ordTet0_suc...
    rewrite <- epsilon at 1...
    rewrite ordExp_mul... 2: apply ordExp_ran... f_equal.
    rewrite <- epsilon at 1... rewrite ordExp_add... f_equal.
    Ï‰_destruct m. exfalso...
    rewrite <- epsilon at 1... rewrite ordTet0_suc...
    apply ordAdd_Ï‰_pow_absorption...
    clear Hn n Hm0 H0 IH Hm. rename m into n.
    Ï‰_induction n.
    + rewrite ordTet0_0...
    + rewrite ordTet0_suc... eapply ord_trans_lt_le; revgoals.
      apply ordExp_enlarge_l... apply IH. apply ordExp_ran...
Qed.

Theorem Ï‰tÏ‰_Ï‰ : Ï‰ ^^ (Ï‰ + Ï‰) = Îµ 1.
Proof with neauto.
  rewrite pred, Îµ_suc...
  erewrite <- (ordTet0_eq_ordTetL_Ï‰ (Îµ 0) _ Ï‰)... 2: {
    rewrite Îµ_0... apply (FUnionI _ _ 1)...
    rewrite ordTetL_1_r... apply ordExp_enlarge_r...
  }
  rewrite ordTet_limit, ordTet0_limit...
  2: apply ordAdd_is_limord...
  2: intros H; apply ordAdd_eq_0 in H as []...
  ext.
  - apply FUnionE in H as [Î± [HÎ± H]].
    assert (HoÎ±: Î± â‹µ ğğ). apply (ord_is_ords (Ï‰ + Ï‰))...
    rewrite ordAdd_limit in HÎ±...
    apply FUnionE in HÎ± as [n [Hn HÎ±]].
    Ï‰_destruct n.
    + apply (FUnionI _ _ 1)... rewrite ordTet0_1...
      eapply ord_trans... rewrite <- Ï‰_tet_Ï‰.
      eapply ord_trans. auto. apply ordTet_preserve_lt; revgoals...
      rewrite ordAdd_0_r... apply ordExp_enlarge_r...
    + apply (FUnionI _ _ nâº)... rewrite Îµ_tet0_n, <- Ï‰tÏ‰_n...
      eapply ord_trans... apply ordTet_preserve_lt...
  - apply FUnionE in H as [n [Hn H]].
    Ï‰_destruct n.
    + rewrite ordTet0_0 in H...
      apply (FUnionI _ _ 1)... 2: rewrite ordTet_1_r...
      eapply ord_trans. auto. apply embed_ran.
      apply ordAdd_enlarge_r...
    + rewrite Îµ_tet0_n, <- Ï‰tÏ‰_n in H...
      eapply FUnionI... apply ordAdd_preserve_lt...
  Unshelve. apply Îµ_operative...
Qed.

Definition Îµ_k := Î» k, Îµ k = Ï‰ ^^ (Ï‰ â‹… kâº).

Lemma Ï‰tÏ‰k_1 : âˆ€k âˆˆ Ï‰, Îµ_k k â†’ Ï‰ ^^ (Ï‰ â‹… kâº + 1) = (Ï‰ ^^â° 2) (Îµ k)âº.
Proof with nauto.
  intros k Hk IH.
  rewrite (pred 1), ordAdd_suc, ordTet_suc, ordAdd_0_r...
  repeat rewrite <- IH. rewrite <- Îµ_exp_Ï‰, ord_max_r...
  rewrite epsilon... left. apply ordExp_enlarge_r...
Qed.

Lemma Ï‰tÏ‰k_exp_Ï‰_r_lt_l : âˆ€ k n âˆˆ Ï‰, Îµ_k k â†’ n â‰  0 â†’ Ï‰ ^^ (Ï‰ â‹… kâº + n) ^ Ï‰ â‹¸ Ï‰ ^ Ï‰ ^^ (Ï‰ â‹… kâº + n).
Proof with nauto.
  intros k Hk n Hn IHk. Ï‰_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. rewrite Ï‰tÏ‰k_1, <- ordTet0_suc...
    repeat rewrite pred... repeat rewrite ordTet0_suc...
    rewrite ordTet0_0... left. rewrite ordExp_mul...
    assert (Hran: Ï‰ ^ (Îµ k)âº â‹µ ğğ). apply ordExp_ran...
    apply ordExp_preserve_lt...
    rewrite <- (ordExp_1_r Ï‰) at 3... rewrite ordExp_add...
    apply ordExp_preserve_lt...
    rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_1...
    eapply (ord_trans _ _ _ (Îµ k + Îµ k)).
    apply ordAdd_preserve_lt... rewrite <- ordMul_2_r...
    rewrite <- ordExp_add, epsilon, ordExp_1_r...
    apply ordMul_preserve_lt...
  - assert (Hran: Ï‰ ^^ (Ï‰ â‹… kâº + m) â‹µ ğğ). apply ordTet_ran...
    assert (Hsum0: Ï‰ â‹… kâº + m â‰  0). {
      intros H. apply ordAdd_eq_0 in H as []...
    }
    assert (Hsum1: Ï‰ â‹… kâº + m â‰  1). {
      intros H. apply ordAdd_eq_1 in H as [[H _]|[]]...
      apply ordMul_eq_0 in H as []... apply (suc_neq_0 k)...
    }
    assert (Htet1: 1 âˆˆ Ï‰ ^^ (Ï‰ â‹… kâº + m)). apply ordTet_gt_1...
    rewrite ordAdd_suc, ordTet_suc, ord_max_l...
    rewrite ordExp_mul... apply ordExp_preserve_le_r...
    eapply ord_trans_le; revgoals... left.
    eapply (ord_trans _ _ _ (Ï‰ ^^ (Ï‰ â‹… kâº + m) â‹… Ï‰ ^^ (Ï‰ â‹… kâº + m))).
    apply ordMul_preserve_lt... apply ord_gt_1_neq_0_1...
    apply ordTet_enlarge_r... apply ord_neq_0_1_gt_1...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
  Unshelve. apply ordExp_ran... auto.
Qed.

Lemma Ï‰tÏ‰k_n : âˆ€ k n âˆˆ Ï‰, Îµ_k k â†’ n â‰  0 â†’ Ï‰ ^^ (Ï‰ â‹… kâº + n) = (Ï‰ ^^â° nâº) (Îµ k)âº.
Proof with nauto.
  intros k Hk n Hn IHk. Ï‰_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. apply Ï‰tÏ‰k_1...
  - rewrite ordAdd_suc, ordTet0_suc, <- IH...
    rewrite ordTet_suc, ord_max_l, IH...
    apply ordExp_ran... apply ordTet_ran...
    apply ordExp_ran... apply ordTet_ran...
    apply Ï‰tÏ‰k_exp_Ï‰_r_lt_l...
Qed.

Theorem Îµ_n : âˆ€n âˆˆ Ï‰, Îµ n = Ï‰ ^^ (Ï‰ â‹… nâº).
Proof with neauto.
  intros n Hn. Ï‰_induction n.
  - subst. rewrite ordMul_1_r, Ï‰_tet_Ï‰...
  - assert (H0: Ï‰ â‹… mâº â‰  0). {
      intros H. apply ordMul_eq_0 in H as []... eapply suc_neq_0...
    }
    rewrite Îµ_suc, ordMul_suc...
    erewrite <- (ordTet0_eq_ordTetL_Ï‰ (Îµ m) _ Ï‰)... 2: {
      rewrite IH. apply ordTet_enlarge_r...
      apply ord_neq_0_1_gt_1... intros H.
      apply ordMul_eq_1 in H as []...
      apply (nat_irrefl 1)... rewrite <- H at 2...
    }
    rewrite ordTet0_limit, ordTet_limit...
    2: apply ordAdd_is_limord...
    2: intros H; apply ordAdd_eq_0 in H as []...
    ext.
    + apply FUnionE in H as [k [Hk H]].
      Ï‰_destruct k.
      * rewrite ordTet0_0 in H...
        apply (FUnionI _ _ 1)... 2: rewrite ordTet_1_r...
        eapply ord_trans_lt_le. auto. apply embed_ran.
        apply ordAdd_enlarge_l...
      * rewrite Îµ_tet0_n, <- Ï‰tÏ‰k_n in H...
        eapply FUnionI... apply ordAdd_preserve_lt...
    + apply FUnionE in H as [Î± [HÎ± Hx]].
      assert (HoÎ±: Î± â‹µ ğğ). apply (ord_is_ords (Ï‰ â‹… mâº + Ï‰))...
      rewrite ordAdd_limit in HÎ±...
      apply FUnionE in HÎ± as [k [Hk HÎ±]].
      Ï‰_destruct k.
      * apply (FUnionI _ _ 1)... rewrite ordTet0_1...
        eapply ord_trans... eapply ord_trans. nauto.
        apply ordTet_preserve_lt; revgoals...
        rewrite ordAdd_0_r, IH... apply ordExp_enlarge_r...
      * apply (FUnionI _ _ kâº)... rewrite Îµ_tet0_n, <- Ï‰tÏ‰k_n...
        eapply ord_trans... apply ordTet_ran... apply ordAdd_ran...
        apply ordTet_preserve_lt... apply ordAdd_ran...
  Unshelve. apply Îµ_operative...
Qed.

Corollary Îµ_Ï‰ : Îµ Ï‰ = Ï‰ ^^ (Ï‰ ^ 2).
Proof with neauto.
  rewrite Îµ_limit, ordExp_2_r, ordTet_limit...
  2: apply ordMul_is_limord_l...
  2: intros H; apply ordMul_eq_0 in H as []...
  ext.
  - apply FUnionE in H as [n [Hn H]]. rewrite Îµ_n in H...
    apply (FUnionI _ _ (Ï‰ â‹… nâº))... apply ordMul_preserve_lt...
    apply Ï‰_inductive...
  - apply FUnionE in H as [Î± [HÎ± H]].
    assert (HoÎ±: Î± â‹µ ğğ). apply (ord_is_ords (Ï‰ â‹… Ï‰))...
    rewrite ordMul_limit in HÎ±...
    apply FUnionE in HÎ± as [n [Hn HÎ±]].
    apply (FUnionI _ _ n)... rewrite Îµ_n...
    eapply ord_trans... apply ordTet_preserve_lt...
    eapply ord_trans... apply ordMul_preserve_lt...
Qed.

End Epsilon.
