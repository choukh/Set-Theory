(** Coq coding by choukh, Sep 2021 **)

Require Export ZFC.LargeOrdinals.SidedTetration.
Require Import ZFC.LargeOrdinals.GeneralEpsilon.
Import OrdinalClass 𝐎𝐍Operation.

Local Hint Resolve
  add_ran mul_ran exp_ran ordAdd_ran ordMul_ran
  preOrdExp_ran ordExp_ran ordTetL_ran ordTet0_ran
  ε_operative bunion_of_ords_is_ord : core.

(** 迭代幂次 **)
(** Tetration **)
(* adapted from https://math.stackexchange.com/a/3768438/815418 *)
Definition OrdTet := λ α, Operation 1 (λ ξ, α ^ ξ ∪ ξ ^ α).
Notation "α ^^ β" := (OrdTet α β) (at level 25) : OrdArith_scope.

Theorem ordTet_0_r : ∀α ⋵ 𝐎𝐍, α ^^ 0 = 1.
Proof. intros α H. apply operation_0; auto. Qed.

Theorem ordTet_suc : ∀ α β ⋵ 𝐎𝐍, α ^^ β⁺ = α ^ (α ^^ β) ∪ (α ^^ β) ^ α.
Proof. intros α Hα β Hβ. apply operation_suc; auto. Qed.

Theorem ordTet_limit : ∀α ⋵ 𝐎𝐍, continuous (OrdTet α).
Proof. intros α Hα. apply operation_limit; auto. Qed.

Theorem ordTet_ran : ∀ α β ⋵ 𝐎𝐍, α ^^ β ⋵ 𝐎𝐍.
Proof with nauto.
  intros α Hα β Hβ. apply operation_operative...
Qed.
Local Hint Resolve ordTet_ran : core.

Theorem ordTet_0_l : ∀α ⋵ 𝐎𝐍, 0 ^^ α = 1.
Proof with neauto.
  ord_induction. intros α Hα IH.
  ord_destruct α.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [γ [Hγ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_0_l, ordExp_0_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [β [Hβ H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [β Hβ]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_1_r : ∀α ⋵ 𝐎𝐍, α ≠ 0 → α ^^ 1 = α.
Proof with nauto.
  intros α H H0. rewrite pred, ordTet_suc...
  rewrite ordTet_0_r, ordExp_1_r, ordExp_1_l, ord_max_l...
  apply ord_suc_correct...
Qed.

Theorem ordTet_1_l : ∀α ⋵ 𝐎𝐍, 1 ^^ α = 1.
Proof with neauto.
  ord_induction. intros α Hα IH.
  ord_destruct α.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [γ [Hγ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_1_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [β [Hβ H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [β Hβ]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_2_r : ∀α ⋵ 𝐎𝐍, α ≠ 0 → α ^^ 2 = α ^ α.
Proof.
  intros α Hα Hα0.
  rewrite pred, ordTet_suc, ordTet_1_r, ord_max_r; nauto.
Qed.

Theorem ordTet_eq_L : ∀α ⋵ 𝐎𝐍, α ≠ 0 → ∀n ∈ ω, α ^^ n⁺ = α ^^ᴸ n.
Proof with nauto.
  intros α Hα Hα0 n Hn.
  destruct (classic (α = 1)) as [|Hα1]. {
    subst. rewrite ordTet_1_l, ordTetL_1_l...
  }
  destruct (classic (α = 2)) as [|Hα2]. {
    subst. ω_induction n.
    - rewrite ordTet_1_r, ordTetL_0...
    - destruct (classic (m = 0)) as [|Hm0]. {
        subst. rewrite ordTet_suc, IH...
        rewrite ordTetL_suc, ordTetL_0, ord_max_l...
      }
      rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
      apply ordTetL_exp_r_le_l...
  }
  ω_induction n.
  - rewrite ordTet_1_r, ordTetL_0...
  - destruct (classic (m = 0)) as [|Hm0]. {
      subst. rewrite ordTet_suc, IH...
      rewrite ordTetL_suc, ordTetL_0, ord_max_l...
    }
    rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
    left. apply ordTetL_exp_r_lt_l... contra.
    apply ord_le_iff_not_gt in H as []...
    rewrite two in H. apply TwoE in H as []... rewrite <- one in H...
Qed.

Theorem ordTet_suc_l : ∀α ⋵ 𝐎𝐍, α ≠ 0 → ∀n ∈ ω, α ^^ n⁺ = α ^ (α ^^ n).
Proof with auto.
  intros α Hα Hα0 n Hn.
  destruct (classic (α = 1)) as [|Hα1]. {
    subst. rewrite ordTet_1_l, ordTet_1_l, ordExp_1_r...
  }
  ω_induction n.
  - rewrite ordTet_1_r, ordTet_0_r, ordExp_1_r...
  - rewrite ordTet_eq_L, ordTet_eq_L, ordTetL_suc...
    apply ω_inductive...
Qed.

Theorem ordTet_ω_eq_ε_0 : ∀α ⋵ 𝐎𝐍, 1 ∈ α → α ^^ ω = ε α 0.
Proof with neauto.
  intros α Hα Hα1.
  apply ord_gt_1_neq_0_1 in Hα1 as [Hα0 Hα1]...
  rewrite ordTet_limit... ext.
  - apply FUnionE in H as [n [Hn Hx]].
    ω_destruct n.
    + rewrite ordTet_0_r, one in Hx...
      apply SingE in Hx. subst. apply ε_has_n...
    + rewrite ε_0... rewrite ordTet_eq_L in Hx... eapply FUnionI...
  - rewrite ε_0 in H... apply FUnionE in H as [n [Hn Hx]].
    rewrite <- ordTet_eq_L in Hx...
    apply (FUnionI _ _ n⁺)... apply ω_inductive...
Qed.

Lemma ordTet_neq_0 : ∀ α β ⋵ 𝐎𝐍, α ^^ β ≠ 0.
Proof with eauto.
  intros α Hα. ord_induction. intros β Hβ IH H.
  ord_destruct β.
  - subst. rewrite ordTet_0_r in H...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    rewrite ordTet_suc in H...
    apply union_eq_empty in H as [].
    + apply EmptyNI in H... exists (α ^ α ^^ γ)... apply PairI1.
    + symmetry in H. apply single_eq_pair in H as [H Heq].
      symmetry in H. apply ordExp_eq_0 in H...
      subst. rewrite ordExp_0_l, ordExp_0_r in Heq...
  - rewrite ordTet_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [γ Hγ].
      assert (Hoγ: γ ⋵ 𝐎𝐍). eapply ord_is_ords...
      apply sucord_in_limord in Hγ...
      eapply repl_eq_1 in Hγ as H0... eapply IH...
Qed.
Local Hint Resolve ordTet_neq_0 : core.

Lemma ordTet_gt_1 : ∀ α β ⋵ 𝐎𝐍, 1 ∈ α → β ≠ 0 → 1 ∈ α ^^ β.
Proof with neauto.
  intros α Hα. ord_induction. intros β Hβ IH Hα1 Hβ0.
  ord_destruct β.
  - subst...
  - destruct Hsuc as [γ [Hγ Heq]]. subst.
    destruct (classic (γ = 0)) as [|Hγ0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    rewrite ordTet_suc... eapply ord_trans... auto.
    apply BUnionI1. apply ordExp_enlarge_r...
  - rewrite ordTet_limit...
    apply EmptyNE in H0 as [γ Hγ].
    assert (Hoγ: γ ⋵ 𝐎𝐍). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    destruct (classic (γ = 0)) as [|Hγ0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTet_suc... left. apply BUnionI2. apply ordExp_enlarge_r...
Qed.
Local Hint Resolve ordTet_gt_1 : core.

Theorem ordTet_eq_1 : ∀ α β ⋵ 𝐎𝐍, α ^^ β = 1 → α = 0 ∨ α = 1 ∨ β = 0.
Proof with neauto.
  intros α Hα β Hβ H.
  destruct (classic (α = 0))...
  destruct (classic (α = 1))...
  destruct (classic (β = 0))... exfalso.
  apply (ord_irrefl 1)... rewrite <- H at 2.
  apply ordTet_gt_1...
Qed.

Theorem ordTet_normal : ∀α ⋵ 𝐎𝐍, 1 ∈ α → normal (OrdTet α).
Proof with nauto.
  intros α Hα Hα1. apply operation_normal...
  fold (OrdTet α). intros x Hx.
  destruct (classic (x = 0)) as [|Hx0]. {
    subst. rewrite ordTet_0_r, ordTet_1_r... apply ord_gt_1_neq_0_1...
  }
  rewrite ordTet_suc... apply BUnionI2.
  apply ordExp_enlarge_r...
Qed.

Fact ordTet_is_limord_r : ∀α ⋵ 𝐎𝐍, ∀𝜆 ⋵ 𝐎𝐍ˡⁱᵐ, 1 ∈ α → 𝜆 ≠ 0 → α ^^ 𝜆 ⋵ 𝐎𝐍ˡⁱᵐ.
Proof with neauto.
  intros α Hα 𝜆 H𝜆 H1 H2.
  apply normal_operation_limit_is_limit...
  apply ordTet_normal...
Qed.

Fact ordTet_is_limord_l : ∀α ⋵ 𝐎𝐍, ∀𝜆 ⋵ 𝐎𝐍ˡⁱᵐ, α ≠ 0 → 𝜆 ≠ 0 → 𝜆 ^^ α ⋵ 𝐎𝐍ˡⁱᵐ.
Proof with neauto.
  ord_induction. intros α Hα IH 𝜆 H𝜆 Hα0 H𝜆0.
  ord_destruct α.
  - subst...
  - destruct Hsuc as [β [Hβ Heq]]. subst.
    destruct (classic (β = 0)) as [|Hβ0]. {
      subst. rewrite ordTet_1_r...
    }
    assert (H1: 1 ∈ 𝜆 ^^ β). {
      apply ord_neq_0_1_gt_1...
      intros H. apply ordTet_eq_1 in H as [|[]]...
      apply (limord_iff_not_sucord 𝜆)... exists 0...
    }
    rewrite ordTet_suc... 
    epose proof (ord_comparability (𝜆 ^ 𝜆 ^^ β) _ (𝜆 ^^ β ^ 𝜆)) as []...
    + rewrite ord_max_r... apply ordExp_is_limord_r...
    + rewrite ord_max_l... apply ordExp_is_limord_l...
  - rewrite ordTet_limit...
    replace (sup {𝜆 ^^ α0 | α0 ∊ α}) with (sup {𝜆 ^^ α0 | α0 ∊ α - {0,}}).
    + apply union_of_limords_is_limord. intros x Hx.
      apply ReplAx in Hx as [β [Hβ Hx]]. subst x.
      apply SepE in Hβ as [Hβ Hβ']. apply SingNE in Hβ'. apply IH...
    + ext.
      * apply FUnionE in H as [β [Hβ Hx]].
        apply SepE1 in Hβ. eapply FUnionI...
      * apply FUnionE in H as [β [Hβ Hx]].
        assert (Hoβ: β ⋵ 𝐎𝐍). apply (ord_is_ords α)...
        apply (FUnionI _ _ β⁺). apply SepI.
        apply sucord_in_limord... apply SingNI. apply suc_neq_0.
        eapply ord_trans... apply ordTet_normal...
        eapply ord_trans_lt_le. auto. apply embed_ran. apply limord_ge_ω...
  Unshelve. auto.
Qed.

Corollary ordTet_preserve_lt : ∀ α β γ ⋵ 𝐎𝐍, 1 ∈ α →
  β ∈ γ ↔ α ^^ β ∈ α ^^ γ.
Proof with eauto.
  intros α Hα β Hβ γ Hγ Hα1. split; intros H.
  apply ordTet_normal...
  destruct (classic (β = γ)).
  - subst. exfalso. eapply ord_irrefl; revgoals...
  - apply ord_connected in H0 as []...
    apply (proj1 (ordTet_normal α Hα Hα1)) in H0...
    exfalso. eapply ord_not_lt_gt; revgoals...
Qed.

Corollary ordTet_cancel : ∀ α β γ ⋵ 𝐎𝐍, 1 ∈ α → α ^^ β = α ^^ γ → β = γ.
Proof with eauto.
  intros α Hα β Hβ γ Hγ H1 Heq.
  contra. apply ord_connected in H as [Hlt|Hlt]...
  - assert (α ^^ β ∈ α ^^ γ). apply ordTet_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
  - assert (α ^^ γ ∈ α ^^ β). apply ordTet_normal...
    rewrite Heq in H. eapply ord_irrefl; revgoals...
Qed.

Theorem ordTet_preserve_le_l : ∀ α β γ ⋵ 𝐎𝐍,
  α ⋸ β → α ^^ γ ⋸ β ^^ γ.
Proof with eauto.
  intros α Hα β Hβ γ Hγ Hle.
  generalize dependent γ.
  ord_induction; intros γ Hγ IH.
  ord_destruct γ.
  - subst. rewrite ordTet_0_r, ordTet_0_r...
  - destruct Hsuc as [δ [Hδ Heq]]. subst.
    destruct Hle; [|subst; right]...
    destruct (classic (β = 0)) as [|Hβ0]. {
      subst. exfalso0.
    }
    destruct (classic (β = 1)) as [|Hβ1]. {
      subst. rewrite one in H. apply SingE in H. subst.
      rewrite ordTet_0_l, ordTet_1_l...
    }
    destruct (classic (α = 0)) as [|Hα0]. {
      subst. rewrite ordTet_0_l...
    }
    destruct (classic (α = 1)) as [|Hα1]. {
      subst. rewrite ordTet_1_l...
    }
    destruct (classic (δ = 0)) as [|Hδ0]. {
      subst. rewrite ordTet_1_r, ordTet_1_r...
    }
    apply ord_le_iff_sub... rewrite ordTet_suc, ordTet_suc...
    intros x Hx. apply BUnionE in Hx as [Hx|Hx].
    + apply BUnionI1. eapply ord_trans_lt_le... clear Hx.
      eapply ord_trans_le. auto.
      apply ordExp_preserve_le_r. 5: apply IH. 1-5: auto.
      apply ordExp_preserve_le_l...
    + apply BUnionI2. eapply ord_trans_lt_le... clear Hx.
      eapply ord_trans_le. auto.
      apply ordExp_preserve_le_l. 4: apply IH. 1-4: auto.
      apply ordExp_preserve_le_r...
  - apply ord_le_iff_sub...
    rewrite ordTet_limit, ordTet_limit...
    intros x Hx. apply FUnionE in Hx as [δ [Hδ Hx]].
    assert (Hoδ: δ ⋵ 𝐎𝐍). eapply ord_is_ords...
    eapply FUnionI... apply IH in Hδ as []...
    eapply ord_trans... congruence.
Qed.

Fact ordTet_preserve_le_r : ∀ α β γ ⋵ 𝐎𝐍, 1 ∈ γ →
  α ⋸ β → γ ^^ α ⋸ γ ^^ β.
Proof.
  intros α Hα β Hβ γ Hγ H0 [].
  left. apply ordTet_preserve_lt; auto.
  right. congruence.
Qed.

Lemma ordTet_enlarge_r : ∀ α β ⋵ 𝐎𝐍, 1 ∈ α → 1 ∈ β → α ∈ α ^^ β.
Proof with nauto.
  intros α Hα β Hβ Hα1 Hβ1. rewrite <- ordTet_1_r at 1...
  apply ordTet_preserve_lt... apply ord_gt_1_neq_0_1...
Qed.

Lemma ordTet_enlarge_l : ∀ α β ⋵ 𝐎𝐍, 1 ∈ β → α ⋸ β ^^ α.
Proof with auto.
  intros α Hα β Hβ Hβ1.
  apply monotone_operation_weakly_increasing...
  apply ordTet_normal...
Qed.

Lemma ordTet_enlarge_lt : ∀ α β γ ⋵ 𝐎𝐍, γ ≠ 0 → α ∈ β → α ∈ β ^^ γ.
Proof with neauto.
  intros α Hα β Hβ γ Hγ H0 Hle.
  destruct (classic (β = 0)). subst. exfalso0.
  destruct (classic (β = 1)). {
    subst. rewrite one in Hle. apply SingE in Hle.
    subst. apply ord_neq_0_gt_0...
  }
  destruct (classic (γ = 1)). subst. rewrite ordTet_1_r...
  rewrite <- (ordTet_1_r β) in Hle...
  eapply (ord_trans (β ^^ γ))...
  apply ordTet_preserve_lt...
Qed.

Lemma ordTet_enlarge_le : ∀ α β γ ⋵ 𝐎𝐍, γ ≠ 0 → α ⋸ β → α ⋸ β ^^ γ.
Proof with neauto.
  intros α Hα β Hβ γ Hγ H0 Hle.
  destruct (classic (β = 0)). {
    subst. rewrite ordTet_0_l...
    destruct Hle. exfalso0. subst...
  }
  destruct (classic (β = 1)). subst. rewrite ordTet_1_l...
  rewrite <- (ordTet_1_r β) in Hle...
  eapply ord_trans_le. auto. apply Hle.
  apply ordTet_preserve_le_r...
  apply ord_le_iff_not_gt... intros Hγ1.
  rewrite one in Hγ1. apply SingE in Hγ1...
Qed.

Section Epsilon.
Local Notation ε := (ε ω).
Local Hint Resolve ε_has_n ε_neq_0 : core.

Theorem ω_tet_ω : ω ^^ ω = ε 0.
Proof. apply ordTet_ω_eq_ε_0; nauto. Qed.

Lemma ε_exp_ω : ∀α ⋵ 𝐎𝐍, (ε α) ^ ω = (ω ^^⁰ 2) (ε α)⁺.
Proof with nauto.
  intros α Hα.
  rewrite (pred 2), ordTet0_suc...
  rewrite (pred 1), ordTet0_suc...
  rewrite ordTet0_0, <- ordAdd_1_r, <- ordExp_add, ordExp_1_r...
  rewrite epsilon, <- ordExp_mul, epsilon...
Qed.

Fact ωtω_1 : ω ^^ (ω + 1) = (ω ^^⁰ 2) (ε 0)⁺.
Proof with nauto.
  rewrite (pred 1), ordAdd_suc, ordTet_suc, ordAdd_0_r...
  rewrite ordTet_ω_eq_ε_0, <- ε_exp_ω, ord_max_r...
  rewrite epsilon... left. apply ordExp_enlarge_r...
Qed.

Fact ωtω_2 : ω ^^ (ω + 2) = (ω ^^⁰ 3) (ε 0)⁺.
Proof with nauto.
  rewrite (pred 2), ordAdd_suc, ordTet_suc, ord_max_l...
  - rewrite (pred 3), ordTet0_suc, ωtω_1...
  - rewrite ωtω_1, <- ε_exp_ω... left.
    rewrite <- (epsilon) at 1...
    rewrite ordExp_mul, ordExp_mul...
    apply ordExp_preserve_lt...
    apply (ord_trans_le_lt _ (ε 0 ⋅ ε 0))...
    apply ordMul_preserve_le_r... rewrite <- epsilon_mul...
    apply ordMul_preserve_le_r... apply ε_ge_ω...
    rewrite <- (ordExp_2_r)... apply ordExp_preserve_lt...
Qed.

Lemma ωtω_n_gt_ω : ∀n ∈ ω, n ≠ 0 → ω ∈ ω ^^ (ω + n).
Proof with nauto.
  intros n Hn Hn0. apply ordTet_enlarge_r...
  eapply ord_trans. auto. apply embed_ran. apply ordAdd_enlarge_r...
Qed.

Lemma ωtω_exp_ω_r_lt_l : ∀n ∈ ω, n ≠ 0 → ω ^^ (ω + n) ^ ω ⋸ ω ^ ω ^^ (ω + n).
Proof with nauto.
  intros n Hn. ω_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. rewrite suc, add_0_l, ωtω_1...
    rewrite (pred 2), ordTet0_suc, ordTet0_1...
    assert (Hε: ε 0 ⋵ 𝐎𝐍)... left.
    rewrite ordExp_mul... apply ordExp_preserve_lt...
    rewrite <- (ordExp_1_r ω) at 3...
    rewrite ordExp_add... apply ordExp_preserve_lt...
    rewrite ordExp_suc, epsilon...
    rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_1...
    eapply (ord_trans _ _ _ (ε 0 + ε 0)).
    apply ordAdd_preserve_lt... rewrite <- ordMul_2_r...
    apply ordMul_preserve_lt...
  - rewrite ordAdd_suc, ordTet_suc, ord_max_l...
    rewrite ordExp_mul... apply ordExp_preserve_le_r...
    eapply ord_trans_le; revgoals... left.
    eapply (ord_trans _ _ _ (ω ^^ (ω + m) ⋅ ω ^^ (ω + m))).
    apply ordMul_preserve_lt... apply ωtω_n_gt_ω...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
    eapply ord_trans. auto. apply embed_ran. apply ωtω_n_gt_ω...
  Unshelve. 1-2: auto.
Qed.

Theorem ωtω_n : ∀n ∈ ω, n ≠ 0 → ω ^^ (ω + n) = (ω ^^⁰ n⁺) (ε 0)⁺.
Proof with nauto.
  intros n Hn. ω_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0]. subst. apply ωtω_1.
  rewrite ordAdd_suc, ordTet0_suc, <- IH...
  rewrite ordTet_suc, ord_max_l, IH...
  apply ωtω_exp_ω_r_lt_l...
Qed.

Lemma ε_tet0_n : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, n ≠ 0 → (ε α ^^⁰ n) ω = (ω ^^⁰ n⁺) (ε α)⁺.
Proof with nauto.
  intros α Hα n Hn. ω_induction n; intros H0. exfalso...
  destruct (classic (m = 0)) as [Hm0|Hm0].
  - subst. rewrite ordTet0_1, ε_exp_ω...
  - rewrite ordTet0_suc, ordTet0_suc, IH, ordTet0_suc...
    rewrite <- epsilon at 1...
    rewrite ordExp_mul... 2: apply ordExp_ran... f_equal.
    rewrite <- epsilon at 1... rewrite ordExp_add... f_equal.
    ω_destruct m. exfalso...
    rewrite <- epsilon at 1... rewrite ordTet0_suc...
    apply ordAdd_ω_pow_absorption...
    clear Hn n Hm0 H0 IH Hm. rename m into n.
    ω_induction n.
    + rewrite ordTet0_0...
    + rewrite ordTet0_suc... eapply ord_trans_lt_le; revgoals.
      apply ordExp_enlarge_l... apply IH. apply ordExp_ran...
Qed.

Theorem ωtω_ω : ω ^^ (ω + ω) = ε 1.
Proof with neauto.
  rewrite pred, ε_suc...
  erewrite <- (ordTet0_eq_ordTetL_ω (ε 0) _ ω)... 2: {
    rewrite ε_0... apply (FUnionI _ _ 1)...
    rewrite ordTetL_1_r... apply ordExp_enlarge_r...
  }
  rewrite ordTet_limit, ordTet0_limit...
  2: apply ordAdd_is_limord...
  2: intros H; apply ordAdd_eq_0 in H as []...
  ext.
  - apply FUnionE in H as [α [Hα H]].
    assert (Hoα: α ⋵ 𝐎𝐍). apply (ord_is_ords (ω + ω))...
    rewrite ordAdd_limit in Hα...
    apply FUnionE in Hα as [n [Hn Hα]].
    ω_destruct n.
    + apply (FUnionI _ _ 1)... rewrite ordTet0_1...
      eapply ord_trans... rewrite <- ω_tet_ω.
      eapply ord_trans. auto. apply ordTet_preserve_lt; revgoals...
      rewrite ordAdd_0_r... apply ordExp_enlarge_r...
    + apply (FUnionI _ _ n⁺)... rewrite ε_tet0_n, <- ωtω_n...
      eapply ord_trans... apply ordTet_preserve_lt...
  - apply FUnionE in H as [n [Hn H]].
    ω_destruct n.
    + rewrite ordTet0_0 in H...
      apply (FUnionI _ _ 1)... 2: rewrite ordTet_1_r...
      eapply ord_trans. auto. apply embed_ran.
      apply ordAdd_enlarge_r...
    + rewrite ε_tet0_n, <- ωtω_n in H...
      eapply FUnionI... apply ordAdd_preserve_lt...
  Unshelve. apply ε_operative...
Qed.

Definition ε_k := λ k, ε k = ω ^^ (ω ⋅ k⁺).

Lemma ωtωk_1 : ∀k ∈ ω, ε_k k → ω ^^ (ω ⋅ k⁺ + 1) = (ω ^^⁰ 2) (ε k)⁺.
Proof with nauto.
  intros k Hk IH.
  rewrite (pred 1), ordAdd_suc, ordTet_suc, ordAdd_0_r...
  repeat rewrite <- IH. rewrite <- ε_exp_ω, ord_max_r...
  rewrite epsilon... left. apply ordExp_enlarge_r...
Qed.

Lemma ωtωk_exp_ω_r_lt_l : ∀ k n ∈ ω, ε_k k → n ≠ 0 → ω ^^ (ω ⋅ k⁺ + n) ^ ω ⋸ ω ^ ω ^^ (ω ⋅ k⁺ + n).
Proof with nauto.
  intros k Hk n Hn IHk. ω_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. rewrite ωtωk_1, <- ordTet0_suc...
    repeat rewrite pred... repeat rewrite ordTet0_suc...
    rewrite ordTet0_0... left. rewrite ordExp_mul...
    assert (Hran: ω ^ (ε k)⁺ ⋵ 𝐎𝐍). apply ordExp_ran...
    apply ordExp_preserve_lt...
    rewrite <- (ordExp_1_r ω) at 3... rewrite ordExp_add...
    apply ordExp_preserve_lt...
    rewrite <- ordAdd_1_r, ordAdd_assoc, ordAdd_1_1...
    eapply (ord_trans _ _ _ (ε k + ε k)).
    apply ordAdd_preserve_lt... rewrite <- ordMul_2_r...
    rewrite <- ordExp_add, epsilon, ordExp_1_r...
    apply ordMul_preserve_lt...
  - assert (Hran: ω ^^ (ω ⋅ k⁺ + m) ⋵ 𝐎𝐍). apply ordTet_ran...
    assert (Hsum0: ω ⋅ k⁺ + m ≠ 0). {
      intros H. apply ordAdd_eq_0 in H as []...
    }
    assert (Hsum1: ω ⋅ k⁺ + m ≠ 1). {
      intros H. apply ordAdd_eq_1 in H as [[H _]|[]]...
      apply ordMul_eq_0 in H as []... apply (suc_neq_0 k)...
    }
    assert (Htet1: 1 ∈ ω ^^ (ω ⋅ k⁺ + m)). apply ordTet_gt_1...
    rewrite ordAdd_suc, ordTet_suc, ord_max_l...
    rewrite ordExp_mul... apply ordExp_preserve_le_r...
    eapply ord_trans_le; revgoals... left.
    eapply (ord_trans _ _ _ (ω ^^ (ω ⋅ k⁺ + m) ⋅ ω ^^ (ω ⋅ k⁺ + m))).
    apply ordMul_preserve_lt... apply ord_gt_1_neq_0_1...
    apply ordTet_enlarge_r... apply ord_neq_0_1_gt_1...
    rewrite <- ordExp_2_r... apply ordExp_preserve_lt...
  Unshelve. apply ordExp_ran... auto.
Qed.

Lemma ωtωk_n : ∀ k n ∈ ω, ε_k k → n ≠ 0 → ω ^^ (ω ⋅ k⁺ + n) = (ω ^^⁰ n⁺) (ε k)⁺.
Proof with nauto.
  intros k Hk n Hn IHk. ω_induction n; intros Hn0. exfalso...
  destruct (classic (m = 0)) as [|Hm0].
  - subst. apply ωtωk_1...
  - rewrite ordAdd_suc, ordTet0_suc, <- IH...
    rewrite ordTet_suc, ord_max_l, IH...
    apply ordExp_ran... apply ordTet_ran...
    apply ordExp_ran... apply ordTet_ran...
    apply ωtωk_exp_ω_r_lt_l...
Qed.

Theorem ε_n : ∀n ∈ ω, ε n = ω ^^ (ω ⋅ n⁺).
Proof with neauto.
  intros n Hn. ω_induction n.
  - subst. rewrite ordMul_1_r, ω_tet_ω...
  - assert (H0: ω ⋅ m⁺ ≠ 0). {
      intros H. apply ordMul_eq_0 in H as []... eapply suc_neq_0...
    }
    rewrite ε_suc, ordMul_suc...
    erewrite <- (ordTet0_eq_ordTetL_ω (ε m) _ ω)... 2: {
      rewrite IH. apply ordTet_enlarge_r...
      apply ord_neq_0_1_gt_1... intros H.
      apply ordMul_eq_1 in H as []...
      apply (nat_irrefl 1)... rewrite <- H at 2...
    }
    rewrite ordTet0_limit, ordTet_limit...
    2: apply ordAdd_is_limord...
    2: intros H; apply ordAdd_eq_0 in H as []...
    ext.
    + apply FUnionE in H as [k [Hk H]].
      ω_destruct k.
      * rewrite ordTet0_0 in H...
        apply (FUnionI _ _ 1)... 2: rewrite ordTet_1_r...
        eapply ord_trans_lt_le. auto. apply embed_ran.
        apply ordAdd_enlarge_l...
      * rewrite ε_tet0_n, <- ωtωk_n in H...
        eapply FUnionI... apply ordAdd_preserve_lt...
    + apply FUnionE in H as [α [Hα Hx]].
      assert (Hoα: α ⋵ 𝐎𝐍). apply (ord_is_ords (ω ⋅ m⁺ + ω))...
      rewrite ordAdd_limit in Hα...
      apply FUnionE in Hα as [k [Hk Hα]].
      ω_destruct k.
      * apply (FUnionI _ _ 1)... rewrite ordTet0_1...
        eapply ord_trans... eapply ord_trans. nauto.
        apply ordTet_preserve_lt; revgoals...
        rewrite ordAdd_0_r, IH... apply ordExp_enlarge_r...
      * apply (FUnionI _ _ k⁺)... rewrite ε_tet0_n, <- ωtωk_n...
        eapply ord_trans... apply ordTet_ran... apply ordAdd_ran...
        apply ordTet_preserve_lt... apply ordAdd_ran...
  Unshelve. apply ε_operative...
Qed.

Corollary ε_ω : ε ω = ω ^^ (ω ^ 2).
Proof with neauto.
  rewrite ε_limit, ordExp_2_r, ordTet_limit...
  2: apply ordMul_is_limord_l...
  2: intros H; apply ordMul_eq_0 in H as []...
  ext.
  - apply FUnionE in H as [n [Hn H]]. rewrite ε_n in H...
    apply (FUnionI _ _ (ω ⋅ n⁺))... apply ordMul_preserve_lt...
    apply ω_inductive...
  - apply FUnionE in H as [α [Hα H]].
    assert (Hoα: α ⋵ 𝐎𝐍). apply (ord_is_ords (ω ⋅ ω))...
    rewrite ordMul_limit in Hα...
    apply FUnionE in Hα as [n [Hn Hα]].
    apply (FUnionI _ _ n)... rewrite ε_n...
    eapply ord_trans... apply ordTet_preserve_lt...
    eapply ord_trans... apply ordMul_preserve_lt...
Qed.

End Epsilon.
