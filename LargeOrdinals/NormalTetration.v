(** Coq coding by choukh, Sep 2021 **)

Require Export ZFC.Elements.EST8_8.
Require Import ZFC.LargeOrdinals.GeneralEpsilon.
Import OrdinalClass ğğOperation.

Local Hint Resolve
  add_ran mul_ran exp_ran ordAdd_ran ordMul_ran
  preOrdExp_ran ordExp_ran ordTetL_ran
  Îµ_operative bunion_of_ords_is_ord : core.

(** è¿­ä»£å¹‚æ¬¡ **)
(** Tetration **)
(* adapted from https://math.stackexchange.com/a/3768438/815418 *)
Definition OrdTet := Î» Î±, Operation 1 (Î» Î¾, Î± ^ Î¾ âˆª Î¾ ^ Î±).
Notation "Î± ^^ Î²" := (OrdTet Î± Î²) (at level 25) : OrdArith_scope.

Theorem ordTet_0_r : âˆ€Î± â‹µ ğğ, Î± ^^ 0 = 1.
Proof. intros Î± H. apply operation_0; auto. Qed.

Theorem ordTet_suc : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î²âº = Î± ^ (Î± ^^ Î²) âˆª (Î± ^^ Î²) ^ Î±.
Proof. intros Î± HÎ± Î² HÎ². apply operation_suc; auto. Qed.

Theorem ordTet_limit : âˆ€Î± â‹µ ğğ, continuous (OrdTet Î±).
Proof. intros Î± HÎ±. apply operation_limit; auto. Qed.

Theorem ordTet_ran : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² â‹µ ğğ.
Proof with nauto.
  intros Î± HÎ± Î² HÎ². apply operation_operative...
Qed.
Local Hint Resolve ordTet_ran : core.

Theorem ordTet_0_l : âˆ€Î± â‹µ ğğ, 0 ^^ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [Î³ [HÎ³ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_0_l, ordExp_0_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [Î² HÎ²]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_1_r : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ Î± ^^ 1 = Î±.
Proof with nauto.
  intros Î± H H0. rewrite pred, ordTet_suc...
  rewrite ordTet_0_r, ordExp_1_r, ordExp_1_l, ord_max_l...
  apply ord_suc_correct...
Qed.

Theorem ordTet_1_l : âˆ€Î± â‹µ ğğ, 1 ^^ Î± = 1.
Proof with neauto.
  ord_induction. intros Î± HÎ± IH.
  ord_destruct Î±.
  - subst. apply ordTet_0_r...
  - destruct Hsuc as [Î³ [HÎ³ H]]. subst.
    rewrite ordTet_suc, IH, ordExp_1_r, ord_max_r...
  - rewrite ordTet_limit... ext.
    + apply FUnionE in H as [Î² [HÎ² H]]. rewrite IH in H...
    + apply EmptyNE in H0 as [Î² HÎ²]. eapply FUnionI... rewrite IH...
Qed.

Theorem ordTet_eq_L : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ âˆ€n âˆˆ Ï‰, Î± ^^ nâº = Î± ^^á´¸ n.
Proof with nauto.
  intros Î± HÎ± HÎ±0 n Hn.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTet_1_l, ordTetL_1_l...
  }
  destruct (classic (Î± = 2)) as [|HÎ±2]. {
    subst. Ï‰_induction n.
    - rewrite ordTet_1_r, ordTetL_0...
    - destruct (classic (m = 0)) as [|Hm0]. {
        subst. rewrite ordTet_suc, IH...
        rewrite ordTetL_suc, ordTetL_0, ord_max_l...
      }
      rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
      apply ordTetL_exp_r_le_l...
  }
  Ï‰_induction n.
  - rewrite ordTet_1_r, ordTetL_0...
  - destruct (classic (m = 0)) as [|Hm0]. {
      subst. rewrite ordTet_suc, IH...
      rewrite ordTetL_suc, ordTetL_0, ord_max_l...
    }
    rewrite ordTet_suc, IH, ordTetL_suc, ord_max_l...
    left. apply ordTetL_exp_r_lt_l... contra.
    apply ord_le_iff_not_gt in H as []...
    rewrite two in H. apply TwoE in H as []... rewrite <- one in H...
Qed.

Theorem ordTet_suc_l : âˆ€Î± â‹µ ğğ, Î± â‰  0 â†’ âˆ€n âˆˆ Ï‰, Î± ^^ nâº = Î± ^ (Î± ^^ n).
Proof with auto.
  intros Î± HÎ± HÎ±0 n Hn.
  destruct (classic (Î± = 1)) as [|HÎ±1]. {
    subst. rewrite ordTet_1_l, ordTet_1_l, ordExp_1_r...
  }
  Ï‰_induction n.
  - rewrite ordTet_1_r, ordTet_0_r, ordExp_1_r...
  - rewrite ordTet_eq_L, ordTet_eq_L, ordTetL_suc...
    apply Ï‰_inductive...
Qed.

Theorem ordTet_Ï‰_eq_Îµ_0 : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ Î± ^^ Ï‰ = Îµ Î± 0.
Proof with neauto.
  intros Î± HÎ± HÎ±1.
  apply ord_gt_1_neq_0_1 in HÎ±1 as [HÎ±0 HÎ±1]...
  rewrite ordTet_limit... ext.
  - apply FUnionE in H as [n [Hn Hx]].
    Ï‰_destruct n.
    + rewrite ordTet_0_r, one in Hx...
      apply SingE in Hx. subst. apply Îµ_has_n...
    + rewrite Îµ_0... rewrite ordTet_eq_L in Hx... eapply FUnionI...
  - rewrite Îµ_0 in H... apply FUnionE in H as [n [Hn Hx]].
    rewrite <- ordTet_eq_L in Hx...
    eapply (FUnionI _ _ nâº)... apply Ï‰_inductive...
Qed.

Lemma ordTet_neq_0 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² â‰  0.
Proof with eauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH H.
  ord_destruct Î².
  - subst. rewrite ordTet_0_r in H...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    rewrite ordTet_suc in H...
    apply union_eq_empty in H as [].
    + apply EmptyNI in H... exists (Î± ^ Î± ^^ Î³)... apply PairI1.
    + symmetry in H. apply single_eq_pair in H as [H Heq].
      symmetry in H. apply ordExp_eq_0 in H...
      subst. rewrite ordExp_0_l, ordExp_0_r in Heq...
  - rewrite ordTet_limit in H...
    apply union_eq_empty in H as [].
    + apply repl_eq_empty in H. exfalso...
    + apply EmptyNE in H0 as [Î³ HÎ³].
      assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
      apply sucord_in_limord in HÎ³...
      eapply repl_eq_1 in HÎ³ as H0... eapply IH...
Qed.

Lemma ordTet_gt_1 : âˆ€ Î± Î² â‹µ ğğ, 1 âˆˆ Î± â†’ Î² â‰  0 â†’ 1 âˆˆ Î± ^^ Î².
Proof with neauto.
  intros Î± HÎ±. ord_induction. intros Î² HÎ² IH HÎ±1 HÎ²0.
  ord_destruct Î².
  - subst...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    rewrite ordTet_suc... eapply ord_trans... auto.
    apply BUnionI1. apply ordExp_enlarge_r...
  - rewrite ordTet_limit...
    apply EmptyNE in H0 as [Î³ HÎ³].
    assert (HoÎ³: Î³ â‹µ ğğ). eapply ord_is_ords...
    eapply FUnionI. apply sucord_in_limord...
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordTet_1_r... apply ord_gt_1_neq_0_1...
    }
    eapply ord_trans_lt_le. auto. apply IH...
    rewrite ordTet_suc... left. apply BUnionI2. apply ordExp_enlarge_r...
Qed.

Theorem ordTet_eq_1 : âˆ€ Î± Î² â‹µ ğğ, Î± ^^ Î² = 1 â†’ Î± = 0 âˆ¨ Î± = 1 âˆ¨ Î² = 0.
Proof with neauto.
  intros Î± HÎ± Î² HÎ² H.
  destruct (classic (Î± = 0))...
  destruct (classic (Î± = 1))...
  destruct (classic (Î² = 0))... exfalso.
  apply (ord_irrefl 1)... rewrite <- H at 2.
  apply ordTet_gt_1...
Qed.

Theorem ordTet_normal : âˆ€Î± â‹µ ğğ, 1 âˆˆ Î± â†’ normal (OrdTet Î±).
Proof with nauto.
  intros Î± HÎ± HÎ±1. apply operation_normal...
  fold (OrdTet Î±). intros x Hx.
  destruct (classic (x = 0)) as [|Hx0]. {
    subst. rewrite ordTet_0_r, ordTet_1_r... apply ord_gt_1_neq_0_1...
  }
  rewrite ordTet_suc... apply BUnionI2.
  apply ordExp_enlarge_r... apply ordTet_gt_1...
Qed.
