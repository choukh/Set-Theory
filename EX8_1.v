(** Coq coding by choukh, Feb 2021 **)

Require Export ZFC.EST8_2.

Section EX8_1_and_2.
Import ğğOperation.
Close Scope Card_scope.
Open Scope Nat_scope.

Definition t := Operation 5 Suc.

Example ex8_2_a : âˆ€Î± âˆˆ Ï‰, t Î± = 5 + Î±.
Proof with nauto.
  intros Î± HÎ±.
  set {Î± âˆŠ Ï‰ | Î» Î±, t Î± = 5 + Î±} as N.
  Ï‰_induction N HÎ±; unfold t in *.
  - rewrite operation_0, add_ident...
  - rewrite operation_suc, IH; [|apply nat_is_ord]...
    rewrite add_suc, add_suc, add_assoc... apply add_ran...
Qed.

Example ex8_2_b : âˆ€ Î±, is_ord Î± â†’ Ï‰ â‹¸ Î± â†’ t Î± = Î±.
Proof with neauto.
  set (Î» Î±, Ï‰ â‹¸ Î± â†’ t Î± = Î±) as Ï•.
  apply (transfinite_induction_schema_on_ordinals Ï•).
  intros Î± HoÎ± IH Hle. unfold t.
  destruct (ord_is_suc_or_limit Î±) as [|Hlim]...
  - destruct H as [Î² [HoÎ² Heq]]. subst.
    destruct Hle as [Hlt|Heq].
    + rewrite operation_suc... f_equal.
      apply IH... apply ord_leq_iff_lt_suc...
    + exfalso. apply (ord_is_limit_iff_not_suc Ï‰)...
      exists Î². split...
  - destruct (classic (Î± = âˆ…)). {
      subst. destruct Hle. exfalso0. exfalso. apply Ï‰_neq_0...
    }
    rewrite operation_limit...
    apply ExtAx. split; intros Hx.
    + apply FUnionE in Hx as [n [Hn Hx]].
      assert (Hon: is_ord n). eapply ord_is_ords...
      destruct (classic (Ï‰ â‹¸ n)) as [HÏ‰|HÏ‰]. {
        rewrite IH in Hx... eapply ord_trans...
      }
      assert (HnÏ‰: n âˆˆ Ï‰). {
        destruct (classic (n âˆˆ Ï‰))... exfalso.
        apply HÏ‰. apply ord_leq_iff_not_gt...
      }
      rewrite ex8_2_a in Hx...
      apply ord_leq_iff_sub in Hle... apply Hle.
      eapply ord_trans... apply add_ran...
    + assert (Hox: is_ord x). eapply ord_is_ords...
      destruct (classic (Ï‰ â‹¸ xâº)) as [HÏ‰|HÏ‰]. {
        eapply FUnionI. apply suc_in_limit...
        rewrite IH... apply suc_in_limit...
      }
      assert (HxpÏ‰: xâº âˆˆ Ï‰). {
        destruct (classic (xâº âˆˆ Ï‰))... exfalso.
        apply HÏ‰. apply ord_leq_iff_not_gt...
      }
      assert (HxÏ‰: x âˆˆ Ï‰). eapply Ï‰_trans; revgoals...
      eapply FUnionI... rewrite ex8_2_a...
      rewrite <- add_ident at 1...
      rewrite add_comm... apply add_preserve_lt...
      repeat rewrite pred. do 4 apply BUnionI1. apply BUnionI2...
Qed.

End EX8_1_and_2.

(* ex8_6_a see EST8_1 Lemma monotone_operation_range_unbounded *)
(* ex8_6_b see EST8_1 Lemma normal_operation_range_closed *)
