(** Coq coding by choukh, Aug 2021 **)

Require Import ZFC.Lib.ChoiceFacts.
Require Import ZFC.Lib.FuncFacts.
Require Import ZFC.Elements.EST8_7.
Require Export ZFC.Lib.OrdFacts.

Local Hint Resolve ordAdd_ran ordMul_ran ordExp_ran : core.

(*** åºæ•°çš„å¯æ•°æ€§ ***)

(* å¯æ•°éé›¶æé™åºæ•°æ˜¯å¯æ•°æ— ç©· *)
Theorem countable_limit_ordinal_cntinf :
  âˆ€ğœ† â‹µ ğğË¡â±áµ, ğœ† â‰  âˆ… â†’ countable ğœ† â†’ ğœ† â‰ˆ Ï‰.
Proof with auto.
  intros ğœ† Hğœ† Hne Hcnt.
  apply limord_is_inford in Hğœ† as [Hğœ† Hinf]...
  apply countable_iff in Hcnt as []... exfalso...
Qed.

(* å¯æ•°é›†é™¤å»ä»»æ„å¤šä¸ªå…ƒç´ ä»æ˜¯å¯æ•°é›† *)
Lemma remove_members_from_cnt :
  âˆ€ A B, countable A â†’ countable (A - B).
Proof.
  intros A B Hcnt. eapply dominate_trans. 2: apply Hcnt.
  apply dominate_sub. auto.
Qed.

(* åºæ•°å¯æ•°å¦‚æœå…¶åç»§å¯æ•° *)
Corollary ord_cnt_if_suc_cnt :
  âˆ€Î± â‹µ ğğ, countable Î±âº â†’ countable Î±.
Proof with auto.
  intros Î± HÎ± Hcnt. rewrite <- (add_one_member_then_remove Î± Î±).
  apply remove_members_from_cnt... apply ord_irrefl...
Qed.

(* å¾€å¯æ•°æ— ç©·åŠ å…¥å¯æ•°å¤šä¸ªå…ƒç´ ä»æ˜¯å¯æ•°æ— ç©· *)
Lemma add_countably_many_members_to_cntinf :
  âˆ€ A B, |A| = â„µâ‚€ â†’ countable B â†’ |A âˆª B| = â„µâ‚€.
Proof with nauto.
  intros A B Hcinf Hcnt. rewrite <- ex2_11_2.
  apply CardAx1, cardAdd_disjoint_iff.
  apply binter_comp_empty. rewrite Hcinf.
  apply cardLe_antisym.
  - rewrite <- cardAdd_aleph0_aleph0 at 2.
    apply cardAdd_preserve_le'. apply cardLe_iff.
    apply remove_members_from_cnt...
  - rewrite <- cardAdd_0_r at 1. 2: exists Ï‰...
    apply cardAdd_preserve_le'. repeat split...
    apply dominate_sub. intros x Hx. exfalso0.
Qed.

(* å¯æ•°æ— ç©·é™¤å»ä¸€ä¸ªå…ƒç´ ä»æ˜¯å¯æ•°æ— ç©· *)
Lemma remove_one_member_from_cntinf :
  âˆ€ a A, |A| = â„µâ‚€ â†’ |A - {a,}| = â„µâ‚€.
Proof with eauto; try congruence.
  intros a A Hcinf.
  destruct (classic (a âˆˆ A)) as [|Ha'].
  2: rewrite remove_no_member...
  symmetry. apply CardAx1.
  symmetry in Hcinf. apply CardAx1 in Hcinf as [f Hbi].
  assert (H' := Hbi). apply bijection_is_func in H' as [Hf [Hi Hr]].
  assert (H' := Hf). destruct H' as [_ [Hd _]].
  set (Func Ï‰ (A - {a,}) (Î» n, match (ixm (n âˆˆ fâ»Â¹[a])) with
    | inl _ => f[n]
    | inr _ => f[nâº]
  end)) as g.
  exists g. apply meta_bijection.
  - intros n Hn. destruct (ixm (n âˆˆ fâ»Â¹[a])).
    + apply SepI. eapply ap_ran...
      apply SingNI. intros Hfn.
      rewrite <- Hfn, inv_dom_reduction in i...
      apply (nat_irrefl n)...
    + apply SepI. eapply ap_ran... apply Ï‰_inductive...
      apply SingNI. intros Hfn.
      rewrite <- Hfn, inv_dom_reduction in n0...
      rewrite Hd. apply Ï‰_inductive...
  - intros n1 H1 n2 H2 Heq.
    destruct (ixm (n1 âˆˆ fâ»Â¹[a]));
    destruct (ixm (n2 âˆˆ fâ»Â¹[a])).
    + apply injectiveE in Heq...
    + apply injectiveE in Heq... 2: rewrite Hd; apply Ï‰_inductive...
      exfalso. rewrite Heq in i. apply n. eapply nat_trans.
      eapply ap_ran... apply bijection_is_func, inv_bijection...
      2: apply i. apply BUnionI2...
    + apply injectiveE in Heq... 2: rewrite Hd; apply Ï‰_inductive...
      exfalso. rewrite <- Heq in i. apply n. eapply nat_trans.
      eapply ap_ran... apply bijection_is_func, inv_bijection...
      2: apply i. apply BUnionI2...
    + apply injectiveE in Heq... 2-3: rewrite Hd; apply Ï‰_inductive...
      apply suc_injective in Heq...
  - intros y Hy. apply SepE in Hy as [Hy Hy']. apply SingNE in Hy'.
    assert (Hyw: (fâ»Â¹)[y] âˆˆ Ï‰). {
      eapply ap_ran... apply bijection_is_func, inv_bijection...
    }
    assert (Haw: (fâ»Â¹)[a] âˆˆ Ï‰). {
      eapply ap_ran... apply bijection_is_func, inv_bijection...
    }
    destruct (classic (fâ»Â¹[y] âˆˆ fâ»Â¹[a])).
    + exists (fâ»Â¹[y]). split... destruct (ixm (fâ»Â¹[y] âˆˆ fâ»Â¹[a]))...
      rewrite inv_ran_reduction...
    + set (fâ»Â¹[y]) as n. assert (Hn: n âˆˆ Ï‰)...
      Ï‰_destruct n. {
        apply le_iff_not_gt in H0 as []...
        - rewrite H1 in H0. exfalso0.
        - apply injectiveE in H0... apply inv_injective.
          apply Hbi. 1-2: rewrite inv_dom...
      }
      exists n. split... destruct (ixm (n âˆˆ fâ»Â¹[a])).
      * apply le_iff_not_gt in H0 as []...
        rewrite Heq in H0. exfalso. apply (Ï‰_not_dense n)...
        apply injectiveE in H0... apply inv_injective.
        apply Hbi. 1-2: rewrite inv_dom...
      * rewrite <- Heq. rewrite inv_ran_reduction...
Qed.

(* å¾€ä½œä¸ºå¯æ•°æ— ç©·çš„é›†æ—å¹¶ä¸­åŠ å…¥ä¸€ä¸ªæ›¿ä»£ç›®æ ‡åä»æ˜¯å¯æ•°æ— ç©· *)
Lemma add_one_member_to_funion : âˆ€ a F A, countable (F a) â†’
  |â‹ƒ {F x | x âˆŠ A - {a,}}| = â„µâ‚€ â†’ |â‹ƒ {F x | x âˆŠ A}| = â„µâ‚€.
Proof with auto.
  intros * Hcnt Heq.
  destruct (classic (a âˆˆ A)) as [|Ha'].
  2: rewrite <- (remove_no_member A a)...
  rewrite <- (remove_one_member_then_return A a)...
  rewrite repl_bunion_distr, union_bunion_distr.
  rewrite repl_single, union_single.
  apply add_countably_many_members_to_cntinf...
Qed.

(* å¯æ•°é›†çš„æ›¿ä»£å¯æ•° *)
Lemma repl_of_cnt_cnt : AC_II â†’ âˆ€ F A, countable A â†’ countable {F x | x âˆŠ A}.
Proof with auto.
  intros AC2 F A Hcnt. eapply dominate_trans. 2: apply Hcnt.
  set (Func A {F x | x âˆŠ A} F) as f.
  apply AC_II_to_IV, AC_IV_to_III, AC_III_to_I in AC2.
  apply (domain_of_surjection_dominate_range AC2 _ _ f).
  apply meta_surjection.
  - intros x Hx. eapply ReplI...
  - intros y Hy. apply ReplAx...
Qed.

(* å¯æ•°æ— ç©·åºæ•°éç©º *)
Lemma cntinf_ord_neq_0 : âˆ€Î± â‹µ ğğ, |Î±| = â„µâ‚€ â†’ Î± â‰  0.
Proof.
  intros Î± HÎ± Hcinf H0. subst. symmetry in Hcinf.
  rewrite pred, card_of_empty, card_eq_0 in Hcinf; nauto.
Qed.
Local Hint Resolve cntinf_ord_neq_0 : core.

(* æ¯”å¯æ•°åºæ•°å°çš„åºæ•°å¯æ•° *)
Lemma ord_lt_cnt_cnt :
  âˆ€Î± â‹µ ğğ, countable Î± â†’ âˆ€Î² âˆˆ Î±, countable Î².
Proof with eauto.
  intros Î± HoÎ± Hcnt Î² HÎ².
  assert (HoÎ²: Î² â‹µ ğğ). apply (ord_is_ords Î±)...
  eapply dominate_trans. apply dominate_sub.
  apply ord_lt_iff_psub; revgoals... apply Hcnt.
Qed.

(* å¯æ•°æ— ç©·åºæ•°çš„åç»§æ˜¯å¯æ•°æ— ç©· *)
Theorem ord_suc_cntinf : AC_II â†’ âˆ€Î± â‹µ ğğ, |Î±| = â„µâ‚€ â†’ |Î±âº| = â„µâ‚€.
Proof with neauto.
  intros AC2 Î± HÎ± Hcinf.
  apply add_countably_many_members_to_cntinf...
  apply countableI1. apply single_finite.
Qed.

(* å¯æ•°æ— ç©·åºæ•°çš„å¯æ•°æ¬¡åç»§æ˜¯å¯æ•°æ— ç©· *)
Theorem ord_sum_cntinf : AC_II â†’ âˆ€Î± â‹µ ğğ, |Î±| = â„µâ‚€ â†’
  âˆ€Î² â‹µ ğğ, countable Î² â†’ |Î± + Î²| = â„µâ‚€.
Proof with neauto.
  intros AC2 Î± HÎ± Hcinf. ord_induction.
  intros Î² HÎ² IH Hcnt. ord_destruct Î².
  - subst. rewrite ordAdd_0_r...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordAdd_1_r... apply ord_suc_cntinf...
    }
    rewrite ordAdd_suc... apply ord_suc_cntinf...
    apply IH... rewrite <- (add_one_member_then_remove Î³ Î³).
    apply remove_members_from_cnt... apply ord_irrefl...
  - rewrite ordAdd_limit...
    apply countable_union_of_cntinf...
    + exists Î±. apply ReplAx. exists 0. split.
      apply ord_neq_0_gt_0... rewrite ordAdd_0_r...
    + apply repl_of_cnt_cnt...
    + intros A H. apply ReplAx in H as [Î³ [HÎ³ H]]. subst.
      apply IH... eapply ord_lt_cnt_cnt...
Qed.

(* å¯æ•°æ— ç©·åºæ•°çš„éé›¶å¯æ•°ä¹˜ç§¯æ˜¯å¯æ•°æ— ç©· *)
Theorem ord_prd_cntinf : AC_II â†’ âˆ€Î± â‹µ ğğ, |Î±| = â„µâ‚€ â†’ 
  âˆ€Î² â‹µ ğğ, Î² â‰  0 â†’ countable Î² â†’ |Î± â‹… Î²| = â„µâ‚€.
Proof with neauto.
  intros AC2 Î± HÎ± Hcinf. ord_induction.
  intros Î² HÎ² IH HÎ²0 Hcnt. ord_destruct Î².
  - exfalso...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordMul_1_r...
    }
    rewrite ordMul_suc... apply ord_sum_cntinf...
    + apply IH... rewrite <- (add_one_member_then_remove Î³ Î³).
      apply remove_members_from_cnt... apply ord_irrefl...
    + apply countableI2. apply CardAx1...
  - clear H0. rewrite ordMul_limit...
    apply (add_one_member_to_funion 0). rewrite ordMul_0_r...
    apply countableI1...
    apply countable_union_of_cntinf...
    + exists Î±. apply ReplAx.
      exists 1. split. 2: rewrite ordMul_1_r...
      apply SepI... apply sucord_in_limord...
      apply ord_neq_0_gt_0... apply SingNI...
    + apply repl_of_cnt_cnt, remove_members_from_cnt...
    + intros A H. apply ReplAx in H as [Î³ [HÎ³ H]]. subst.
      apply SepE in HÎ³ as [HÎ³ HÎ³0]. apply SingNE in HÎ³0.
      apply IH... eapply ord_lt_cnt_cnt...
Qed.

(* å¯æ•°æ— ç©·åºæ•°çš„éé›¶å¯æ•°æ¬¡æ–¹æ˜¯å¯æ•°æ— ç©· *)
Theorem ord_pow_cntinf : AC_II â†’ âˆ€Î± â‹µ ğğ, |Î±| = â„µâ‚€ â†’ 
  âˆ€Î² â‹µ ğğ, Î² â‰  0 â†’ countable Î² â†’ |Î± ^ Î²| = â„µâ‚€.
Proof with neauto.
  intros AC2 Î± HÎ± Hcinf. ord_induction.
  intros Î² HÎ² IH HÎ²0 Hcnt. ord_destruct Î².
  - exfalso...
  - destruct Hsuc as [Î³ [HÎ³ Heq]]. subst.
    destruct (classic (Î³ = 0)) as [|HÎ³0]. {
      subst. rewrite ordExp_1_r...
    }
    rewrite ordExp_suc... apply ord_prd_cntinf...
    + apply IH... rewrite <- (add_one_member_then_remove Î³ Î³).
      apply remove_members_from_cnt... apply ord_irrefl...
    + apply countableI2. apply CardAx1...
  - clear H0. rewrite ordExp_limit...
    apply (add_one_member_to_funion 0). rewrite ordExp_0_r...
    apply countableI1. apply nat_finite...
    apply countable_union_of_cntinf...
    + exists Î±. apply ReplAx.
      exists 1. split. 2: rewrite ordExp_1_r...
      apply SepI... apply sucord_in_limord...
      apply ord_neq_0_gt_0... apply SingNI...
    + apply repl_of_cnt_cnt, remove_members_from_cnt...
    + intros A H. apply ReplAx in H as [Î³ [HÎ³ H]]. subst.
      apply SepE in HÎ³ as [HÎ³ HÎ³0]. apply SingNE in HÎ³0.
      apply IH... eapply ord_lt_cnt_cnt...
Qed.
