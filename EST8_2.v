(** Based on "Elements of Set Theory" Chapter 8 Part 2 **)
(** Coq coding by choukh, Feb 2021 **)

Require Import ZFC.lib.Class.
Require Export ZFC.EST8_1.
Import OrdinalClass.

(*** ESTç¬¬å…«ç« 2ï¼šåºæ•°æ“ä½œçš„æ€§è´¨ï¼ŒVeblenä¸åŠ¨ç‚¹å®šç† ***)

(* è§„èŒƒæ“ä½œçš„å®šä¹‰åŸŸæœ‰æœ€å¤§å…ƒ *)
Theorem normal_operation_domain_has_maximum :
  âˆ€ F, F:á¶œ ğğ â‡’ ğğ â†’ normal F â†’ âˆ€Î² â‹µ ğğ, F 0 âˆˆ Î² â†’
  âˆƒÎ³ â‹µ ğğ, Îµ_maximum Î³ (Domain F (RangeAmong F Î²âº)).
Proof with eauto.
  intros F HF [Hmono Hcon] Î² HoÎ² Hlt.
  set (Î» y, âˆƒÎ± â‹µ ğğ, F Î± = y) as C.
  assert (Hsur: F :á¶œ ğğ âŸ¹ C). {
    split. intros Î¾ HoÎ¾. exists Î¾. split... intros Î¾ H...
  }
  assert (Hsub: C â«ƒ ğğ). {
    intros Î¾ [Î± [HoÎ± Heq]]. subst Î¾. apply HF...
  }
  assert (Hinj: class_injective F ğğ). {
    eapply monotone_operation_injective...
  }
  assert (Hran: âˆ€x âˆˆ RangeAmong F Î²âº, x â‹µ C). {
    intros Î¾ HÎ¾. apply SepE2 in HÎ¾...
  }
  set (Domain F (RangeAmong F Î²âº)) as Î³.
  assert (HoÎ³: is_ord Î³). {
    apply transitive_set_well_ordered_by_epsilon_is_ord.
    - intros x y Hxy Hy.
      eapply domain_spec in Hy as [Hoy HFy]...
      assert (Hox: x â‹µ ğğ). eapply ord_is_ords...
      eapply domain_spec... split...
      apply SepI; [apply SepE1 in HFy|exists x; split]...
      eapply ord_trans; revgoals... apply Hmono...
    - apply ords_woset. intros x Hx. eapply domain_spec...
  }
  destruct (ord_is_suc_or_limit Î³) as [|Hlim]...
  - destruct H as [Î¼ [HoÎ¼ Heq]]. rewrite Heq.
    exists Î¼. split... split... intros x Hx.
    apply ord_leq_iff_lt_suc... eapply ord_is_ords; revgoals...
  - exfalso. destruct (classic (Î³ = 0)) as [|Hne].
    + eapply EmptyNI... exists 0.
      eapply domain_spec... split... apply SepI.
      apply BUnionI1... exists 0. split...
    + apply (ord_irrefl Î³)...
      eapply domain_spec... split...
      apply SepI; [|exists Î³; split]...
      apply ord_leq_iff_lt_suc... apply HF...
      rewrite Hcon... apply ord_sup_correct.
      * intros x Hx. apply ReplAx in Hx as [Î± [HÎ± Heq]].
        subst x. apply HF. eapply ord_is_ords...
      * split... intros x Hx.
        apply ReplAx in Hx as [Î± [HÎ± Heq]]. subst x.
        eapply domain_spec in HÎ± as [HÎ± HFÎ±]...
        apply SepE1 in HFÎ±. apply ord_leq_iff_lt_suc... apply HF...
Qed.

(* åºæ•°é›†ä¸Šç•Œçš„è§„èŒƒæ“ä½œç­‰äºåºæ•°é›†è§„èŒƒæ“ä½œçš„ä¸Šç•Œ *)
Theorem operation_of_sup_eq_sup_of_operation :
  âˆ€ F, F:á¶œ ğğ â‡’ ğğ â†’ normal F â†’ âˆ€ S, is_ords S â†’ S â‰  âˆ… â†’
  F (sup S) = sup (Range F S).
Proof with eauto; try congruence.
  intros F HF [Hmono Hcon] S Hos Hne.
  assert (HoS: sup S â‹µ ğğ). apply union_of_ords_is_ord...
  assert (HoF: F (sup S) â‹µ ğğ). apply HF...
  assert (HosR: is_ords (Range F S)). {
    intros x Hx. apply ReplAx in Hx as [Î± [HoÎ± Heq]].
    subst x. apply HF. apply Hos...
  }
  assert (HoR: sup (Range F S) â‹µ ğğ). {
    apply union_of_ords_is_ord...
  }
  apply sub_antisym; apply ord_leq_iff_sub; revgoals...
  - apply ord_sup_correct... split...
    intros Î¾ HÎ¾. apply ReplAx in HÎ¾ as [Î± [HoÎ± Heq]].
    subst Î¾. apply ord_sup_is_ub in Hos as [Ho Hle].
    apply Hle in HoÎ± as []; [left|right]... apply Hmono...
  - destruct (ord_is_suc_or_limit (sup S)) as [|Hlim].
    + apply ord_sup_is_ub...
    + apply ord_sup_correct... eapply ReplI.
      apply sup_of_ords_is_suc_impl_in_ords...
    + destruct (classic (sup S = âˆ…)). {
        rewrite H. apply union_empty_iff in H as []...
        apply ord_sup_is_ub... rewrite H.
        eapply ReplI. apply SingI.
      }
      rewrite Hcon... apply ord_sup_correct.
      * intros x Hx. apply ReplAx in Hx as [Î± [HÎ± Heq]].
        subst x. apply HF. apply (ord_is_ords (sup S))...
      * split... intros Î¾ HÎ¾. left.
        apply ReplAx in HÎ¾ as [Î± [HÎ± Heq]]. subst Î¾.
        apply UnionAx in HÎ± as [Î³ [HÎ³ HÎ±]].
        apply UnionAx. exists (F Î³). split.
        eapply ReplI... apply Hmono... apply Hos...
Qed.

(* ex8_5 å•è°ƒæ“ä½œçš„å€¼ä¸å°äºåŸå€¼ *)
Lemma monotone_operation_leq :
  âˆ€ F, F:á¶œ ğğ â‡’ ğğ â†’ monotone F â†’ âˆ€Î± â‹µ ğğ, Î± â‹¸ F Î±.
Proof with auto.
  intros F HF Hmono. unfold all_in_class, all.
  apply transfinite_induction_schema_on_ordinals.
  intros Î± HoÎ± IH. apply ord_leq_iff_not_gt... apply HF...
  intros HFÎ±. apply Hmono in HFÎ± as HFFÎ±...
  apply IH in HFÎ± as [].
  eapply ord_not_lt_gt; revgoals; eauto; try repeat apply HF...
  eapply ord_not_lt_self; revgoals; eauto; try repeat apply HF...
Qed.

Import ğğOperation.

(* Veblenä¸åŠ¨ç‚¹å®šç†ï¼šè§„èŒƒæ“ä½œå­˜åœ¨ä»»æ„å¤§çš„ä¸åŠ¨ç‚¹ *)
Theorem Veblen_fixed_point : âˆ€ F, F:á¶œ ğğ â‡’ ğğ â†’ normal F â†’
  âˆ€Î² â‹µ ğğ, âˆƒÎ³ â‹µ ğğ, F Î³ = Î³ âˆ§ Î² â‹¸ Î³.
Proof with neauto; try congruence.
  intros F HF Hnml Î² HoÎ².
  assert (H := Hnml). destruct H as [Hmono Hcon].
  eapply monotone_operation_leq in HoÎ² as H...
  destruct H as [Heq|Hlt]; revgoals. exists Î². split...
  set (Operation Î² F) as f.
  set {f | n âˆŠ Ï‰} as S.
  assert (Hne: S â‰  âˆ…). {
    apply EmptyNI. exists (f 0). eapply ReplI...
  }
  assert (Hos: is_ords S). {
    intros x Hx. apply ReplAx in Hx as [n [Hn Hfn]]. subst x.
    apply operation_operative... apply nat_is_ord...
  }
  exists (sup S). repeat split.
  - apply union_of_ords_is_ord...
  - rewrite operation_of_sup_eq_sup_of_operation...
    apply ExtAx. split; intros Hx.
    + apply FUnionE in Hx as [Î± [HÎ± Hx]].
      apply ReplAx in HÎ± as [n [Hn Hfn]]. subst Î±.
      apply UnionAx. exists (f nâº). split.
      eapply ReplI... apply Ï‰_inductive...
      unfold f. rewrite operation_suc... apply nat_is_ord...
    + apply UnionAx in Hx as [y [Hy Hx]].
      apply ReplAx in Hy as [n [Hn Hfn]]. subst y.
      apply (FUnionI _ _ (f n)). eapply ReplI...
      assert (Hof: is_ord (f n)). {
        apply operation_operative... apply nat_is_ord...
      }
      eapply monotone_operation_leq in Hof as H...
      destruct H... eapply ord_trans... apply HF...
  - apply ord_sup_is_ub...
    apply ReplAx. exists 0. split...
    unfold f. rewrite operation_0...
Qed.
